<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="container">
    <div class="sidebar">
        <h2>è¿æ¥è®¾ç½®</h2>

        <!-- è¿æ¥çŠ¶æ€ -->
        <div class="status" id="connectionStatus">æœªè¿æ¥</div>
        <div class="network-info" id="networkInfo">
            ç½‘ç»œçŠ¶æ€: æ£€æµ‹ä¸­...
            <div class="connection-quality">
                <span>è¿æ¥è´¨é‡:</span>
                <div class="quality-indicator" id="qualityIndicator"></div>
                <span id="qualityText">æœªè¿æ¥</span>
            </div>
        </div>

        <!-- è¿æ¥é€‰é¡¹å¡ -->
        <div class="connection-tabs">
            <div class="connection-tab active" data-tab="connect">è¿æ¥</div>
            <div class="connection-tab" data-tab="chats">è”ç³»äºº</div>
            <div class="connection-tab" data-tab="groups">ç¾¤èŠ</div>
        </div>

        <!-- è¿æ¥é¢æ¿ -->
        <div class="connection-panel active" id="connectPanel">
            <!-- ç”¨æˆ·IDæ˜¾ç¤º -->
            <div class="user-id" id="userId">
                æ‚¨çš„ID: <span id="userIdValue">ç”Ÿæˆä¸­...</span>
                <button id="copyIdBtn" style="padding: 2px 5px; font-size: 12px; margin-left: 5px;">å¤åˆ¶</button>
            </div>

            <div class="steps">
                <div class="step">
                    <div class="step-number">1</div>
                    <button onclick="ConnectionManager.createOffer()" id="createOfferBtn">åˆ›å»ºè¿æ¥è¯·æ±‚</button>
                </div>
                <div class="step">
                    <div class="step-number">2</div>
                    <button onclick="ConnectionManager.createAnswer()" id="createAnswerBtn">åˆ›å»ºè¿æ¥å“åº”</button>
                </div>
                <div class="step">
                    <div class="step-number">3</div>
                    <button onclick="ConnectionManager.handleAnswer()" id="handleAnswerBtn">å¤„ç†å¯¹æ–¹å“åº”</button>
                </div>
                <!-- æ·»åŠ é‡ç½®æŒ‰é’® -->
                <div class="reset-container">
                    <button id="resetAllBtn" class="reset-all-btn">é‡ç½®</button>
                </div>
            </div>

            <div class="connection-info">
                <h3>è¿æ¥ä¿¡æ¯</h3>
                <label for="sdpText"></label><textarea id="sdpText" placeholder="ç²˜è´´å¯¹æ–¹çš„è¿æ¥ä¿¡æ¯..."></textarea>
                <button onclick="UIManager.copyText()" class="copy-button">å¤åˆ¶è¿æ¥ä¿¡æ¯</button>
            </div>

            <div class="debug-info" id="debugInfo"></div>
        </div>

        <!-- è”ç³»äººåˆ—è¡¨é¢æ¿ -->
        <div class="connection-panel" id="chatsPanel">

            <div class="chat-actions">
                <button id="newChatBtn" class="new-chat-btn">æ·»åŠ æ–°èŠå¤©</button>
                <button id="clearContactsBtn" class="clear-contacts-btn">æ¸…ç©ºè”ç³»äººåˆ—è¡¨</button>
            </div>

            <!-- æ–°å»ºèŠå¤©è¡¨å• -->
            <div class="new-chat-form" id="newChatForm">
                <label for="peerIdInput"></label><input type="text" id="peerIdInput" placeholder="è¾“å…¥å¯¹æ–¹ID">
                <label for="peerNameInput"></label><input type="text" id="peerNameInput" placeholder="è¾“å…¥å¯¹æ–¹æ˜µç§°">
                <div class="form-buttons">
                    <button class="cancel-btn" id="cancelNewChatBtn">å–æ¶ˆ</button>
                    <button id="confirmNewChatBtn">ç¡®è®¤</button>
                </div>
            </div>

            <!-- è”ç³»äººåˆ—è¡¨ -->
            <div class="chat-list" id="chatList">
                <!-- èŠå¤©é¡¹ä¼šåŠ¨æ€æ·»åŠ  -->
            </div>
        </div>
        <!-- ç¾¤èŠé¢æ¿ -->
        <div class="connection-panel" id="groupsPanel">
            <div class="group-actions">
                <button id="newGroupBtn" class="new-group-btn">åˆ›å»ºæ–°ç¾¤èŠ</button>
            </div>

            <!-- æ–°å»ºç¾¤èŠè¡¨å• -->
            <div class="new-group-form" id="newGroupForm" style="display: none;">
                <input type="text" id="groupNameInput" placeholder="è¾“å…¥ç¾¤èŠåç§°">
                <div class="form-buttons">
                    <button class="cancel-btn" id="cancelNewGroupBtn">å–æ¶ˆ</button>
                    <button id="confirmNewGroupBtn">ç¡®è®¤</button>
                </div>
            </div>

            <!-- ç¾¤èŠåˆ—è¡¨ -->
            <div class="group-list" id="groupList">
                <!-- ç¾¤èŠé¡¹ä¼šåŠ¨æ€æ·»åŠ  -->
            </div>
        </div>
    </div>

    <div class="chat-container">
        <!-- æ·»åŠ è¿”å›è®¾ç½®æŒ‰é’® -->
        <button class="back-to-settings" id="backToSettings">è¿”å›è¿æ¥è®¾ç½®</button>

        <!-- èŠå¤©å¤´éƒ¨ -->
        <div class="chat-header">
            <div class="chat-title" id="currentChatTitle">æœªé€‰æ‹©èŠå¤©</div>
            <div class="chat-actions" id="chatHeaderActions" style="display: none;">
                <button id="manageMembersBtn" class="manage-members-btn">ç®¡ç†æˆå‘˜</button>
            </div>
        </div>

        <!-- ç¾¤èŠæˆå‘˜ç®¡ç†å¼¹çª— -->
        <div id="memberManagementModal" class="modal" style="display: none;">
            <div class="modal-content">
                <span class="close-modal">&times;</span>
                <h3>ç®¡ç†ç¾¤èŠæˆå‘˜</h3>
                <div class="member-list" id="groupMemberList">
                    <!-- æˆå‘˜åˆ—è¡¨ä¼šåŠ¨æ€æ·»åŠ  -->
                </div>
                <div class="add-member-section">
                    <h4>æ·»åŠ æˆå‘˜</h4>
                    <div class="add-member-form">
                        <label for="contactsDropdown"></label><select id="contactsDropdown">
                            <option value="">é€‰æ‹©è”ç³»äºº...</option>
                        </select>
                        <button id="addMemberBtn">æ·»åŠ </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="chat-box" id="chatBox"></div>

        <div class="input-area">
            <!-- æ·»åŠ åª’ä½“æŒ‰é’®è¡Œ -->
            <div class="media-controls">
                <div class="left-buttons">
                    <button class="upload-btn" onclick="document.getElementById('fileInput').click()" id="uploadButton" disabled>
                        æ–‡ä»¶
                    </button>
                    <button class="voice-record-button" id="voiceButton" disabled>
                        <span id="voiceButtonText">å½•éŸ³</span>
                        <span id="voiceTimer" class="audio-timer" style="display: none">00:00</span>
                    </button>
                    <button class="video-call-btn" id="videoCallButton" disabled onclick="VideoCallManager.initiateCall()">
                        è§†é¢‘
                    </button>
                    <button class="audio-call-btn" id="audioCallButton" disabled onclick="VideoCallManager.initiateAudioCall()">
                        è¯­éŸ³é€šè¯
                    </button>
                </div>
                <div class="right-buttons">
                    <button class="clear-chat-btn" id="clearChatButton" onclick="MessageManager.clearChat()">
                        æ¸…ç©ºä¼šè¯
                    </button>
                </div>
            </div>

            <!-- æ–‡æœ¬è¾“å…¥è¡Œ -->
            <div class="input-controls">
                <label for="messageInput"></label><textarea id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯... (Ctrl+Enter å‘é€)" disabled></textarea>
                <button id="sendButton" disabled onclick="MessageManager.sendMessage()">å‘é€</button>
            </div>

            <input type="file" id="fileInput" style="display: none"
                   onchange="MediaManager.handleFileSelect(event)">
            <div id="filePreviewContainer"></div>
            <div id="audioPreviewContainer"></div>
        </div>
    </div>
</div>
<!-- è§†é¢‘é€šè¯è¯·æ±‚å¼¹çª— -->
<div id="videoCallRequest" class="video-call-request" style="display: none;">
    <div class="video-call-avatar">ğŸ‘¤</div>
    <h3>è§†é¢‘é€šè¯è¯·æ±‚</h3>
    <p>å¯¹æ–¹è¯·æ±‚ä¸æ‚¨è¿›è¡Œè§†é¢‘é€šè¯</p>
    <div class="video-call-request-buttons">
        <button class="reject-call" onclick="VideoCallManager.rejectCall()">æ‹’ç»</button>
        <button class="accept-call" onclick="VideoCallManager.acceptCall()">æ¥å—</button>
    </div>
</div>

<!-- è§†é¢‘é€šè¯ç•Œé¢ -->
<div id="videoCallContainer" class="video-call-container" style="display: none;">
    <div class="video-streams">
        <video id="remoteVideo" autoplay playsinline></video>
        <video id="localVideo" autoplay playsinline muted></video>
    </div>
    <div class="video-call-controls">
        <button class="video-call-button toggle-camera" id="toggleCameraBtn" onclick="VideoCallManager.toggleCamera()">
            ğŸ“¹
        </button>
        <button class="video-call-button mute-audio" id="toggleAudioBtn" onclick="VideoCallManager.toggleAudio()">
            ğŸ¤
        </button>
        <button class="video-call-button end-call" onclick="VideoCallManager.endCall()">
            ğŸ“
        </button>
        <button class="video-call-button audio-only" id="audioOnlyBtn" onclick="VideoCallManager.toggleAudioOnly()">
            ğŸ”Š
        </button>
    </div>
</div>
</body>

<script>
    // é…ç½®å¯¹è±¡
    const Config = {
        // ICEæœåŠ¡å™¨é…ç½®
        iceServers: [
            {
                "urls": [
                    "turn:stun.evan-brass.net",
                    "turn:stun.evan-brass.net?transport=tcp",
                    "stun:stun.evan-brass.net"
                ],
                "username": "guest",
                "credential": "password"
            }
        ],

        // WebRTCé…ç½®
        peerConnectionConfig: {
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            iceCandidatePoolSize: 10,
            sdpSemantics: 'unified-plan'
        },

        // é‡è¿é…ç½®
        reconnect: {
            maxAttempts: 5,
            delay: 2000,
            backoffFactor: 1.5
        },

        // è¶…æ—¶é…ç½®
        timeouts: {
            iceGathering: 5000,  // æ›´ä½çš„è¶…æ—¶ï¼Œå¿«é€Ÿå¤±è´¥
            connection: 8000,
            networkCheck: 5000
        },

        // åª’ä½“é…ç½®
        media: {
            maxAudioDuration: 60,  // 60ç§’
            imageCompression: 0.7  // é»˜è®¤å‹ç¼©ç‡
        }
    };

    // å·¥å…·ç±»
    const Utils = {
        // æ—¥å¿—çº§åˆ«
        logLevels: {
            DEBUG: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3
        },

        // å½“å‰æ—¥å¿—çº§åˆ«
        currentLogLevel: 0,

        // è®°å½•æ—¥å¿—
        log: function (message, level = this.logLevels.DEBUG) {
            if (level >= this.currentLogLevel) {
                const debugInfo = document.getElementById('debugInfo');
                const timestamp = new Date().toLocaleTimeString();

                let prefix = '';
                switch (level) {
                    case this.logLevels.INFO:
                        prefix = '[ä¿¡æ¯] ';
                        break;
                    case this.logLevels.WARN:
                        prefix = '[è­¦å‘Š] ';
                        break;
                    case this.logLevels.ERROR:
                        prefix = '[é”™è¯¯] ';
                        break;
                    default:
                        prefix = '[è°ƒè¯•] ';
                }

                debugInfo.innerHTML = `[${timestamp}] ${prefix}${message}<br>` + debugInfo.innerHTML;

                // é™åˆ¶æ—¥å¿—æ¡æ•°
                const lines = debugInfo.innerHTML.split('<br>');
                if (lines.length > 10) {
                    debugInfo.innerHTML = lines.slice(0, 10).join('<br>');
                }

                // åœ¨æ§åˆ¶å°ä¹Ÿè®°å½•æ—¥å¿—
                if (level === this.logLevels.ERROR) {
                    console.error(message);
                } else if (level === this.logLevels.WARN) {
                    console.warn(message);
                } else {
                    console.log(message);
                }
            }
        },

        // æ ¼å¼åŒ–æ—¶é—´
        formatTime: function (seconds) {
            const minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${minutes}:${secs}`;
        },

        // ç½‘ç»œç±»å‹æ£€æµ‹
        checkNetworkType: async function () {
            try {
                const pc = new RTCPeerConnection();
                const candidates = [];

                pc.onicecandidate = (e) => {
                    if (e.candidate) {
                        candidates.push(e.candidate);
                    }
                };

                await pc.createDataChannel("");
                await pc.createOffer().then(offer => pc.setLocalDescription(offer));
                await new Promise(r => setTimeout(r, 1000));

                pc.close();

                const hasIPv4 = candidates.some(c => c.address && c.address.indexOf('.') !== -1);
                const hasIPv6 = candidates.some(c => c.address && c.address.indexOf(':') !== -1);
                const hasRelay = candidates.some(c => c.type === 'relay');
                const hasUdp = candidates.some(c => c.protocol === 'udp');
                const hasTcp = candidates.some(c => c.protocol === 'tcp');

                return {
                    ipv4: hasIPv4,
                    ipv6: hasIPv6,
                    relay: hasRelay,
                    udp: hasUdp,
                    tcp: hasTcp,
                    count: candidates.length
                };
            } catch (error) {
                Utils.log(`ç½‘ç»œæ£€æµ‹å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                return null;
            }
        },

        // åˆ†å—å‘é€å¤§æ–‡ä»¶
        sendInChunks: function (data, sendFunc, chunkSize = 128 * 1024) {
            // å¦‚æœæ•°æ®å°äºé˜ˆå€¼ï¼Œç›´æ¥å‘é€
            if (data.length < chunkSize) {
                return sendFunc(data);
            }

            // å¦åˆ™åˆ†å—å‘é€
            const chunks = [];
            const totalChunks = Math.ceil(data.length / chunkSize);
            const fileId = new Date().getTime();

            for (let i = 0; i < totalChunks; i++) {
                const start = i * chunkSize;
                const end = Math.min(data.length, start + chunkSize);
                chunks.push(data.substring(start, end));
            }

            Utils.log(`æ–‡ä»¶è¿‡å¤§ï¼Œåˆ†ä¸º${totalChunks}å—å‘é€`, Utils.logLevels.INFO);

            // å‘é€å…ƒæ•°æ®
            sendFunc(JSON.stringify({
                type: 'file-meta',
                id: fileId,
                totalChunks: totalChunks
            }));

            // é€å—å‘é€
            chunks.forEach((chunk, index) => {
                setTimeout(() => {
                    sendFunc(JSON.stringify({
                        type: 'file-chunk',
                        id: fileId,
                        chunk: chunk,
                        index: index
                    }));
                }, index * 100); // æ·»åŠ å°å»¶è¿Ÿé¿å…å‘é€è¿‡å¿«
            });
        },

        // ç”ŸæˆéšæœºID
        generateId: function() {
            return Math.random().toString(36).substring(2, 10);
        },

        // æ ¼å¼åŒ–æ—¥æœŸ
        formatDate: function(date) {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            if (date.getTime() > today.getTime()) {
                return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            } else if (date.getTime() > yesterday.getTime()) {
                return 'æ˜¨å¤©';
            } else {
                return `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
            }
        }
    };

    // äº‹ä»¶ç®¡ç†å™¨
    const EventEmitter = {
        events: {},

        // æ³¨å†Œäº‹ä»¶
        on: function (event, callback) {
            if (!this.events[event]) {
                this.events[event] = [];
            }
            this.events[event].push(callback);
        },

        // è§¦å‘äº‹ä»¶
        emit: function (event, ...args) {
            if (this.events[event]) {
                this.events[event].forEach(callback => {
                    try {
                        callback(...args);
                    } catch (e) {
                        Utils.log(`äº‹ä»¶å¤„ç†å‘ç”Ÿé”™è¯¯: ${e.message}`, Utils.logLevels.ERROR);
                    }
                });
            }
        },

        // ç§»é™¤äº‹ä»¶
        off: function (event, callback) {
            if (this.events[event]) {
                if (callback) {
                    this.events[event] = this.events[event].filter(cb => cb !== callback);
                } else {
                    delete this.events[event];
                }
            }
        }
    };

    // æ•°æ®åº“ç®¡ç†å™¨
    const DBManager = {
        db: null,
        dbName: 'p2pChatDB',
        dbVersion: 1,

        // åˆå§‹åŒ–æ•°æ®åº“
        init: function() {
            return new Promise((resolve, reject) => {
                if (this.db) {
                    resolve(this.db);
                    return;
                }

                const request = indexedDB.open(this.dbName, this.dbVersion);

                request.onerror = (event) => {
                    Utils.log('æ•°æ®åº“æ‰“å¼€å¤±è´¥', Utils.logLevels.ERROR);
                    reject('æ•°æ®åº“æ‰“å¼€å¤±è´¥');
                };

                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    Utils.log('æ•°æ®åº“æ‰“å¼€æˆåŠŸ', Utils.logLevels.INFO);
                    resolve(this.db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // åˆ›å»ºç”¨æˆ·å­˜å‚¨
                    if (!db.objectStoreNames.contains('user')) {
                        db.createObjectStore('user', { keyPath: 'id' });
                    }

                    // åˆ›å»ºè”ç³»äººå­˜å‚¨
                    if (!db.objectStoreNames.contains('contacts')) {
                        db.createObjectStore('contacts', { keyPath: 'id' });
                    }

                    // åˆ›å»ºèŠå¤©è®°å½•å­˜å‚¨
                    if (!db.objectStoreNames.contains('chats')) {
                        db.createObjectStore('chats', { keyPath: 'id' });
                    }

                    // åˆ›å»ºç¾¤ç»„å­˜å‚¨
                    if (!db.objectStoreNames.contains('groups')) {
                        db.createObjectStore('groups', { keyPath: 'id' });
                    }
                };
            });
        },

        // å­˜å‚¨æ•°æ®
        setItem: function(storeName, item) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject('æ•°æ®åº“æœªåˆå§‹åŒ–');
                    return;
                }

                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(item);

                request.onsuccess = () => resolve();
                request.onerror = () => reject('å­˜å‚¨æ•°æ®å¤±è´¥');
            });
        },

        // è·å–æ•°æ®
        getItem: function(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject('æ•°æ®åº“æœªåˆå§‹åŒ–');
                    return;
                }

                const transaction = this.db.transaction([storeName]);
                const store = transaction.objectStore(storeName);
                const request = store.get(key);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject('è·å–æ•°æ®å¤±è´¥');
            });
        },

        // è·å–å­˜å‚¨ä¸­çš„æ‰€æœ‰æ•°æ®
        getAllItems: function(storeName) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject('æ•°æ®åº“æœªåˆå§‹åŒ–');
                    return;
                }

                const transaction = this.db.transaction([storeName]);
                const store = transaction.objectStore(storeName);
                const request = store.getAll();

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject('è·å–æ•°æ®å¤±è´¥');
            });
        },

        // åˆ é™¤æ•°æ®
        removeItem: function(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject('æ•°æ®åº“æœªåˆå§‹åŒ–');
                    return;
                }

                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);

                request.onsuccess = () => resolve();
                request.onerror = () => reject('åˆ é™¤æ•°æ®å¤±è´¥');
            });
        },

        // æ¸…ç©ºå­˜å‚¨
        clearStore: function(storeName) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject('æ•°æ®åº“æœªåˆå§‹åŒ–');
                    return;
                }

                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();

                request.onsuccess = () => resolve();
                request.onerror = () => reject('æ¸…ç©ºæ•°æ®å¤±è´¥');
            });
        }
    };

    // è¿æ¥ç®¡ç†å™¨
    const ConnectionManager = {
        connections: {},  // å­˜å‚¨å¤šä¸ªè¿æ¥
        iceCandidates: {},
        connectionTimeouts: {},
        reconnectAttempts: {},
        iceTimers: {},
        iceGatheringStartTimes: {},
        connectionStrengths: {},
        pendingChunks: {},

        // åˆå§‹åŒ–è¿æ¥
        init: function (peerId) {
            if (this.connections[peerId]) {
                this.close(peerId);
            }

            try {
                // åˆ›å»ºæ–°çš„é…ç½®ï¼ŒåŸºäºå½“å‰ç½‘ç»œçŠ¶å†µ
                let currentConfig = {...Config.peerConnectionConfig};
                currentConfig.iceServers = Config.iceServers;

                this.connections[peerId] = {
                    peerConnection: new RTCPeerConnection(currentConfig),
                    dataChannel: null
                };

                const pc = this.connections[peerId].peerConnection;

                pc.onicecandidate = (e) => this.handleIceCandidate(e, peerId);
                pc.onicegatheringstatechange = (e) => this.handleIceGatheringStateChange(e, peerId);
                pc.oniceconnectionstatechange = (e) => this.handleIceConnectionStateChange(e, peerId);
                pc.ondatachannel = (e) => this.handleDataChannel(e, peerId);

                this.iceCandidates[peerId] = [];
                this.reconnectAttempts[peerId] = 0;

                Utils.log(`ä¸${peerId}çš„WebRTCè¿æ¥å·²åˆå§‹åŒ–`, Utils.logLevels.INFO);
                return true;
            } catch (error) {
                Utils.log(`åˆå§‹åŒ–è¿æ¥å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                return false;
            }
        },

        // å¤„ç†ICEå€™é€‰è€…
        handleIceCandidate: function (event, peerId) {
            if (event.candidate) {
                if (!this.iceCandidates[peerId]) {
                    this.iceCandidates[peerId] = [];
                }
                this.iceCandidates[peerId].push(event.candidate);
                this.updateSdpText();
                Utils.log(`æ”¶é›†åˆ°ICEå€™é€‰: ${event.candidate.type} ${event.candidate.protocol}`, Utils.logLevels.DEBUG);

                // å¦‚æœè¿æ¥å·²å»ºç«‹ï¼Œå°è¯•å‘é€å€™é€‰è€…ç»™å¯¹æ–¹ï¼ˆå¯ç”¨Trickle ICEï¼‰
                const conn = this.connections[peerId];
                if (conn && conn.dataChannel && conn.dataChannel.readyState === 'open') {
                    this.sendIceCandidate(event.candidate, peerId);
                }
            }
        },

        // å¤„ç†ICEæ”¶é›†çŠ¶æ€å˜åŒ–
        handleIceGatheringStateChange: function (event, peerId) {
            const pc = this.connections[peerId]?.peerConnection;
            if (!pc) return;

            const state = pc.iceGatheringState;

            switch (state) {
                case 'gathering':
                    UIManager.updateStatus('æ­£åœ¨æ”¶é›†ç½‘ç»œä¿¡æ¯...');
                    this.startIceTimer(peerId);
                    this.iceGatheringStartTimes[peerId] = Date.now();
                    break;

                case 'complete':
                    this.stopIceTimer(peerId);
                    const duration = (Date.now() - this.iceGatheringStartTimes[peerId]) / 1000;
                    UIManager.updateStatus(`ç½‘ç»œä¿¡æ¯æ”¶é›†å®Œæˆ (${duration.toFixed(1)}ç§’)`);
                    this.updateSdpText();
                    break;
            }
        },

        // å¤„ç†ICEè¿æ¥çŠ¶æ€å˜åŒ–
        handleIceConnectionStateChange: function (event, peerId) {
            const pc = this.connections[peerId]?.peerConnection;
            if (!pc) return;

            const state = pc.iceConnectionState;
            UIManager.updateStatus(`ICEçŠ¶æ€: ${state}`);

            switch (state) {
                case 'checking':
                    this.startConnectionTimeout(peerId);
                    EventEmitter.emit('connectionChecking', peerId);
                    break;

                case 'connected':
                    this.clearConnectionTimeout(peerId);
                    this.enableTrickleIce(peerId);
                    this.connectionStrengths[peerId] = this.calculateConnectionStrength(peerId);
                    UIManager.updateConnectionState(true);
                    EventEmitter.emit('connectionEstablished', peerId);

                    // æ›´æ–°è§†é¢‘é€šè¯æŒ‰é’®çŠ¶æ€
                    if (ChatManager.currentChatId === peerId) {
                        document.getElementById('videoCallButton').disabled = false;
                        document.getElementById('videoCallButton').onclick = () => VideoCallManager.initiateCall(peerId);
                    }
                    break;

                case 'disconnected':
                    this.handleDisconnection(peerId);
                    EventEmitter.emit('connectionDisconnected', peerId);
                    break;

                case 'failed':
                    this.handleConnectionFailure(peerId);
                    EventEmitter.emit('connectionFailed', peerId);
                    break;

                case 'closed':
                    UIManager.updateConnectionState(false);
                    EventEmitter.emit('connectionClosed', peerId);
                    break;
            }
        },

        // å¤„ç†æ•°æ®é€šé“
        handleDataChannel: function (event, peerId) {
            this.setupDataChannel(event.channel, peerId);
        },

        // å¯åŠ¨ICEæ”¶é›†è®¡æ—¶å™¨
        startIceTimer: function (peerId) {
            this.stopIceTimer(peerId);
            this.iceTimers[peerId] = setTimeout(() => {
                const pc = this.connections[peerId]?.peerConnection;
                if (pc && pc.iceGatheringState !== 'complete') {
                    Utils.log('ICEæ”¶é›†è¶…æ—¶ï¼Œä½¿ç”¨å½“å‰å¯ç”¨è¿æ¥', Utils.logLevels.WARN);
                    UIManager.updateStatus('ç½‘ç»œä¿¡æ¯æ”¶é›†è¶…æ—¶ï¼Œä½¿ç”¨å½“å‰å¯ç”¨è¿æ¥');
                    this.updateSdpText();
                }
            }, Config.timeouts.iceGathering);
        },

        // åœæ­¢ICEæ”¶é›†è®¡æ—¶å™¨
        stopIceTimer: function (peerId) {
            if (this.iceTimers[peerId]) {
                clearTimeout(this.iceTimers[peerId]);
                this.iceTimers[peerId] = null;
            }
        },

        // å¯åŠ¨è¿æ¥è¶…æ—¶
        startConnectionTimeout: function (peerId) {
            this.clearConnectionTimeout(peerId);
            this.connectionTimeouts[peerId] = setTimeout(() => {
                const pc = this.connections[peerId]?.peerConnection;
                if (pc && pc.iceConnectionState === 'checking') {
                    Utils.log('è¿æ¥å»ºç«‹è¶…æ—¶', Utils.logLevels.WARN);
                    this.handleConnectionFailure(peerId);
                }
            }, Config.timeouts.connection);
        },

        // æ¸…é™¤è¿æ¥è¶…æ—¶
        clearConnectionTimeout: function (peerId) {
            if (this.connectionTimeouts[peerId]) {
                clearTimeout(this.connectionTimeouts[peerId]);
                this.connectionTimeouts[peerId] = null;
            }
        },

        // å¤„ç†è¿æ¥å¤±è´¥
        handleConnectionFailure: function (peerId) {
            UIManager.updateStatus('è¿æ¥å¤±è´¥');
            UIManager.updateConnectionState(false);

            if (!this.reconnectAttempts[peerId]) {
                this.reconnectAttempts[peerId] = 0;
            }

            if (this.reconnectAttempts[peerId] < Config.reconnect.maxAttempts) {
                const delay = Config.reconnect.delay * Math.pow(Config.reconnect.backoffFactor, this.reconnectAttempts[peerId]);
                this.reconnectAttempts[peerId]++;

                UIManager.updateStatus(`æ­£åœ¨å°è¯•é‡æ–°è¿æ¥ (${this.reconnectAttempts[peerId]}/${Config.reconnect.maxAttempts})...`, delay);

                setTimeout(() => {
                    this.restartIceWithRelay(peerId);
                }, delay);
            } else {
                UIManager.updateStatus('è¿æ¥å¤±è´¥ï¼Œè¯·é‡æ–°å¼€å§‹è¿æ¥æµç¨‹');
                this.resetConnection(peerId);
            }
        },

        // å¤„ç†è¿æ¥æ–­å¼€
        handleDisconnection: function (peerId) {
            UIManager.updateStatus('è¿æ¥æ–­å¼€ï¼Œå°è¯•é‡è¿...');
            UIManager.updateConnectionState(false, 'disconnected');

            // ä½¿ç”¨æŒ‡æ•°é€€é¿é‡è¿
            const delay = 1000;
            setTimeout(() => {
                const pc = this.connections[peerId]?.peerConnection;
                if (pc && pc.iceConnectionState === 'disconnected') {
                    this.restartIce(peerId);
                }
            }, delay);
        },

        // ä½¿ç”¨ä¸­ç»§æœåŠ¡å™¨é‡å¯ICE
        restartIceWithRelay: async function (peerId) {
            try {
                const conn = this.connections[peerId];
                if (!conn || !conn.peerConnection) {
                    throw new Error('æ²¡æœ‰æ´»åŠ¨çš„è¿æ¥');
                }

                // è°ƒæ•´é…ç½®ï¼Œå¼ºåˆ¶ä½¿ç”¨ä¸­ç»§
                const relayConfig = {
                    ...Config.peerConnectionConfig,
                    iceTransportPolicy: 'relay'
                };
                relayConfig.iceServers = Config.iceServers;

                conn.peerConnection.setConfiguration(relayConfig);

                Utils.log('æ­£åœ¨ä½¿ç”¨ä¸­ç»§æœåŠ¡å™¨é‡æ–°åå•†è¿æ¥', Utils.logLevels.INFO);

                if (conn.peerConnection.signalingState === 'stable') {
                    const offer = await conn.peerConnection.createOffer({iceRestart: true});
                    await conn.peerConnection.setLocalDescription(offer);
                    UIManager.updateStatus('æ­£åœ¨å°è¯•ä½¿ç”¨ä¸­ç»§æœåŠ¡å™¨é‡è¿...');
                    this.updateSdpText();
                }
            } catch (error) {
                Utils.log(`é‡è¿å°è¯•å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                // ç»§ç»­å°è¯•ä¸‹ä¸€æ¬¡é‡è¿æˆ–æœ€ç»ˆæ”¾å¼ƒ
                this.handleConnectionFailure(peerId);
            }
        },

        // æ ‡å‡†ICEé‡å¯
        restartIce: async function (peerId) {
            try {
                const conn = this.connections[peerId];
                if (!conn || !conn.peerConnection || conn.peerConnection.signalingState !== 'stable') {
                    return;
                }

                Utils.log('æ­£åœ¨å°è¯•ICEé‡å¯', Utils.logLevels.INFO);

                const offer = await conn.peerConnection.createOffer({iceRestart: true});
                await conn.peerConnection.setLocalDescription(offer);

                this.updateSdpText();
                UIManager.updateStatus('æ­£åœ¨åå•†é‡æ–°è¿æ¥...');
            } catch (error) {
                Utils.log(`ICEé‡å¯å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
            }
        },

        // å¯ç”¨Trickle ICEï¼ˆå®æ—¶å‘é€ICEå€™é€‰è€…ï¼‰
        enableTrickleIce: function (peerId) {
            Utils.log('å¯ç”¨Trickle ICE', Utils.logLevels.DEBUG);
            // å·²åœ¨handleIceCandidateå¤„ç†
        },

        // å‘é€ICEå€™é€‰è€…
        sendIceCandidate: function (candidate, peerId) {
            const conn = this.connections[peerId];
            if (conn && conn.dataChannel && conn.dataChannel.readyState === 'open') {
                try {
                    const message = {
                        type: 'ice-candidate',
                        candidate: candidate,
                        sender: UserManager.userId
                    };
                    conn.dataChannel.send(JSON.stringify(message));
                    Utils.log('å·²å‘é€ICEå€™é€‰', Utils.logLevels.DEBUG);
                } catch (error) {
                    Utils.log(`å‘é€ICEå€™é€‰å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                }
            }
        },

        // è®¾ç½®æ•°æ®é€šé“
        setupDataChannel: function (channel, peerId) {
            if (!this.connections[peerId]) {
                this.connections[peerId] = { peerConnection: null, dataChannel: null };
            }

            this.connections[peerId].dataChannel = channel;
            const conn = this.connections[peerId];

            conn.dataChannel.onopen = () => {
                Utils.log(`ä¸${peerId}çš„æ•°æ®é€šé“å·²æ‰“å¼€`, Utils.logLevels.INFO);
                UIManager.updateStatus("è¿æ¥å·²å»ºç«‹ï¼Œå¯ä»¥å¼€å§‹èŠå¤©");
                UIManager.enableChatInterface(true);
                EventEmitter.emit('dataChannelOpen', peerId);

                // é¦–æ¬¡è¿æ¥æˆåŠŸåè‡ªåŠ¨äº¤æ¢æ›´å¤šICEå€™é€‰
                this.enableTrickleIce(peerId);

                // å¼€å§‹è¿æ¥è´¨é‡ç›‘æ§
                this.startConnectionMonitoring(peerId);

                // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥è”ç³»äººçš„èŠå¤©ï¼Œå¯ç”¨è§†é¢‘é€šè¯æŒ‰é’®
                if (ChatManager.currentChatId === peerId) {
                    document.getElementById('videoCallButton').disabled = false;
                    document.getElementById('videoCallButton').onclick = () => VideoCallManager.initiateCall(peerId);
                }
            };

            conn.dataChannel.onclose = () => {
                Utils.log(`ä¸${peerId}çš„æ•°æ®é€šé“å·²å…³é—­`, Utils.logLevels.INFO);
                UIManager.updateStatus("è¿æ¥å·²å…³é—­");

                // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥è”ç³»äººçš„èŠå¤©ï¼Œç¦ç”¨è§†é¢‘é€šè¯æŒ‰é’®
                if (ChatManager.currentChatId === peerId) {
                    document.getElementById('videoCallButton').disabled = true;
                }

                EventEmitter.emit('dataChannelClosed', peerId);
            };

            conn.dataChannel.onmessage = (event) => {
                try {
                    // å°è¯•è§£æJSONæ¶ˆæ¯
                    const message = JSON.parse(event.data);

                    // æ·»åŠ å‘é€è€…ä¿¡æ¯
                    if (!message.sender) {
                        message.sender = peerId;
                    }

                    // æ·»åŠ æ—¶é—´æˆ³
                    if (!message.timestamp) {
                        message.timestamp = new Date().toISOString();
                    }

                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤ç»„ç›¸å…³æ¶ˆæ¯
                    if (message.groupId ||
                        message.type === 'group-invite' ||
                        message.type === 'group-removed' ||
                        message.type === 'group-member-added' ||
                        message.type === 'group-member-removed') {

                        // äº¤ç»™ç¾¤èŠç®¡ç†å™¨å¤„ç†
                        if (GroupManager.handleGroupMessage(message)) {
                            return; // å·²å¤„ç†ç¾¤èŠæ¶ˆæ¯
                        }
                    }

                    // æ£€æŸ¥æ˜¯å¦æ˜¯è§†é¢‘é€šè¯ç›¸å…³æ¶ˆæ¯
                    if (message.type && message.type.startsWith('video-call-')) {
                        VideoCallManager.handleMessage(message, peerId);
                        return;
                    }

                    switch (message.type) {
                        case 'ice-candidate':
                            this.handleIncomingIceCandidate(message.candidate, peerId);
                            break;

                        case 'file-meta':
                            // åˆå§‹åŒ–æ–‡ä»¶å—æ”¶é›†
                            if (!this.pendingChunks[peerId]) {
                                this.pendingChunks[peerId] = {};
                            }
                            this.pendingChunks[peerId][message.id] = {
                                chunks: new Array(message.totalChunks),
                                received: 0,
                                total: message.totalChunks
                            };
                            break;

                        case 'file-chunk':
                            // æ”¶é›†æ–‡ä»¶å—
                            if (this.pendingChunks[peerId] && this.pendingChunks[peerId][message.id]) {
                                this.pendingChunks[peerId][message.id].chunks[message.index] = message.chunk;
                                this.pendingChunks[peerId][message.id].received++;

                                // æ£€æŸ¥æ˜¯å¦å·²æ”¶åˆ°æ‰€æœ‰å—
                                if (this.pendingChunks[peerId][message.id].received === this.pendingChunks[peerId][message.id].total) {
                                    const completeData = this.pendingChunks[peerId][message.id].chunks.join('');
                                    delete this.pendingChunks[peerId][message.id];

                                    // è§£æå¹¶æ˜¾ç¤ºå®Œæ•´æ¶ˆæ¯
                                    const fullMessage = JSON.parse(completeData);
                                    fullMessage.sender = peerId;

                                    // æ·»åŠ åˆ°èŠå¤©è®°å½•å¹¶æ˜¾ç¤º
                                    ChatManager.addMessage(peerId, fullMessage);

                                    // æ›´æ–°è”ç³»äººæœ€åæ¶ˆæ¯
                                    let previewText = '[æ–‡ä»¶]';
                                    if (fullMessage.type === 'file' || fullMessage.type === 'image') {
                                        if (fullMessage.fileType) {
                                            if (fullMessage.fileType.startsWith('image/')) previewText = '[å›¾ç‰‡]';
                                            else if (fullMessage.fileType.startsWith('video/')) previewText = '[è§†é¢‘]';
                                            else if (fullMessage.fileType.startsWith('audio/')) previewText = '[éŸ³é¢‘]';
                                        }
                                    }
                                    else if (fullMessage.type === 'audio') previewText = '[è¯­éŸ³]';

                                    UserManager.updateContactLastMessage(
                                        peerId,
                                        previewText,
                                        ChatManager.currentChatId !== peerId
                                    );
                                }
                            }
                            break;

                        default:
                            // æ™®é€šæ¶ˆæ¯æ·»åŠ åˆ°èŠå¤©è®°å½•
                            ChatManager.addMessage(peerId, message);

                            // æ›´æ–°è”ç³»äººæœ€åæ¶ˆæ¯
                            let previewText = '';
                            if (message.type === 'text') {
                                previewText = message.content;
                            } else if (message.type === 'file' || message.type === 'image') {
                                if (message.fileType) {
                                    if (message.fileType.startsWith('image/')) previewText = '[å›¾ç‰‡]';
                                    else if (message.fileType.startsWith('video/')) previewText = '[è§†é¢‘]';
                                    else if (message.fileType.startsWith('audio/')) previewText = '[éŸ³é¢‘]';
                                    else previewText = '[æ–‡ä»¶]';
                                } else {
                                    previewText = '[æ–‡ä»¶]';
                                }
                            } else if (message.type === 'audio') {
                                previewText = '[è¯­éŸ³]';
                            } else {
                                previewText = '[æ¶ˆæ¯]';
                            }

                            UserManager.updateContactLastMessage(
                                peerId,
                                previewText,
                                ChatManager.currentChatId !== peerId
                            );
                    }
                } catch (e) {
                    // å¦‚æœä¸æ˜¯JSONï¼Œä½œä¸ºæ™®é€šæ–‡æœ¬æ˜¾ç¤º
                    const textMessage = {
                        type: 'text',
                        content: event.data,
                        sender: peerId,
                        timestamp: new Date().toISOString()
                    };
                    ChatManager.addMessage(peerId, textMessage);
                    UserManager.updateContactLastMessage(
                        peerId,
                        event.data,
                        ChatManager.currentChatId !== peerId
                    );
                }
            };

            conn.dataChannel.onerror = (error) => {
                Utils.log(`æ•°æ®é€šé“é”™è¯¯: ${error.message || 'æœªçŸ¥é”™è¯¯'}`, Utils.logLevels.ERROR);
                EventEmitter.emit('dataChannelError', error, peerId);
            };
        },

        // å¤„ç†æ¥æ”¶åˆ°çš„ICEå€™é€‰è€…
        handleIncomingIceCandidate: async function (candidate, peerId) {
            try {
                const conn = this.connections[peerId];
                if (conn && conn.peerConnection) {
                    await conn.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    Utils.log('å·²æ·»åŠ è¿œç¨‹ICEå€™é€‰', Utils.logLevels.DEBUG);
                }
            } catch (error) {
                Utils.log(`æ·»åŠ è¿œç¨‹ICEå€™é€‰å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
            }
        },

        // å¼€å§‹è¿æ¥è´¨é‡ç›‘æµ‹
        startConnectionMonitoring: function (peerId) {
            setInterval(async () => {
                const conn = this.connections[peerId];
                if (conn && conn.peerConnection && conn.dataChannel && conn.dataChannel.readyState === 'open') {
                    try {
                        const stats = await conn.peerConnection.getStats();
                        let currentRoundTripTime = null;
                        let bytesReceived = 0;
                        let bytesSent = 0;
                        let localCandidateType = null;
                        let remoteCandidateType = null;

                        stats.forEach(report => {
                            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                                currentRoundTripTime = report.currentRoundTripTime;
                                // ä¿å­˜UDPæˆ–TCPè¿æ¥ç±»å‹
                                if (report.localCandidateId && report.remoteCandidateId) {
                                    stats.forEach(s => {
                                        if (s.id === report.localCandidateId) {
                                            localCandidateType = `${s.candidateType}/${s.protocol}`;
                                        }
                                        if (s.id === report.remoteCandidateId) {
                                            remoteCandidateType = `${s.candidateType}/${s.protocol}`;
                                        }
                                    });
                                }
                            }

                            if (report.type === 'data-channel') {
                                bytesReceived += report.bytesReceived || 0;
                                bytesSent += report.bytesSent || 0;
                            }
                        });

                        // åªåœ¨æœ‰æ•ˆRTTæ—¶æ›´æ–°è¿æ¥è´¨é‡
                        if (currentRoundTripTime !== null) {
                            UIManager.updateConnectionQuality(currentRoundTripTime);
                            this.connectionStrengths[peerId] = this.calculateConnectionStrength(peerId, currentRoundTripTime);

                            Utils.log(`è¿æ¥ç›‘æµ‹: RTT=${currentRoundTripTime.toFixed(3)}s, æœ¬åœ°=${localCandidateType}, è¿œç¨‹=${remoteCandidateType}, ä¼ è¾“=${bytesReceived + bytesSent}å­—èŠ‚`,
                                Utils.logLevels.DEBUG);

                            // å¦‚æœè¿æ¥è´¨é‡å¾ˆå·®ï¼Œå°è¯•é‡æ–°åå•†
                            if (currentRoundTripTime > 1.5 && this.connectionStrengths[peerId] < 30) {
                                this.considerReconnection(peerId);
                            }
                        }
                    } catch (error) {
                        Utils.log(`è·å–è¿æ¥ç»Ÿè®¡å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                    }
                }
            }, Config.timeouts.networkCheck);
        },

        // è®¡ç®—è¿æ¥å¼ºåº¦ (0-100)
        calculateConnectionStrength: function (peerId, rtt = null) {
            const conn = this.connections[peerId];
            if (!conn || !conn.peerConnection) return 0;

            let strength = 0;

            // åŸºäºICEè¿æ¥çŠ¶æ€
            switch (conn.peerConnection.iceConnectionState) {
                case 'connected':
                    strength += 60;
                    break;
                case 'completed':
                    strength += 70;
                    break;
                case 'checking':
                    strength += 30;
                    break;
                case 'disconnected':
                    strength += 10;
                    break;
                default:
                    strength += 0;
            }

            // å¦‚æœRTTå¯ç”¨ï¼Œæ ¹æ®å»¶è¿Ÿè°ƒæ•´
            if (rtt !== null) {
                if (rtt < 0.1) strength += 30;
                else if (rtt < 0.3) strength += 20;
                else if (rtt < 0.7) strength += 10;
                else if (rtt > 1.0) strength -= 20;
            }

            // ç¡®ä¿åœ¨0-100èŒƒå›´å†…
            return Math.max(0, Math.min(100, strength));
        },

        // åœ¨è¿æ¥è´¨é‡å·®æ—¶è€ƒè™‘é‡è¿
        considerReconnection: function (peerId) {
            if (!this.reconnectAttempts[peerId]) {
                this.reconnectAttempts[peerId] = 0;
            }

            if (this.reconnectAttempts[peerId] < Config.reconnect.maxAttempts) {
                Utils.log('æ£€æµ‹åˆ°è¿æ¥è´¨é‡å·®ï¼Œå°è¯•é‡æ–°åå•†...', Utils.logLevels.WARN);
                this.restartIce(peerId);
            }
        },

        // æ›´æ–°SDPæ–‡æœ¬
        updateSdpText: function (peerId) {
            if (!peerId || !this.connections[peerId]) return;

            const conn = this.connections[peerId];
            if (!conn.peerConnection || !conn.peerConnection.localDescription) {
                return;
            }

            const connectionInfo = {
                sdp: conn.peerConnection.localDescription,
                candidates: this.iceCandidates[peerId] || [],
                userId: UserManager.userId
            };

            document.getElementById('sdpText').value = JSON.stringify(connectionInfo);
        },

        // é‡ç½®è¿æ¥
        resetConnection: function (peerId) {
            if (this.connections[peerId]) {
                this.close(peerId);
            }

            this.connections[peerId] = null;
            this.iceCandidates[peerId] = [];
            this.reconnectAttempts[peerId] = 0;

            if (this.currentPeerId === peerId) {
                UIManager.resetConnectionControls();
            }
        },

        // å…³é—­è¿æ¥
        close: function (peerId) {
            this.stopIceTimer(peerId);
            this.clearConnectionTimeout(peerId);

            const conn = this.connections[peerId];
            if (!conn) return;

            if (conn.dataChannel) {
                try {
                    conn.dataChannel.close();
                } catch (e) {
                    // å¿½ç•¥å…³é—­é”™è¯¯
                }
                conn.dataChannel = null;
            }

            if (conn.peerConnection) {
                try {
                    conn.peerConnection.close();
                } catch (e) {
                    // å¿½ç•¥å…³é—­é”™è¯¯
                }
                conn.peerConnection = null;
            }

            if (this.currentPeerId === peerId) {
                UIManager.updateStatus('è¿æ¥å·²å…³é—­');
                UIManager.enableChatInterface(false);
            }
        },

        // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥åˆ°ç‰¹å®šç”¨æˆ·
        isConnectedTo: function(peerId) {
            const conn = this.connections[peerId];
            return conn &&
                conn.dataChannel &&
                conn.dataChannel.readyState === 'open' &&
                conn.peerConnection &&
                (conn.peerConnection.iceConnectionState === 'connected' ||
                    conn.peerConnection.iceConnectionState === 'completed');
        },

        // åˆ›å»ºè¿æ¥è¯·æ±‚
        createOffer: async function () {
            if (!UIManager.checkWebRTCSupport()) return;

            // è·å–å¯¹æ–¹ID
            const peerIdInput = document.getElementById('sdpText').value.trim();
            let targetPeerId = '';

            if (peerIdInput) {
                try {
                    // å°è¯•ä»SDPæ–‡æœ¬ä¸­æå–ç”¨æˆ·ID
                    const sdpData = JSON.parse(peerIdInput);
                    if (sdpData.userId) {
                        targetPeerId = sdpData.userId;
                    }
                } catch (e) {
                    // è§£æå¤±è´¥ï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„JSON
                }
            }

            // å¦‚æœæ²¡æœ‰è·å–åˆ°IDï¼Œä½¿ç”¨å½“å‰é€‰æ‹©çš„èŠå¤©IDæˆ–è¯·æ±‚ç”¨æˆ·è¾“å…¥
            if (!targetPeerId) {
                if (ChatManager.currentChatId) {
                    targetPeerId = ChatManager.currentChatId;
                } else {
                    targetPeerId = prompt('è¯·è¾“å…¥è¦è¿æ¥çš„ç”¨æˆ·ID:');
                    if (!targetPeerId) return;
                }
            }

            try {
                if (!this.init(targetPeerId)) {
                    throw new Error('æ— æ³•åˆå§‹åŒ–WebRTCè¿æ¥');
                }

                const conn = this.connections[targetPeerId];

                // åˆ›å»ºæ•°æ®é€šé“
                conn.dataChannel = conn.peerConnection.createDataChannel("messageChannel", {
                    ordered: true,
                    maxRetransmits: 30
                });

                this.setupDataChannel(conn.dataChannel, targetPeerId);

                // åˆ›å»ºoffer
                const offer = await conn.peerConnection.createOffer({
                    offerToReceiveAudio: false,
                    offerToReceiveVideo: false
                });

                await conn.peerConnection.setLocalDescription(offer);
                UIManager.updateStatus("æ­£åœ¨æ”¶é›†ç½‘ç»œä¿¡æ¯...");

                // çŸ­æš‚å»¶è¿Ÿåæ›´æ–°SDPï¼ˆè®©ICEæ”¶é›†å¼€å§‹ï¼‰
                setTimeout(() => this.updateSdpText(targetPeerId), 1000);

                // åªç¦ç”¨å½“å‰æ“ä½œçš„æŒ‰é’®ï¼Œä¸å½±å“å…¶ä»–è¿æ¥
                UIManager.disableConnectionButtons('offer');

                // å¦‚æœç”¨æˆ·ä¸åœ¨è”ç³»äººåˆ—è¡¨ä¸­ï¼Œæ·»åŠ 
                if (!UserManager.contacts[targetPeerId]) {
                    UserManager.addContact(targetPeerId);
                }
            } catch (error) {
                Utils.log(`åˆ›å»ºè¿æ¥è¯·æ±‚å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.updateStatus('åˆ›å»ºè¿æ¥è¯·æ±‚å¤±è´¥');
            }
        },

        // åˆ›å»ºè¿æ¥å“åº”
        createAnswer: async function () {
            try {
                // è§£æå¯¹æ–¹çš„SDP
                const sdpText = document.getElementById('sdpText').value.trim();
                document.getElementById('sdpText').value = '';
                if (!sdpText) {
                    throw new Error('è¯·å…ˆç²˜è´´å¯¹æ–¹çš„è¿æ¥ä¿¡æ¯');
                }

                const offerData = JSON.parse(sdpText);

                if (!offerData.sdp) {
                    throw new Error('æ— æ•ˆçš„è¿æ¥ä¿¡æ¯æ ¼å¼');
                }

                // è·å–å¯¹æ–¹ID
                const targetPeerId = offerData.userId || prompt('è¯·è¾“å…¥å¯¹æ–¹çš„ç”¨æˆ·ID:');
                if (!targetPeerId) {
                    throw new Error('éœ€è¦å¯¹æ–¹IDæ‰èƒ½å»ºç«‹è¿æ¥');
                }

                if (!this.init(targetPeerId)) {
                    throw new Error('æ— æ³•åˆå§‹åŒ–WebRTCè¿æ¥');
                }

                const conn = this.connections[targetPeerId];

                // è®¾ç½®è¿œç¨‹æè¿°
                await conn.peerConnection.setRemoteDescription(new RTCSessionDescription(offerData.sdp));

                // æ·»åŠ ICEå€™é€‰è€…
                if (offerData.candidates && offerData.candidates.length > 0) {
                    for (const candidate of offerData.candidates) {
                        await conn.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                }

                // åˆ›å»ºåº”ç­”
                const answer = await conn.peerConnection.createAnswer();
                await conn.peerConnection.setLocalDescription(answer);

                UIManager.updateStatus("æ­£åœ¨æ”¶é›†ç½‘ç»œä¿¡æ¯...");

                // çŸ­æš‚å»¶è¿Ÿåæ›´æ–°SDP
                setTimeout(() => this.updateSdpText(targetPeerId), 1000);

                UIManager.disableConnectionButtons('answer');

                // å¦‚æœç”¨æˆ·ä¸åœ¨è”ç³»äººåˆ—è¡¨ä¸­ï¼Œæ·»åŠ 
                if (!UserManager.contacts[targetPeerId]) {
                    UserManager.addContact(targetPeerId);
                }
            } catch (error) {
                Utils.log(`åˆ›å»ºè¿æ¥å“åº”å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.updateStatus(`åˆ›å»ºè¿æ¥å“åº”å¤±è´¥: ${error.message}`);
            }
        },

        // å¤„ç†è¿æ¥å“åº”
        handleAnswer: async function () {
            try {
                // è§£æå¯¹æ–¹çš„SDP
                const sdpText = document.getElementById('sdpText').value.trim();
                if (!sdpText) {
                    throw new Error('è¯·å…ˆç²˜è´´å¯¹æ–¹çš„è¿æ¥ä¿¡æ¯');
                }

                const answerData = JSON.parse(sdpText);

                if (!answerData.sdp) {
                    throw new Error('æ— æ•ˆçš„è¿æ¥ä¿¡æ¯æ ¼å¼');
                }

                // è·å–å¯¹æ–¹ID
                const targetPeerId = answerData.userId;
                if (!targetPeerId) {
                    throw new Error('è¿æ¥ä¿¡æ¯ä¸­ç¼ºå°‘ç”¨æˆ·ID');
                }

                if (!this.connections[targetPeerId]) {
                    throw new Error('æœªæ‰¾åˆ°ä¸è¯¥ç”¨æˆ·çš„è¿æ¥ï¼Œè¯·å…ˆåˆ›å»ºè¿æ¥è¯·æ±‚');
                }

                const conn = this.connections[targetPeerId];

                // è®¾ç½®è¿œç¨‹æè¿°
                await conn.peerConnection.setRemoteDescription(new RTCSessionDescription(answerData.sdp));

                // æ·»åŠ ICEå€™é€‰è€…
                if (answerData.candidates && answerData.candidates.length > 0) {
                    for (const candidate of answerData.candidates) {
                        await conn.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                }

                UIManager.updateStatus("æ­£åœ¨å»ºç«‹è¿æ¥...");
                UIManager.disableConnectionButtons('complete');
                // æ¸…ç©ºè¿æ¥ä¿¡æ¯
                document.getElementById('sdpText').value = "";

                // å¦‚æœç”¨æˆ·ä¸åœ¨è”ç³»äººåˆ—è¡¨ä¸­ï¼Œæ·»åŠ 
                if (!UserManager.contacts[targetPeerId]) {
                    UserManager.addContact(targetPeerId);
                }
            } catch (error) {
                Utils.log(`å¤„ç†è¿æ¥å“åº”å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.updateStatus(`å¤„ç†è¿æ¥å“åº”å¤±è´¥: ${error.message}`);
            }
        },

        // å‘ç‰¹å®šç”¨æˆ·å‘é€æ¶ˆæ¯
        sendTo: function(peerId, message) {
            const conn = this.connections[peerId];
            if (!conn || !conn.dataChannel || conn.dataChannel.readyState !== 'open') {
                UIManager.showNotification(`æ— æ³•å‘é€æ¶ˆæ¯ï¼Œä¸${peerId}çš„è¿æ¥æœªå»ºç«‹`, 'error');
                return false;
            }

            try {
                // ç¡®ä¿æ¶ˆæ¯æ˜¯å¯¹è±¡
                let msgToSend = message;
                if (typeof message !== 'object') {
                    msgToSend = {
                        type: 'text',
                        content: message,
                        sender: UserManager.userId,
                        timestamp: new Date().toISOString()
                    };
                } else {
                    // æ·»åŠ å‘é€è€…ID
                    msgToSend.sender = UserManager.userId;
                    if (!msgToSend.timestamp) {
                        msgToSend.timestamp = new Date().toISOString();
                    }
                }

                conn.dataChannel.send(JSON.stringify(msgToSend));
                return true;
            } catch (error) {
                Utils.log(`å‘é€æ¶ˆæ¯å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                return false;
            }
        },

        // é‡ç½®æ‰€æœ‰è¿æ¥
        resetAllConnections: function() {
            // ç¡®è®¤å¯¹è¯æ¡†
            if (!confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰è¿æ¥å—ï¼Ÿè¿™å°†æ–­å¼€æ‰€æœ‰ç°æœ‰è¿æ¥ã€‚')) {
                return;
            }

            // å…³é—­æ‰€æœ‰è¿æ¥
            for (const peerId in this.connections) {
                this.close(peerId);
            }

            // æ¸…ç©ºè¿æ¥åˆ—è¡¨
            this.connections = {};
            this.iceCandidates = {};
            this.connectionTimeouts = {};
            this.reconnectAttempts = {};
            this.iceTimers = {};
            this.iceGatheringStartTimes = {};
            this.connectionStrengths = {};
            this.pendingChunks = {};

            // é‡ç½®UI
            UIManager.resetConnectionControls();
            UIManager.updateStatus('æ‰€æœ‰è¿æ¥å·²é‡ç½®');
            UIManager.enableChatInterface(false);

            // æ¸…ç©ºSDPæ–‡æœ¬
            document.getElementById('sdpText').value = '';

            // é€šçŸ¥ç”¨æˆ·
            UIManager.showNotification('æ‰€æœ‰è¿æ¥å·²é‡ç½®', 'info');

            Utils.log('æ‰€æœ‰è¿æ¥å·²é‡ç½®', Utils.logLevels.INFO);

            return true;
        }
    };

    // UI ç®¡ç†å™¨
    const UIManager = {
        // æ›´æ–°è¿æ¥çŠ¶æ€æ˜¾ç¤º
        updateConnectionState: function (connected, state = '') {
            const statusElement = document.getElementById('connectionStatus');
            if (connected) {
                statusElement.classList.add('connected');
                statusElement.classList.remove('disconnected');

                // æ˜¾ç¤ºè¿”å›èŠå¤©æŒ‰é’®
                document.querySelector('.sidebar').classList.add('show-back-btn');
            } else {
                if (state === 'disconnected') {
                    statusElement.classList.add('disconnected');
                } else {
                    statusElement.classList.remove('connected');
                }
            }
        },

        // å¯ç”¨/ç¦ç”¨èŠå¤©ç•Œé¢
        enableChatInterface: function(enabled) {
            const messageInput = document.getElementById('messageInput');
            const sendButton = document.getElementById('sendButton');
            const uploadButton = document.getElementById('uploadButton');
            const voiceButton = document.getElementById('voiceButton');
            const videoCallButton = document.getElementById('videoCallButton');
            const audioCallButton = document.getElementById('audioCallButton'); // æ–°å¢
            const clearChatButton = document.getElementById('clearChatButton');

            messageInput.disabled = !enabled;
            sendButton.disabled = !enabled;
            uploadButton.disabled = !enabled;
            voiceButton.disabled = !enabled;
            videoCallButton.disabled = !enabled;
            audioCallButton.disabled = !enabled; // æ–°å¢
            clearChatButton.disabled = !enabled;

            if (enabled) {
                // èšç„¦è¾“å…¥æ¡†
                setTimeout(() => messageInput.focus(), 300);
            }
        },

        // æ›´æ–°è¿æ¥çŠ¶æ€æ–‡æœ¬
        updateStatus: function (message, delay = 0) {
            const statusElement = document.getElementById('connectionStatus');

            if (delay > 0) {
                // å¦‚æœæœ‰å»¶è¿Ÿï¼Œæ˜¾ç¤ºå€’è®¡æ—¶
                statusElement.innerHTML = `${message} <span class="loading-spinner"></span>`;

                let countdown = Math.floor(delay / 1000);
                const timer = setInterval(() => {
                    countdown--;
                    if (countdown <= 0) {
                        clearInterval(timer);
                        statusElement.textContent = message;
                    } else {
                        statusElement.innerHTML = `${message} (${countdown}ç§’) <span class="loading-spinner"></span>`;
                    }
                }, 1000);
            } else {
                statusElement.textContent = message;
            }
        },

        // æ›´æ–°è¿æ¥è´¨é‡æŒ‡ç¤ºå™¨
        updateConnectionQuality: function (rtt) {
            const indicator = document.getElementById('qualityIndicator');
            const qualityText = document.getElementById('qualityText');

            if (!indicator || !qualityText) return;

            try {
                if (rtt < 0.3) {
                    indicator.className = 'quality-indicator quality-good';
                    qualityText.textContent = 'è‰¯å¥½';
                } else if (rtt < 0.8) {
                    indicator.className = 'quality-indicator quality-medium';
                    qualityText.textContent = 'ä¸€èˆ¬';
                } else {
                    indicator.className = 'quality-indicator quality-poor';
                    qualityText.textContent = 'è¾ƒå·®';
                }
            } catch (error) {
                Utils.log(`æ›´æ–°è¿æ¥è´¨é‡æ˜¾ç¤ºå¤±è´¥: ${error}`, Utils.logLevels.ERROR);
            }
        },

        // ç¦ç”¨è¿æ¥æŒ‰é’®
        disableConnectionButtons: function (stage) {
            switch (stage) {
                case 'offer':
                    document.getElementById('createOfferBtn').disabled = true;
                    document.getElementById('createAnswerBtn').disabled = true;
                    document.getElementById('handleAnswerBtn').disabled = false;
                    break;

                case 'answer':
                    document.getElementById('createOfferBtn').disabled = true;
                    document.getElementById('createAnswerBtn').disabled = true;
                    document.getElementById('handleAnswerBtn').disabled = true;
                    break;

                case 'complete':
                    document.getElementById('createOfferBtn').disabled = true;
                    document.getElementById('createAnswerBtn').disabled = true;
                    document.getElementById('handleAnswerBtn').disabled = true;
                    break;
            }
        },

        // é‡ç½®è¿æ¥æ§ä»¶
        resetConnectionControls: function () {
            // é‡ç½®è¿æ¥æŒ‰é’®çŠ¶æ€
            document.getElementById('createOfferBtn').disabled = false;
            document.getElementById('createAnswerBtn').disabled = false;
            document.getElementById('handleAnswerBtn').disabled = false;

            // å¦‚æœæ²¡æœ‰æ´»è·ƒè¿æ¥ï¼Œéšè—è¿”å›èŠå¤©æŒ‰é’®
            let hasActiveConnection = false;
            for (const peerId in ConnectionManager.connections) {
                const conn = ConnectionManager.connections[peerId];
                if (conn && conn.dataChannel && conn.dataChannel.readyState === 'open') {
                    hasActiveConnection = true;
                    break;
                }
            }

            if (!hasActiveConnection) {
                document.querySelector('.sidebar').classList.remove('show-back-btn');
                this.enableChatInterface(false);

                // ç§»åŠ¨ç«¯ï¼šåˆ‡æ¢å›è¿æ¥è®¾ç½®ç•Œé¢
                if (window.innerWidth <= 768) {
                    document.querySelector('.container').classList.remove('connected-mode');
                }
            }
        },

        // å¤åˆ¶æ–‡æœ¬
        copyText: function () {
            const textarea = document.getElementById('sdpText');
            textarea.select();
            document.execCommand('copy');

            const copyButton = document.querySelector('.copy-button');
            const originalText = copyButton.textContent;

            copyButton.textContent = 'å·²å¤åˆ¶ï¼';
            setTimeout(() => {
                copyButton.textContent = originalText;
            }, 2000);
        },

        // æ£€æŸ¥WebRTCæ”¯æŒ
        checkWebRTCSupport: function () {
            if (typeof RTCPeerConnection === 'undefined') {
                this.updateStatus('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ WebRTCï¼Œè¯·ä½¿ç”¨ Chrome ç­‰ç°ä»£æµè§ˆå™¨');
                Utils.log('æµè§ˆå™¨ä¸æ”¯æŒWebRTC', Utils.logLevels.ERROR);
                return false;
            }

            if (typeof navigator.mediaDevices === 'undefined' ||
                typeof navigator.mediaDevices.getUserMedia === 'undefined') {
                Utils.log('æµè§ˆå™¨å¯èƒ½ä¸å®Œå…¨æ”¯æŒåª’ä½“è®¾å¤‡API', Utils.logLevels.WARN);
            }

            return true;
        },

        // æ˜¾ç¤ºé€šçŸ¥æ¶ˆæ¯
        showNotification: function (message, type = 'info') {
            // åˆ›å»ºé€šçŸ¥å…ƒç´ 
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;

            // è®¾ç½®å›¾æ ‡
            let icon = '';
            switch (type) {
                case 'warning':
                    icon = 'âš ï¸';
                    break;
                case 'error':
                    icon = 'âŒ';
                    break;
                case 'success':
                    icon = 'âœ…';
                    break;
                default:
                    icon = 'â„¹ï¸';
            }

            notification.innerHTML = `
                <span class="notification-icon">${icon}</span>
                <span class="notification-message">${message}</span>
                <button class="notification-close">Ã—</button>
            `;

            // æ·»åŠ åˆ°ç•Œé¢
            if (!document.querySelector('.notification-container')) {
                const container = document.createElement('div');
                container.className = 'notification-container';
                document.body.appendChild(container);
            }

            const container = document.querySelector('.notification-container');
            container.appendChild(notification);

            // ç‚¹å‡»å…³é—­æŒ‰é’®ç§»é™¤é€šçŸ¥
            notification.querySelector('.notification-close').addEventListener('click', () => {
                notification.classList.add('notification-hide');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }

                    // å¦‚æœå®¹å™¨ä¸ºç©ºï¼Œç§»é™¤å®¹å™¨
                    if (container.children.length === 0) {
                        container.parentNode.removeChild(container);
                    }
                }, 300);
            });

            // è‡ªåŠ¨å…³é—­
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.add('notification-hide');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }

                        // å¦‚æœå®¹å™¨ä¸ºç©ºï¼Œç§»é™¤å®¹å™¨
                        if (container.children.length === 0) {
                            container.parentNode.removeChild(container);
                        }
                    }, 300);
                }
            }, 10000); // 10ç§’åè‡ªåŠ¨å…³é—­
        },

        // æ˜¾ç¤ºé‡è¿æç¤º
        showReconnectPrompt: function(peerId, onReconnectSuccess) {
            // åˆ›å»ºé‡è¿æç¤ºå…ƒç´ 
            const reconnectPrompt = document.createElement('div');
            reconnectPrompt.className = 'reconnect-prompt';
            reconnectPrompt.innerHTML = `
        <div class="reconnect-message">
            <p>è¿æ¥æœªå»ºç«‹ï¼Œæ— æ³•å‘é€æ¶ˆæ¯</p>
            <div class="reconnect-buttons">
                <button class="reconnect-btn">é‡æ–°è¿æ¥</button>
                <button class="cancel-btn">å–æ¶ˆ</button>
            </div>
        </div>
    `;

            // æ·»åŠ åˆ°èŠå¤©æ¡†
            const chatBox = document.getElementById('chatBox');
            chatBox.appendChild(reconnectPrompt);
            chatBox.scrollTop = chatBox.scrollHeight;

            // è®¾ç½®é‡è¿æŒ‰é’®äº‹ä»¶
            const reconnectBtn = reconnectPrompt.querySelector('.reconnect-btn');
            reconnectBtn.addEventListener('click', async () => {
                // ç§»é™¤æç¤º
                if (reconnectPrompt.parentNode) {
                    reconnectPrompt.parentNode.removeChild(reconnectPrompt);
                }

                // æ˜¾ç¤ºè¿æ¥é¢æ¿
                document.querySelector('.connection-tab[data-tab="connect"]').click();

                // å¦‚æœåœ¨ç§»åŠ¨è®¾å¤‡ä¸Šï¼Œåˆ‡æ¢åˆ°è¿æ¥ç•Œé¢
                if (window.innerWidth <= 768) {
                    document.querySelector('.container').classList.remove('connected-mode');
                }

                // é‡ç½®è¿æ¥æŒ‰é’®çŠ¶æ€
                this.resetConnectionControls();

                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
                const reconnectingMsg = document.createElement('div');
                reconnectingMsg.className = 'system-message';
                reconnectingMsg.textContent = 'æ­£åœ¨å°è¯•é‡æ–°è¿æ¥...';
                chatBox.appendChild(reconnectingMsg);

                // è‡ªåŠ¨å¼€å§‹è¿æ¥æµç¨‹
                try {
                    // æ¸…ç©ºä¹‹å‰çš„è¿æ¥ä¿¡æ¯
                    document.getElementById('sdpText').value = '';

                    // åˆå§‹åŒ–æ–°è¿æ¥
                    await ConnectionManager.createOffer();

                    // æ˜¾ç¤ºé€šçŸ¥
                    this.showNotification('è¯·å°†è¿æ¥ä¿¡æ¯å‘é€ç»™å¯¹æ–¹ï¼Œå¹¶ç­‰å¾…å¯¹æ–¹å›å¤', 'info');

                    // ç›‘å¬è¿æ¥çŠ¶æ€å˜åŒ–
                    const checkConnection = () => {
                        if (ConnectionManager.isConnectedTo(peerId)) {
                            // è¿æ¥æˆåŠŸ
                            const successMsg = document.createElement('div');
                            successMsg.className = 'system-message success';
                            successMsg.textContent = 'è¿æ¥å·²é‡æ–°å»ºç«‹';
                            chatBox.appendChild(successMsg);
                            chatBox.scrollTop = chatBox.scrollHeight;

                            // æ‰§è¡ŒæˆåŠŸå›è°ƒ
                            if (typeof onReconnectSuccess === 'function') {
                                onReconnectSuccess();
                            }

                            // å¦‚æœåœ¨ç§»åŠ¨è®¾å¤‡ä¸Šï¼Œåˆ‡æ¢å›èŠå¤©ç•Œé¢
                            if (window.innerWidth <= 768) {
                                document.querySelector('.container').classList.add('connected-mode');
                            }

                            return true;
                        }
                        return false;
                    };

                    // å®šæœŸæ£€æŸ¥è¿æ¥çŠ¶æ€
                    const checkInterval = setInterval(() => {
                        if (checkConnection()) {
                            clearInterval(checkInterval);
                        }
                    }, 2000);

                    // 60ç§’ååœæ­¢æ£€æŸ¥
                    setTimeout(() => {
                        clearInterval(checkInterval);
                        if (!ConnectionManager.isConnectedTo(peerId)) {
                            const failMsg = document.createElement('div');
                            failMsg.className = 'system-message error';
                            failMsg.textContent = 'è¿æ¥å»ºç«‹å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å®Œæˆè¿æ¥æ­¥éª¤';
                            chatBox.appendChild(failMsg);
                            chatBox.scrollTop = chatBox.scrollHeight;
                        }
                    }, 60000);

                } catch (error) {
                    Utils.log(`è‡ªåŠ¨é‡è¿å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                    this.showNotification('è‡ªåŠ¨é‡è¿å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å»ºç«‹è¿æ¥', 'error');
                }
            });

            // è®¾ç½®å–æ¶ˆæŒ‰é’®äº‹ä»¶
            const cancelBtn = reconnectPrompt.querySelector('.cancel-btn');
            cancelBtn.addEventListener('click', () => {
                if (reconnectPrompt.parentNode) {
                    reconnectPrompt.parentNode.removeChild(reconnectPrompt);
                }
            });

            // æ·»åŠ æ ·å¼
            if (!document.getElementById('reconnect-prompt-style')) {
                const style = document.createElement('style');
                style.id = 'reconnect-prompt-style';
                style.textContent = `
            .reconnect-prompt {
                padding: 10px;
                margin: 10px auto;
                max-width: 80%;
                background: rgba(255, 255, 255, 0.9);
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                text-align: center;
            }
            .reconnect-message {
                font-size: 14px;
                color: #333;
            }
            .reconnect-buttons {
                margin-top: 10px;
                display: flex;
                justify-content: center;
                gap: 10px;
            }
            .reconnect-btn {
                background: #007bff;
                color: white;
                border: none;
                padding: 5px 15px;
                border-radius: 4px;
                cursor: pointer;
            }
            .cancel-btn {
                background: #f44336;
                color: white;
                border: none;
                padding: 5px 15px;
                border-radius: 4px;
                cursor: pointer;
            }
            .system-message {
                text-align: center;
                padding: 5px 10px;
                margin: 5px auto;
                font-size: 12px;
                color: #666;
                background: rgba(0,0,0,0.05);
                border-radius: 10px;
                max-width: 80%;
            }
            .system-message.success {
                color: #4CAF50;
            }
            .system-message.error {
                color: #f44336;
            }
        `;
                document.head.appendChild(style);
            }
        }
    };

    // åª’ä½“ç®¡ç†å™¨
    const MediaManager = {
        mediaRecorder: null,
        audioChunks: [],
        recordingTimer: null,
        recordingStartTime: null,
        recordingDuration: 0,

        // åˆå§‹åŒ–è¯­éŸ³å½•åˆ¶
        initVoiceRecording: function() {
            // ä¸å†ä¸»åŠ¨è¯·æ±‚éº¦å…‹é£æƒé™ï¼Œè€Œæ˜¯åœ¨æŒ‰ä¸‹å½•éŸ³æŒ‰é’®æ—¶è¯·æ±‚

            // æ£€æŸ¥æ˜¯å¦åœ¨å®‰å…¨ä¸Šä¸‹æ–‡(HTTPS)
            if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                Utils.log('è¯­éŸ³å½•åˆ¶åŠŸèƒ½éœ€è¦HTTPSç¯å¢ƒ', Utils.logLevels.WARN);

                const voiceButton = document.getElementById('voiceButton');
                voiceButton.disabled = true;
                voiceButton.title = 'å½•éŸ³åŠŸèƒ½éœ€è¦HTTPSç¯å¢ƒ';
                voiceButton.innerHTML = '<span id="voiceButtonText">éœ€è¦HTTPS</span>';

                // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
                UIManager.showNotification('è¯­éŸ³å½•åˆ¶åŠŸèƒ½éœ€è¦HTTPSå®‰å…¨ç¯å¢ƒæ‰èƒ½ä½¿ç”¨ï¼Œè¯·ä½¿ç”¨HTTPSè®¿é—®æœ¬é¡µé¢ã€‚', 'warning');
                return;
            }

            // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒgetUserMedia
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                Utils.log('æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½', Utils.logLevels.WARN);

                const voiceButton = document.getElementById('voiceButton');
                voiceButton.disabled = true;
                voiceButton.title = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½';
                voiceButton.innerHTML = '<span id="voiceButtonText">å½•éŸ³ä¸å¯ç”¨</span>';
                return;
            }

            // å¯ç”¨å½•éŸ³æŒ‰é’®ï¼Œä½†å»¶è¿Ÿè¯·æ±‚æƒé™
            document.getElementById('voiceButton').disabled = false;
            Utils.log('è¯­éŸ³å½•åˆ¶æŒ‰é’®å·²å¯ç”¨ï¼Œå°†åœ¨ç”¨æˆ·ç‚¹å‡»æ—¶è¯·æ±‚æƒé™', Utils.logLevels.INFO);
        },

        // æ·»åŠ ä¸€ä¸ªæ–°æ–¹æ³•æ¥è¯·æ±‚éº¦å…‹é£æƒé™
        requestMicrophonePermission: async function() {
            if (this.mediaRecorder) {
                return true; // å·²ç»æœ‰æƒé™äº†
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({audio: true});

                // å°è¯•ä½¿ç”¨æ›´å¥½çš„ç¼–ç æ–¹å¼
                const options = {};

                // å°è¯•ä½¿ç”¨ opus ç¼–ç å™¨
                if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                    options.mimeType = 'audio/webm;codecs=opus';
                } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                    options.mimeType = 'audio/mp4';
                }

                this.mediaRecorder = new MediaRecorder(stream, options);

                this.mediaRecorder.ondataavailable = (event) => {
                    this.audioChunks.push(event.data);
                };

                this.mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(this.audioChunks, {type: options.mimeType || 'audio/webm'});
                    const reader = new FileReader();

                    reader.onloadend = () => {
                        MessageManager.audioData = reader.result;
                        MessageManager.audioDuration = this.recordingDuration;
                        this.displayAudioPreview(reader.result, this.recordingDuration);
                    };

                    reader.readAsDataURL(audioBlob);
                };

                Utils.log('éº¦å…‹é£æƒé™å·²è·å–', Utils.logLevels.INFO);
                return true;
            } catch (error) {
                Utils.log(`è·å–éº¦å…‹é£æƒé™å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);

                const voiceButton = document.getElementById('voiceButton');
                voiceButton.disabled = true;
                document.getElementById('voiceButtonText').textContent = 'å½•éŸ³ä¸å¯ç”¨';

                // æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯æç¤º
                UIManager.showNotification('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯­éŸ³å½•åˆ¶åŠŸèƒ½ä¸å¯ç”¨ã€‚', 'error');
                return false;
            }
        },

        // å¼€å§‹å½•éŸ³
        startRecording: async function() {
            // å…ˆè¯·æ±‚æƒé™
            if (!this.mediaRecorder) {
                const permissionGranted = await this.requestMicrophonePermission();
                if (!permissionGranted) return;
            }

            try {
                this.audioChunks = [];
                this.mediaRecorder.start();
                this.recordingStartTime = Date.now();

                const voiceButton = document.getElementById('voiceButton');
                const voiceButtonText = document.getElementById('voiceButtonText');
                const voiceTimer = document.getElementById('voiceTimer');

                voiceButton.classList.add('recording');
                voiceButtonText.textContent = 'åœæ­¢å½•éŸ³';
                voiceTimer.style.display = 'inline';

                this.recordingTimer = setInterval(() => this.updateRecordingTimer(), 1000);
                this.updateRecordingTimer();

                Utils.log('å¼€å§‹å½•éŸ³', Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`å¼€å§‹å½•éŸ³å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
            }
        },

        // åœæ­¢å½•éŸ³
        stopRecording: function () {
            if (!this.mediaRecorder || this.mediaRecorder.state !== 'recording') return;

            try {
                this.mediaRecorder.stop();
                clearInterval(this.recordingTimer);

                const voiceButton = document.getElementById('voiceButton');
                const voiceButtonText = document.getElementById('voiceButtonText');
                const voiceTimer = document.getElementById('voiceTimer');

                voiceButton.classList.remove('recording');
                voiceButtonText.textContent = 'å½•éŸ³';
                voiceTimer.style.display = 'none';

                Utils.log('å½•éŸ³å·²åœæ­¢', Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`åœæ­¢å½•éŸ³å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
            }
        },

        releaseAudioResources: function() {
            // æ£€æŸ¥æ˜¯å¦æœ‰æ´»è·ƒçš„åª’ä½“æµ
            if (this.mediaRecorder && this.mediaRecorder.stream) {
                // åœæ­¢æ‰€æœ‰éŸ³é¢‘è½¨é“
                this.mediaRecorder.stream.getTracks().forEach(track => {
                    track.stop();
                    Utils.log('éº¦å…‹é£èµ„æºå·²é‡Šæ”¾', Utils.logLevels.DEBUG);
                });
            }

            // é‡ç½®å½•éŸ³å™¨
            this.mediaRecorder = null;
        },

        // æ›´æ–°å½•éŸ³è®¡æ—¶å™¨
        updateRecordingTimer: function () {
            const now = Date.now();
            const duration = Math.floor((now - this.recordingStartTime) / 1000);
            this.recordingDuration = duration;

            const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
            const seconds = (duration % 60).toString().padStart(2, '0');
            document.getElementById('voiceTimer').textContent = `${minutes}:${seconds}`;

            // å¦‚æœè¶…è¿‡æœ€å¤§å½•åˆ¶æ—¶é—´ï¼Œè‡ªåŠ¨åœæ­¢
            if (duration >= Config.media.maxAudioDuration) {
                this.stopRecording();
            }
        },

        // å¤„ç†æ–‡ä»¶é€‰æ‹©æ–¹æ³•
        handleFileSelect: async function (event) {
            const file = event.target.files[0];
            if (!file) return;

            // æ£€æŸ¥æ–‡ä»¶å¤§å°
            const maxFileSize = 10 * 1024 * 1024; // 10MB
            if (file.size > maxFileSize) {
                alert(`æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ ${maxFileSize / 1024 / 1024} MB`);
                return;
            }

            try {
                const reader = new FileReader();

                reader.onload = async (e) => {
                    const fileData = e.target.result;
                    const fileType = file.type;
                    const fileName = file.name;
                    const fileSize = file.size;

                    // è®¾ç½®æ¶ˆæ¯å¯¹è±¡
                    MessageManager.selectedFile = {
                        data: fileData,
                        type: fileType,
                        name: fileName,
                        size: fileSize
                    };

                    // æ˜¾ç¤ºæ–‡ä»¶é¢„è§ˆ
                    this.displayFilePreview(MessageManager.selectedFile);
                };

                // ä½¿ç”¨readAsDataURLè¯»å–ä¸ºbase64æ ¼å¼
                reader.readAsDataURL(file);
            } catch (error) {
                Utils.log(`å¤„ç†æ–‡ä»¶å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                alert('å¤„ç†æ–‡ä»¶å¤±è´¥');
            }
        },

        // æ˜¾ç¤ºæ–‡ä»¶é¢„è§ˆæ–¹æ³•
        displayFilePreview: function (fileObj) {
            const container = document.getElementById('filePreviewContainer');
            const fileType = fileObj.type;
            const fileName = fileObj.name;
            let previewHtml = '';

            // æ ¹æ®æ–‡ä»¶ç±»å‹æ˜¾ç¤ºä¸åŒé¢„è§ˆ
            if (fileType.startsWith('image/')) {
                // å›¾ç‰‡é¢„è§ˆ
                previewHtml = `
                <div class="file-preview">
                    <div class="file-preview-header">
                        <span>${fileName}</span>
                        <button onclick="MessageManager.cancelFileData()">å–æ¶ˆ</button>
                    </div>
                    <div class="file-preview-content">
                        <img src="${fileObj.data}" class="image-preview" alt="${fileName}">
                    </div>
                </div>
            `;
            } else if (fileType.startsWith('video/')) {
                // è§†é¢‘é¢„è§ˆ
                previewHtml = `
                <div class="file-preview">
                    <div class="file-preview-header">
                        <span>${fileName}</span>
                        <button onclick="MessageManager.cancelFileData()">å–æ¶ˆ</button>
                    </div>
                    <div class="file-preview-content">
                        <video controls class="video-preview">
                            <source src="${fileObj.data}" type="${fileType}">
                            æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘é¢„è§ˆ
                        </video>
                    </div>
                </div>
            `;
            } else {
                // å…¶ä»–æ–‡ä»¶ç±»å‹ï¼Œæ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
                const fileSize = this.formatFileSize(fileObj.size);
                const fileIcon = this.getFileIcon(fileType);

                previewHtml = `
                <div class="file-preview">
                    <div class="file-preview-header">
                        <span>${fileName}</span>
                        <button onclick="MessageManager.cancelFileData()">å–æ¶ˆ</button>
                    </div>
                    <div class="file-preview-content file-info">
                        <div class="file-icon">${fileIcon}</div>
                        <div class="file-details">
                            <div class="file-name">${fileName}</div>
                            <div class="file-size">${fileSize}</div>
                            <div class="file-type">${fileType || 'æœªçŸ¥ç±»å‹'}</div>
                        </div>
                    </div>
                </div>
            `;
            }

            container.innerHTML = previewHtml;
        },

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        formatFileSize: function(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        },

        // è·å–æ–‡ä»¶å›¾æ ‡
        getFileIcon: function(mimeType) {
            if (!mimeType) return 'ğŸ“„';

            if (mimeType.startsWith('image/')) return 'ğŸ–¼ï¸';
            if (mimeType.startsWith('video/')) return 'ğŸ¬';
            if (mimeType.startsWith('audio/')) return 'ğŸµ';

            if (mimeType === 'application/pdf') return 'ğŸ“•';
            if (mimeType.includes('word')) return 'ğŸ“˜';
            if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) return 'ğŸ“—';
            if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return 'ğŸ“™';

            if (mimeType.includes('zip') || mimeType.includes('compressed')) return 'ğŸ—œï¸';
            if (mimeType.includes('text')) return 'ğŸ“';

            return 'ğŸ“„';
        },

        // æ˜¾ç¤ºéŸ³é¢‘é¢„è§ˆ
        displayAudioPreview: function (audioData, duration) {
            const container = document.getElementById('audioPreviewContainer');
            const formattedDuration = Utils.formatTime(duration);

            container.innerHTML = `
            <div class="voice-message">
                <button onclick="event.stopPropagation(); MediaManager.playAudio(this)" data-audio="${audioData}">
                    æ’­æ”¾
                </button>
                <div class="voice-wave">
                    ${Array(5).fill('<div class="wave-bar"></div>').join('')}
                </div>
                <span class="duration">${formattedDuration}</span>
                <button onclick="MessageManager.cancelAudioData()">å–æ¶ˆ</button>
            </div>
            `;

            // éŸ³é¢‘æ•°æ®å·²ä¿å­˜ï¼Œå¯ä»¥é‡Šæ”¾éº¦å…‹é£èµ„æº
            this.releaseAudioResources();
        },

        // æ’­æ”¾éŸ³é¢‘
        playAudio: function (button) {
            const audio = new Audio(button.dataset.audio);
            const originalText = button.textContent;

            button.textContent = 'æ’­æ”¾ä¸­...';
            audio.play();

            // æ·»åŠ æ³¢å½¢åŠ¨ç”»æ•ˆæœ
            const waveContainer = button.nextElementSibling;
            if (waveContainer && waveContainer.classList.contains('voice-wave')) {
                waveContainer.classList.add('playing');
            }

            audio.onended = () => {
                button.textContent = originalText;
                if (waveContainer) {
                    waveContainer.classList.remove('playing');
                }
            };

            audio.onerror = () => {
                button.textContent = 'æ’­æ”¾å¤±è´¥';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            };
        }
    };

    // è§†é¢‘é€šè¯ç®¡ç†å™¨
    const VideoCallManager = {
        localStream: null,
        remoteStream: null,
        localVideo: null,
        remoteVideo: null,
        currentPeerId: null,
        isCallActive: false,
        isCaller: false,
        isCallPending: false,
        isAudioMuted: false,
        isVideoEnabled: true,
        callRequestTimeout: null,

        // åˆå§‹åŒ–
        // åˆå§‹åŒ–
        init: function() {
            this.localVideo = document.getElementById('localVideo');
            this.remoteVideo = document.getElementById('remoteVideo');

            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                Utils.log('æµè§ˆå™¨ä¸æ”¯æŒéŸ³è§†é¢‘é€šè¯åŠŸèƒ½', Utils.logLevels.ERROR);
                document.getElementById('videoCallButton').disabled = true;
                document.getElementById('videoCallButton').title = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³è§†é¢‘é€šè¯';
                return false;
            }

            // ç›‘å¬è§†é¢‘é€šè¯æ¶ˆæ¯
            EventEmitter.on('dataChannelOpen', (peerId) => {
                if (ChatManager.currentChatId === peerId) {
                    document.getElementById('videoCallButton').disabled = false;
                    document.getElementById('videoCallButton').onclick = () => this.initiateCall(peerId);
                }
            });

            return true;
        },

        // å‘èµ·é€šè¯
        // å‘èµ·é€šè¯
        initiateCall: async function(peerId, audioOnly = false) {
            if (this.isCallActive || this.isCallPending) return;

            // å¦‚æœæ²¡æœ‰æŒ‡å®špeerIdï¼Œä½¿ç”¨å½“å‰èŠå¤©å¯¹è±¡
            if (!peerId) {
                peerId = ChatManager.currentChatId;
            }

            if (!peerId) {
                UIManager.showNotification('è¯·å…ˆé€‰æ‹©èŠå¤©å¯¹è±¡', 'warning');
                return;
            }

            if (!ConnectionManager.isConnectedTo(peerId)) {
                UIManager.showNotification('è¿æ¥æœªå»ºç«‹ï¼Œæ— æ³•å‘èµ·é€šè¯', 'error');
                return;
            }

            try {
                // æ£€æŸ¥è®¾å¤‡æ”¯æŒæƒ…å†µ
                if (!audioOnly) {
                    // æ£€æŸ¥è§†é¢‘è®¾å¤‡æ˜¯å¦å¯ç”¨
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const hasVideoDevice = devices.some(device => device.kind === 'videoinput');

                    if (!hasVideoDevice) {
                        UIManager.showNotification('æœªæ£€æµ‹åˆ°æ‘„åƒå¤´è®¾å¤‡ï¼Œå°†ä½¿ç”¨è¯­éŸ³é€šè¯æ¨¡å¼', 'warning');
                        audioOnly = true;
                    } else {
                        // å°è¯•è·å–è§†é¢‘æƒé™
                        try {
                            const testStream = await navigator.mediaDevices.getUserMedia({video: true});
                            // æˆåŠŸè·å–åç«‹å³é‡Šæ”¾
                            testStream.getTracks().forEach(track => track.stop());
                        } catch (error) {
                            UIManager.showNotification('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œå°†ä½¿ç”¨è¯­éŸ³é€šè¯æ¨¡å¼', 'warning');
                            Utils.log(`è§†é¢‘æƒé™æ£€æŸ¥å¤±è´¥: ${error.message}`, Utils.logLevels.WARN);
                            audioOnly = true;
                        }
                    }
                }

                // æ£€æŸ¥éŸ³é¢‘è®¾å¤‡
                try {
                    const testAudioStream = await navigator.mediaDevices.getUserMedia({audio: true});
                    // æˆåŠŸè·å–åç«‹å³é‡Šæ”¾
                    testAudioStream.getTracks().forEach(track => track.stop());
                } catch (error) {
                    UIManager.showNotification('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œé€šè¯åŠŸèƒ½ä¸å¯ç”¨', 'error');
                    Utils.log(`éŸ³é¢‘æƒé™æ£€æŸ¥å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                    return;
                }

                this.currentPeerId = peerId;
                this.isCaller = true;
                this.isCallPending = true;
                this.isAudioOnly = audioOnly;

                // å‘ŠçŸ¥å¯¹æ–¹è¯·æ±‚é€šè¯
                const callRequest = {
                    type: 'video-call-request',
                    audioOnly: audioOnly,
                    timestamp: Date.now(),
                    sender: UserManager.userId
                };

                ConnectionManager.sendTo(peerId, callRequest);

                UIManager.showNotification(`ç­‰å¾…å¯¹æ–¹æ¥å—${audioOnly ? 'è¯­éŸ³' : 'è§†é¢‘'}é€šè¯...`, 'info');
                Utils.log(`å·²å‘é€${audioOnly ? 'è¯­éŸ³' : 'è§†é¢‘'}é€šè¯è¯·æ±‚`, Utils.logLevels.INFO);

                // 30ç§’è¶…æ—¶
                this.callRequestTimeout = setTimeout(() => {
                    if (this.isCallPending) {
                        this.isCallPending = false;
                        this.isCaller = false;
                        this.currentPeerId = null;
                        UIManager.showNotification('å¯¹æ–¹æœªåº”ç­”ï¼Œé€šè¯è¯·æ±‚å·²å–æ¶ˆ', 'warning');

                        // å‘é€å–æ¶ˆæ¶ˆæ¯
                        const cancelRequest = {
                            type: 'video-call-cancel',
                            timestamp: Date.now(),
                            sender: UserManager.userId
                        };
                        ConnectionManager.sendTo(peerId, cancelRequest);
                    }
                }, 30000);
            } catch (error) {
                Utils.log(`å‘èµ·é€šè¯å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.showNotification('å‘èµ·é€šè¯å¤±è´¥', 'error');
                this.isCallPending = false;
                this.isCaller = false;
                this.currentPeerId = null;
            }
        },

        // æ˜¾ç¤ºé€šè¯è¯·æ±‚
        showCallRequest: function(peerId, audioOnly = false) {
            this.currentPeerId = peerId;
            this.isAudioOnly = audioOnly;

            // ä¿®æ”¹é€šè¯è¯·æ±‚ç•Œé¢ï¼Œæ˜¾ç¤ºæ˜¯è¯­éŸ³è¿˜æ˜¯è§†é¢‘é€šè¯è¯·æ±‚
            const requestTitle = document.querySelector('#videoCallRequest h3');
            const requestDesc = document.querySelector('#videoCallRequest p');
            if (requestTitle && requestDesc) {
                requestTitle.textContent = audioOnly ? 'è¯­éŸ³é€šè¯è¯·æ±‚' : 'è§†é¢‘é€šè¯è¯·æ±‚';
                requestDesc.textContent = `å¯¹æ–¹è¯·æ±‚ä¸æ‚¨è¿›è¡Œ${audioOnly ? 'è¯­éŸ³' : 'è§†é¢‘'}é€šè¯`;
            }

            document.getElementById('videoCallRequest').style.display = 'flex';
        },

        // éšè—é€šè¯è¯·æ±‚
        hideCallRequest: function() {
            document.getElementById('videoCallRequest').style.display = 'none';
        },

        // æ¥å—é€šè¯
        acceptCall: async function() {
            this.hideCallRequest();

            if (!this.currentPeerId) {
                UIManager.showNotification('é€šè¯è¯·æ±‚æ— æ•ˆ', 'error');
                return;
            }

            try {
                // æ˜¾ç¤ºè·å–åª’ä½“è®¾å¤‡æƒé™çš„æç¤º
                UIManager.showNotification('æ­£åœ¨è¯·æ±‚åª’ä½“è®¾å¤‡æƒé™...', 'info');

                // æ£€æŸ¥è®¾å¤‡æ”¯æŒæƒ…å†µ
                if (!this.isAudioOnly) {
                    // æ£€æŸ¥è§†é¢‘è®¾å¤‡æ˜¯å¦å¯ç”¨
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const hasVideoDevice = devices.some(device => device.kind === 'videoinput');

                    if (!hasVideoDevice) {
                        UIManager.showNotification('æœªæ£€æµ‹åˆ°æ‘„åƒå¤´è®¾å¤‡ï¼Œå°†ä½¿ç”¨è¯­éŸ³é€šè¯æ¨¡å¼', 'warning');
                        this.isAudioOnly = true;
                    } else {
                        // å°è¯•è·å–è§†é¢‘æƒé™
                        try {
                            const testStream = await navigator.mediaDevices.getUserMedia({video: true});
                            // æˆåŠŸè·å–åç«‹å³é‡Šæ”¾
                            testStream.getTracks().forEach(track => track.stop());
                        } catch (error) {
                            UIManager.showNotification('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œå°†ä½¿ç”¨è¯­éŸ³é€šè¯æ¨¡å¼', 'warning');
                            Utils.log(`è§†é¢‘æƒé™æ£€æŸ¥å¤±è´¥: ${error.message}`, Utils.logLevels.WARN);
                            this.isAudioOnly = true;
                        }
                    }
                }

                // è·å–åª’ä½“æƒé™
                this.localStream = await navigator.mediaDevices.getUserMedia({
                    video: !this.isAudioOnly,
                    audio: true
                });

                // æ˜¾ç¤ºæœ¬åœ°è§†é¢‘ï¼ˆå¦‚æœæ˜¯è§†é¢‘é€šè¯ï¼‰
                this.localVideo.srcObject = this.localStream;

                // å¦‚æœæ˜¯çº¯è¯­éŸ³é€šè¯ï¼Œéšè—æœ¬åœ°è§†é¢‘åŒºåŸŸ
                this.localVideo.style.display = this.isAudioOnly ? 'none' : 'block';

                // è®¾ç½®éŸ³é¢‘ä¸“ç”¨æŒ‰é’®çŠ¶æ€
                const audioOnlyBtn = document.getElementById('audioOnlyBtn');
                if (audioOnlyBtn) {
                    audioOnlyBtn.style.background = this.isAudioOnly ? '#4CAF50' : '#fff';
                    audioOnlyBtn.title = this.isAudioOnly ? 'åˆ‡æ¢åˆ°è§†é¢‘é€šè¯' : 'åˆ‡æ¢åˆ°çº¯è¯­éŸ³é€šè¯';
                }

                // ä½¿ç”¨ç°æœ‰çš„è¿æ¥
                this.setupPeerConnection();

                // æ˜¾ç¤ºè§†é¢‘é€šè¯ç•Œé¢
                document.getElementById('videoCallContainer').style.display = 'flex';

                // å‘é€æ¥å—ä¿¡å·
                const acceptMessage = {
                    type: 'video-call-accepted',
                    audioOnly: this.isAudioOnly,
                    timestamp: Date.now(),
                    sender: UserManager.userId
                };
                ConnectionManager.sendTo(this.currentPeerId, acceptMessage);

                this.isCallActive = true;
                this.isCallPending = false;

                Utils.log(`å·²æ¥å—${this.isAudioOnly ? 'è¯­éŸ³' : 'è§†é¢‘'}é€šè¯`, Utils.logLevels.INFO);
            } catch (error) {
                Utils.log(`æ¥å—é€šè¯å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.showNotification('æ— æ³•è®¿é—®åª’ä½“è®¾å¤‡', 'error');

                // å‘é€æ‹’ç»æ¶ˆæ¯ï¼Œæ ‡æ˜åŸå› æ˜¯è®¾å¤‡é—®é¢˜
                const rejectMessage = {
                    type: 'video-call-rejected',
                    reason: 'device_error',
                    timestamp: Date.now(),
                    sender: UserManager.userId
                };
                ConnectionManager.sendTo(this.currentPeerId, rejectMessage);

                this.currentPeerId = null;
            }
        },

        // æ‹’ç»é€šè¯
        rejectCall: function() {
            this.hideCallRequest();

            if (!this.currentPeerId) return;

            // å‘é€æ‹’ç»æ¶ˆæ¯
            const rejectMessage = {
                type: 'video-call-rejected',
                reason: 'user_rejected',
                timestamp: Date.now(),
                sender: UserManager.userId
            };
            ConnectionManager.sendTo(this.currentPeerId, rejectMessage);

            // é‡ç½®çŠ¶æ€
            this.isCallPending = false;
            this.isCallActive = false;
            this.isCaller = false;
            this.currentPeerId = null;
            this.isAudioOnly = false;

            Utils.log('å·²æ‹’ç»é€šè¯è¯·æ±‚', Utils.logLevels.INFO);
        },

        // è®¾ç½®å¯¹ç­‰è¿æ¥
        setupPeerConnection: function() {
            // ä½¿ç”¨å·²æœ‰çš„è¿æ¥ä¼ é€’ä¿¡ä»¤
            if (!this.currentPeerId || !ConnectionManager.connections[this.currentPeerId]) {
                Utils.log('æ— æ³•åˆ›å»ºé€šè¯è¿æ¥: æ²¡æœ‰åŸºç¡€è¿æ¥', Utils.logLevels.ERROR);
                return;
            }

            const conn = ConnectionManager.connections[this.currentPeerId];

            // æ·»åŠ æœ¬åœ°æµ
            this.localStream.getTracks().forEach(track => {
                conn.peerConnection.addTrack(track, this.localStream);
            });

            // å¤„ç†è¿œç¨‹æµ
            conn.peerConnection.ontrack = (event) => {
                if (event.streams && event.streams[0]) {
                    this.remoteVideo.srcObject = event.streams[0];
                    this.remoteStream = event.streams[0];

                    // æ£€æŸ¥æ˜¯å¦æœ‰è§†é¢‘è½¨é“ï¼Œå¦‚æœåªæœ‰éŸ³é¢‘åˆ™éšè—è¿œç¨‹è§†é¢‘
                    const hasVideoTrack = event.streams[0].getVideoTracks().length > 0;
                    this.remoteVideo.style.display = hasVideoTrack ? 'block' : 'none';

                    Utils.log(`æ”¶åˆ°è¿œç¨‹${hasVideoTrack ? 'è§†é¢‘' : 'éŸ³é¢‘'}æµ`, Utils.logLevels.INFO);
                }
            };

            // å¦‚æœæ˜¯å‘¼å«æ–¹ï¼Œåˆ›å»ºå¹¶å‘é€offer
            if (this.isCaller) {
                this.createAndSendOffer();
            }
        },

        // åˆ›å»ºå¹¶å‘é€offer
        createAndSendOffer: async function() {
            try {
                if (!this.currentPeerId) return;

                const conn = ConnectionManager.connections[this.currentPeerId];
                if (!conn || !conn.peerConnection) return;

                const offer = await conn.peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: !this.isAudioOnly
                });

                await conn.peerConnection.setLocalDescription(offer);

                // å‘é€offerç»™å¯¹æ–¹
                const offerMessage = {
                    type: 'video-call-offer',
                    sdp: conn.peerConnection.localDescription,
                    audioOnly: this.isAudioOnly,
                    sender: UserManager.userId
                };
                ConnectionManager.sendTo(this.currentPeerId, offerMessage);

                Utils.log(`å·²å‘é€${this.isAudioOnly ? 'è¯­éŸ³' : 'è§†é¢‘'}é€šè¯offer`, Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`åˆ›å»ºofferå¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                this.endCall();
            }
        },

        // å¤„ç†æ”¶åˆ°çš„offer
        handleOffer: async function(offer, peerId, audioOnly) {
            try {
                this.currentPeerId = peerId;
                this.isAudioOnly = audioOnly;

                const conn = ConnectionManager.connections[peerId];
                if (!conn || !conn.peerConnection) return;

                await conn.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

                // åˆ›å»ºanswer
                const answer = await conn.peerConnection.createAnswer();
                await conn.peerConnection.setLocalDescription(answer);

                // å‘é€answerç»™å¯¹æ–¹
                const answerMessage = {
                    type: 'video-call-answer',
                    sdp: conn.peerConnection.localDescription,
                    audioOnly: this.isAudioOnly,
                    sender: UserManager.userId
                };
                ConnectionManager.sendTo(peerId, answerMessage);

                Utils.log(`å·²å›å¤${this.isAudioOnly ? 'è¯­éŸ³' : 'è§†é¢‘'}é€šè¯answer`, Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`å¤„ç†offerå¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                this.endCall();
            }
        },

        // å¤„ç†æ”¶åˆ°çš„answer
        handleAnswer: async function(answer, peerId, audioOnly) {
            try {
                if (this.currentPeerId !== peerId) return;

                // æ›´æ–°é€šè¯ç±»å‹
                this.isAudioOnly = audioOnly;

                // æ›´æ–°UIæ˜¾ç¤º
                this.updateUIForCallType();

                const conn = ConnectionManager.connections[peerId];
                if (!conn || !conn.peerConnection) return;

                await conn.peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                Utils.log('å·²è®¾ç½®è¿œç¨‹æè¿°', Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`å¤„ç†answerå¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                this.endCall();
            }
        },

        // åˆ‡æ¢æ‘„åƒå¤´
        toggleCamera: function() {
            if (!this.localStream) return;

            // å¦‚æœæ˜¯çº¯è¯­éŸ³æ¨¡å¼ï¼Œåˆ‡æ¢åˆ°è§†é¢‘æ¨¡å¼
            if (this.isAudioOnly) {
                this.toggleAudioOnly();
                return;
            }

            const videoTrack = this.localStream.getVideoTracks()[0];
            if (videoTrack) {
                this.isVideoEnabled = !this.isVideoEnabled;
                videoTrack.enabled = this.isVideoEnabled;

                const button = document.getElementById('toggleCameraBtn');
                button.innerHTML = this.isVideoEnabled ? 'ğŸ“¹' : 'ğŸš«';
                button.style.background = this.isVideoEnabled ? '#fff' : '#666';

                Utils.log(`æ‘„åƒå¤´å·²${this.isVideoEnabled ? 'å¼€å¯' : 'å…³é—­'}`, Utils.logLevels.DEBUG);
            } else {
                // æ²¡æœ‰è§†é¢‘è½¨é“ï¼Œå¯èƒ½æ˜¯è®¾å¤‡ä¸æ”¯æŒæˆ–æƒé™é—®é¢˜
                UIManager.showNotification('æ— æ³•è®¿é—®æ‘„åƒå¤´', 'warning');
            }
        },

        // åˆ‡æ¢éº¦å…‹é£
        toggleAudio: function() {
            if (!this.localStream) return;

            const audioTrack = this.localStream.getAudioTracks()[0];
            if (audioTrack) {
                this.isAudioMuted = !this.isAudioMuted;
                audioTrack.enabled = !this.isAudioMuted;

                const button = document.getElementById('toggleAudioBtn');
                button.innerHTML = this.isAudioMuted ? 'ğŸ”‡' : 'ğŸ¤';
                button.style.background = this.isAudioMuted ? '#666' : '#fff';

                Utils.log(`éº¦å…‹é£å·²${this.isAudioMuted ? 'é™éŸ³' : 'å¼€å¯'}`, Utils.logLevels.DEBUG);
            }
        },

        // åˆ‡æ¢çº¯è¯­éŸ³æ¨¡å¼
        // åˆ‡æ¢çº¯è¯­éŸ³æ¨¡å¼
        toggleAudioOnly: async function() {
            if (!this.isCallActive) return;

            try {
                // å¦‚æœè¦åˆ‡æ¢åˆ°è§†é¢‘æ¨¡å¼ï¼Œå…ˆæ£€æŸ¥æ˜¯å¦æ”¯æŒè§†é¢‘
                if (this.isAudioOnly) {
                    // æ£€æŸ¥è§†é¢‘è®¾å¤‡æ˜¯å¦å¯ç”¨
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const hasVideoDevice = devices.some(device => device.kind === 'videoinput');

                    if (!hasVideoDevice) {
                        UIManager.showNotification('æœªæ£€æµ‹åˆ°æ‘„åƒå¤´è®¾å¤‡ï¼Œæ— æ³•åˆ‡æ¢åˆ°è§†é¢‘æ¨¡å¼', 'warning');
                        return;
                    }

                    // å°è¯•è·å–è§†é¢‘æƒé™
                    try {
                        const testStream = await navigator.mediaDevices.getUserMedia({video: true});
                        // æˆåŠŸè·å–åç«‹å³é‡Šæ”¾
                        testStream.getTracks().forEach(track => track.stop());
                    } catch (error) {
                        UIManager.showNotification('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œæ— æ³•åˆ‡æ¢åˆ°è§†é¢‘æ¨¡å¼', 'error');
                        Utils.log(`è§†é¢‘æƒé™æ£€æŸ¥å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                        return;
                    }
                }

                this.isAudioOnly = !this.isAudioOnly;

                // æ›´æ–°UI
                this.updateUIForCallType();

                // åœæ­¢å½“å‰åª’ä½“æµ
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                }

                // é‡æ–°è·å–åª’ä½“æƒé™
                this.localStream = await navigator.mediaDevices.getUserMedia({
                    video: !this.isAudioOnly,
                    audio: true
                });

                // æ›´æ–°æœ¬åœ°è§†é¢‘
                this.localVideo.srcObject = this.localStream;

                const conn = ConnectionManager.connections[this.currentPeerId];
                if (!conn || !conn.peerConnection) return;

                // æ›¿æ¢æ‰€æœ‰è½¨é“
                const senders = conn.peerConnection.getSenders();
                const tracks = this.localStream.getTracks();

                // æŸ¥æ‰¾å·²æœ‰çš„éŸ³é¢‘å’Œè§†é¢‘å‘é€å™¨
                const audioSender = senders.find(s => s.track && s.track.kind === 'audio');
                const videoSender = senders.find(s => s.track && s.track.kind === 'video');

                // è·å–æ–°çš„éŸ³é¢‘å’Œè§†é¢‘è½¨é“
                const audioTrack = tracks.find(t => t.kind === 'audio');
                const videoTrack = tracks.find(t => t.kind === 'video');

                // æ›¿æ¢éŸ³é¢‘è½¨é“
                if (audioSender && audioTrack) {
                    audioSender.replaceTrack(audioTrack);
                } else if (audioTrack) {
                    conn.peerConnection.addTrack(audioTrack, this.localStream);
                }

                // å¤„ç†è§†é¢‘è½¨é“
                if (this.isAudioOnly) {
                    // åœ¨çº¯è¯­éŸ³æ¨¡å¼ä¸‹ï¼Œå¦‚æœæœ‰è§†é¢‘å‘é€å™¨ï¼Œå°†å…¶ç§»é™¤
                    if (videoSender) {
                        try {
                            conn.peerConnection.removeTrack(videoSender);
                        } catch (e) {
                            Utils.log(`ç§»é™¤è§†é¢‘è½¨é“å¤±è´¥: ${e.message}`, Utils.logLevels.ERROR);
                        }
                    }
                } else {
                    // åœ¨è§†é¢‘æ¨¡å¼ä¸‹ï¼Œæ›¿æ¢æˆ–æ·»åŠ è§†é¢‘è½¨é“
                    if (videoSender && videoTrack) {
                        videoSender.replaceTrack(videoTrack);
                    } else if (videoTrack) {
                        conn.peerConnection.addTrack(videoTrack, this.localStream);
                    }
                }

                // é€šçŸ¥å¯¹æ–¹æ¨¡å¼å·²æ›´æ”¹
                const modeChangeMsg = {
                    type: 'video-call-mode-change',
                    audioOnly: this.isAudioOnly,
                    timestamp: Date.now(),
                    sender: UserManager.userId
                };
                ConnectionManager.sendTo(this.currentPeerId, modeChangeMsg);

                Utils.log(`å·²åˆ‡æ¢åˆ°${this.isAudioOnly ? 'çº¯è¯­éŸ³' : 'è§†é¢‘'}é€šè¯æ¨¡å¼`, Utils.logLevels.INFO);
            } catch (error) {
                Utils.log(`åˆ‡æ¢é€šè¯æ¨¡å¼å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.showNotification('åˆ‡æ¢é€šè¯æ¨¡å¼å¤±è´¥', 'error');
            }
        },

        // æ›´æ–°UIä»¥åŒ¹é…å½“å‰é€šè¯ç±»å‹
        updateUIForCallType: function() {
            // è®¾ç½®æœ¬åœ°è§†é¢‘æ˜¾ç¤º
            if (this.localVideo) {
                this.localVideo.style.display = this.isAudioOnly ? 'none' : 'block';
            }

            // æ›´æ–°éŸ³é¢‘æ¨¡å¼æŒ‰é’®
            const audioOnlyBtn = document.getElementById('audioOnlyBtn');
            if (audioOnlyBtn) {
                audioOnlyBtn.style.background = this.isAudioOnly ? '#4CAF50' : '#fff';
                audioOnlyBtn.title = this.isAudioOnly ? 'åˆ‡æ¢åˆ°è§†é¢‘é€šè¯' : 'åˆ‡æ¢åˆ°çº¯è¯­éŸ³é€šè¯';
            }

            // æ›´æ–°æ‘„åƒå¤´æŒ‰é’®çŠ¶æ€
            const cameraBtn = document.getElementById('toggleCameraBtn');
            if (cameraBtn) {
                cameraBtn.style.display = this.isAudioOnly ? 'none' : 'inline-block';
            }

            // è°ƒæ•´è§†é¢‘å®¹å™¨çš„å¸ƒå±€
            const videoContainer = document.getElementById('videoCallContainer');
            if (videoContainer) {
                videoContainer.classList.toggle('audio-only-mode', this.isAudioOnly);
            }
        },

        // ç»“æŸé€šè¯
        endCall: function() {
            // æ¸…é™¤è¶…æ—¶å®šæ—¶å™¨
            if (this.callRequestTimeout) {
                clearTimeout(this.callRequestTimeout);
                this.callRequestTimeout = null;
            }

            // å‘é€ç»“æŸé€šè¯ä¿¡å·
            if ((this.isCallActive || this.isCallPending) && this.currentPeerId) {
                const endCallMessage = {
                    type: 'video-call-end',
                    timestamp: Date.now(),
                    sender: UserManager.userId
                };
                try {
                    ConnectionManager.sendTo(this.currentPeerId, endCallMessage);
                } catch (error) {
                    Utils.log(`å‘é€ç»“æŸé€šè¯æ¶ˆæ¯å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                }
            }

            // å½»åº•å…³é—­å¹¶åœæ­¢æ‰€æœ‰åª’ä½“è½¨é“
            this.releaseMediaResources();

            // é‡ç½®è§†é¢‘å…ƒç´ 
            if (this.localVideo) this.localVideo.srcObject = null;
            if (this.remoteVideo) this.remoteVideo.srcObject = null;
            this.remoteStream = null;

            // éšè—è§†é¢‘é€šè¯ç•Œé¢
            document.getElementById('videoCallContainer').style.display = 'none';
            this.hideCallRequest();

            // é‡ç½®çŠ¶æ€
            this.isCallActive = false;
            this.isCallPending = false;
            this.isCaller = false;
            this.isAudioMuted = false;
            this.isVideoEnabled = true;
            this.isAudioOnly = false;
            this.currentPeerId = null;

            // é‡ç½®è¿æ¥æŒ‰é’®çŠ¶æ€
            UIManager.resetConnectionControls();

            Utils.log('é€šè¯å·²ç»“æŸï¼Œæ‰€æœ‰èµ„æºå·²é‡Šæ”¾', Utils.logLevels.INFO);
        },

        // æ·»åŠ ä¸€ä¸ªæ–°æ–¹æ³•ä¸“é—¨è´Ÿè´£é‡Šæ”¾åª’ä½“èµ„æº
        releaseMediaResources: function() {
            // å…³é—­æœ¬åœ°è§†é¢‘/éŸ³é¢‘è½¨é“
            if (this.localStream) {
                this.localStream.getTracks().forEach(track => {
                    track.stop();
                    Utils.log(`å·²åœæ­¢${track.kind}è½¨é“`, Utils.logLevels.DEBUG);
                });
                this.localStream = null;
            }

            // å¦‚æœæœ‰è¿œç¨‹æµï¼Œä¹Ÿå¯ä»¥è€ƒè™‘æ¸…ç†
            if (this.remoteStream) {
                // æˆ‘ä»¬ä¸éœ€è¦åœæ­¢è¿œç¨‹è½¨é“ï¼Œä½†å¯ä»¥æ¸…é™¤å¼•ç”¨
                this.remoteStream = null;
            }
        },

        // å¤„ç†æ¶ˆæ¯
        handleMessage: function(message, peerId) {
            switch (message.type) {
                case 'video-call-request':
                    if (!this.isCallActive && !this.isCallPending) {
                        this.isCallPending = true;
                        // æ³¨æ„æ–°å¢çš„audioOnlyå‚æ•°
                        this.showCallRequest(peerId, message.audioOnly || false);
                        Utils.log(`æ”¶åˆ°${message.audioOnly ? 'è¯­éŸ³' : 'è§†é¢‘'}é€šè¯è¯·æ±‚`, Utils.logLevels.INFO);
                    } else {
                        // å·²åœ¨é€šè¯ä¸­ï¼Œè‡ªåŠ¨æ‹’ç»
                        const busyMessage = {
                            type: 'video-call-rejected',
                            reason: 'busy',
                            timestamp: Date.now(),
                            sender: UserManager.userId
                        };
                        ConnectionManager.sendTo(peerId, busyMessage);
                    }
                    break;

                case 'video-call-accepted':
                    if (this.isCallPending && this.isCaller && this.currentPeerId === peerId) {
                        clearTimeout(this.callRequestTimeout);
                        this.callRequestTimeout = null;

                        // æ›´æ–°é€šè¯ç±»å‹ï¼ˆæ¥æ”¶æ–¹å¯èƒ½æ”¹å˜äº†é€šè¯ç±»å‹ï¼‰
                        if (typeof message.audioOnly !== 'undefined') {
                            this.isAudioOnly = message.audioOnly;
                        }

                        // å¯¹æ–¹å·²æ¥å—ï¼Œå¼€å§‹é€šè¯
                        this.startLocalStream();
                    }
                    break;

                case 'video-call-rejected':
                    if (this.isCallPending && this.currentPeerId === peerId) {
                        clearTimeout(this.callRequestTimeout);
                        this.callRequestTimeout = null;
                        this.isCallPending = false;
                        this.isCaller = false;
                        this.currentPeerId = null;
                        this.isAudioOnly = false;

                        // é‡Šæ”¾å·²ç”³è¯·çš„ä»»ä½•åª’ä½“èµ„æº
                        this.releaseMediaResources();

                        let reason = 'å¯¹æ–¹æ‹’ç»äº†é€šè¯';
                        if (message.reason === 'busy') {
                            reason = 'å¯¹æ–¹æ­£å¿™';
                        } else if (message.reason === 'device_error') {
                            reason = 'å¯¹æ–¹æ— æ³•è®¿é—®éº¦å…‹é£æˆ–æ‘„åƒå¤´';
                        }

                        UIManager.showNotification(reason, 'warning');
                        Utils.log(`é€šè¯è¢«æ‹’ç»: ${message.reason}`, Utils.logLevels.INFO);
                    }
                    break;

                case 'video-call-cancel':
                    if (this.isCallPending && !this.isCaller && this.currentPeerId === peerId) {
                        this.isCallPending = false;
                        this.hideCallRequest();
                        this.currentPeerId = null;
                        this.isAudioOnly = false;

                        // é‡Šæ”¾å·²ç”³è¯·çš„ä»»ä½•åª’ä½“èµ„æº
                        this.releaseMediaResources();

                        Utils.log('å¯¹æ–¹å–æ¶ˆäº†é€šè¯è¯·æ±‚', Utils.logLevels.INFO);
                    }
                    break;

                case 'video-call-offer':
                    if (this.isCallActive && !this.isCaller && this.currentPeerId === peerId) {
                        // æ³¨æ„æ–°å¢çš„audioOnlyå‚æ•°
                        this.handleOffer(message.sdp, peerId, message.audioOnly || false);
                    }
                    break;

                case 'video-call-answer':
                    if (this.isCallActive && this.isCaller && this.currentPeerId === peerId) {
                        // æ³¨æ„æ–°å¢çš„audioOnlyå‚æ•°
                        this.handleAnswer(message.sdp, peerId, message.audioOnly || false);
                    }
                    break;

                case 'video-call-mode-change':
                    if (this.isCallActive && this.currentPeerId === peerId) {
                        // å¯¹æ–¹æ›´æ”¹äº†é€šè¯æ¨¡å¼
                        this.isAudioOnly = message.audioOnly;
                        this.updateUIForCallType();
                        Utils.log(`å¯¹æ–¹å·²åˆ‡æ¢åˆ°${this.isAudioOnly ? 'çº¯è¯­éŸ³' : 'è§†é¢‘'}é€šè¯æ¨¡å¼`, Utils.logLevels.INFO);
                    }
                    break;

                case 'video-call-end':
                    if ((this.isCallActive || this.isCallPending) && this.currentPeerId === peerId) {
                        this.endCall();
                        UIManager.showNotification('å¯¹æ–¹ç»“æŸäº†é€šè¯', 'info');
                    }
                    break;
            }
        },

        // å¼€å§‹æœ¬åœ°æµ
        startLocalStream: async function() {
            try {
                // åªæœ‰åœ¨è¿˜æ²¡æœ‰æœ¬åœ°æµæ—¶æ‰è¯·æ±‚æƒé™
                if (!this.localStream) {
                    // æ˜¾ç¤ºè·å–åª’ä½“è®¾å¤‡æƒé™çš„æç¤º
                    UIManager.showNotification('æ­£åœ¨è¯·æ±‚åª’ä½“è®¾å¤‡æƒé™...', 'info');

                    // è·å–æƒé™
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        video: !this.isAudioOnly,
                        audio: true
                    });

                    // æ˜¾ç¤ºæœ¬åœ°è§†é¢‘ï¼ˆå¦‚æœä¸æ˜¯çº¯è¯­éŸ³é€šè¯ï¼‰
                    this.localVideo.srcObject = this.localStream;
                    this.localVideo.style.display = this.isAudioOnly ? 'none' : 'block';
                }

                // åˆ›å»ºWebRTCè¿æ¥
                this.setupPeerConnection();

                // æ˜¾ç¤ºè§†é¢‘é€šè¯ç•Œé¢
                document.getElementById('videoCallContainer').style.display = 'flex';

                // æ›´æ–°UIä»¥åŒ¹é…å½“å‰é€šè¯ç±»å‹
                this.updateUIForCallType();

                this.isCallActive = true;
                this.isCallPending = false;

                Utils.log(`${this.isAudioOnly ? 'è¯­éŸ³' : 'è§†é¢‘'}é€šè¯å·²å¼€å§‹`, Utils.logLevels.INFO);
            } catch (error) {
                Utils.log(`å¯åŠ¨é€šè¯å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.showNotification('æ— æ³•è®¿é—®åª’ä½“è®¾å¤‡', 'error');
                this.endCall();
            }
        },

        // åˆå§‹åŒ–è¯­éŸ³é€šè¯
        initiateAudioCall: function(peerId) {
            // è°ƒç”¨é€šç”¨çš„initiateCallæ–¹æ³•ï¼Œè®¾ç½®audioOnlyä¸ºtrue
            this.initiateCall(peerId, true);
        },
    };

    // æ¶ˆæ¯ç®¡ç†å™¨
    const MessageManager = {
        selectedFile: null,
        audioData: null,
        audioDuration: 0,

        // å‘é€æ¶ˆæ¯
        sendMessage: function() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            // æ£€æŸ¥æ˜¯å¦æœ‰é€‰æ‹©çš„èŠå¤©
            if (!ChatManager.currentChatId) {
                UIManager.showNotification('è¯·å…ˆé€‰æ‹©èŠå¤©å¯¹è±¡', 'warning');
                return;
            }

            // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤èŠ
            const isGroupChat = ChatManager.currentChatId.startsWith('group_');

            // å¦‚æœæ˜¯ç¾¤èŠï¼Œæ£€æŸ¥ç¾¤ç»„æ˜¯å¦å­˜åœ¨
            if (isGroupChat && !GroupManager.groups[ChatManager.currentChatId]) {
                UIManager.showNotification('ç¾¤èŠä¸å­˜åœ¨æˆ–æ‚¨å·²è¢«ç§»å‡º', 'error');
                return;
            }

            // å¦‚æœæ˜¯ç§èŠï¼Œæ£€æŸ¥è¿æ¥çŠ¶æ€
            if (!isGroupChat) {
                const isConnected = ConnectionManager.isConnectedTo(ChatManager.currentChatId);

                if (!isConnected && (message || this.selectedFile || this.audioData)) {
                    // è¿æ¥æœªå»ºç«‹ï¼Œæ˜¾ç¤ºé‡è¿æç¤º
                    UIManager.showReconnectPrompt(ChatManager.currentChatId, () => {
                        // é‡è¿æˆåŠŸåçš„å›è°ƒï¼Œé‡æ–°å°è¯•å‘é€æ¶ˆæ¯
                        this.sendMessage();
                    });
                    return;
                }
            }

            if (!message && !this.selectedFile && !this.audioData) {
                return;
            }

            // å‘é€è¯­éŸ³æ¶ˆæ¯
            if (this.audioData) {
                const audioMessage = {
                    type: 'audio',
                    data: this.audioData,
                    duration: this.audioDuration,
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                if (isGroupChat) {
                    // å‘é€åˆ°ç¾¤ç»„
                    GroupManager.broadcastToGroup(ChatManager.currentChatId, audioMessage);
                } else {
                    // å‘é€åˆ°ä¸ªäºº
                    Utils.sendInChunks(JSON.stringify(audioMessage),
                        (data) => ConnectionManager.connections[ChatManager.currentChatId].dataChannel.send(data));
                }

                // æ·»åŠ åˆ°èŠå¤©è®°å½•
                ChatManager.addMessage(ChatManager.currentChatId, audioMessage);

                // æ›´æ–°æœ€åæ¶ˆæ¯
                if (isGroupChat) {
                    GroupManager.updateGroupLastMessage(ChatManager.currentChatId, '[è¯­éŸ³]');
                } else {
                    UserManager.updateContactLastMessage(ChatManager.currentChatId, '[è¯­éŸ³]');
                }

                this.cancelAudioData();
            }

            // å‘é€æ–‡ä»¶æ¶ˆæ¯
            if (this.selectedFile) {
                // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶ID
                const fileId = `${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;

                const fileMessage = {
                    type: 'file',  // ç»Ÿä¸€ä½¿ç”¨fileç±»å‹
                    fileId: fileId,
                    fileName: this.selectedFile.name,
                    fileType: this.selectedFile.type,
                    fileSize: this.selectedFile.size,
                    data: this.selectedFile.data,  // è¿™é‡ŒåŒ…å«æ–‡ä»¶çš„base64æ•°æ®
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                if (isGroupChat) {
                    // å‘é€åˆ°ç¾¤ç»„
                    GroupManager.broadcastToGroup(ChatManager.currentChatId, fileMessage);
                } else {
                    // å‘é€åˆ°ä¸ªäºº
                    Utils.sendInChunks(JSON.stringify(fileMessage),
                        (data) => ConnectionManager.connections[ChatManager.currentChatId].dataChannel.send(data));
                }

                // æ·»åŠ åˆ°èŠå¤©è®°å½•
                ChatManager.addMessage(ChatManager.currentChatId, fileMessage);

                // æ›´æ–°æœ€åæ¶ˆæ¯
                let filePreview = '[æ–‡ä»¶]';
                if (this.selectedFile.type.startsWith('image/')) filePreview = '[å›¾ç‰‡]';
                if (this.selectedFile.type.startsWith('video/')) filePreview = '[è§†é¢‘]';
                if (this.selectedFile.type.startsWith('audio/')) filePreview = '[éŸ³é¢‘]';

                if (isGroupChat) {
                    GroupManager.updateGroupLastMessage(ChatManager.currentChatId, filePreview);
                } else {
                    UserManager.updateContactLastMessage(ChatManager.currentChatId, filePreview);
                }

                this.cancelFileData();
            }

            // å‘é€æ–‡æœ¬æ¶ˆæ¯
            if (message) {
                const urlRegex = /(https?:\/\/[^\s]+)/g;
                const messageObj = {
                    type: 'text',
                    content: message,
                    links: message.match(urlRegex) || [],
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                if (isGroupChat) {
                    // å‘é€åˆ°ç¾¤ç»„
                    GroupManager.broadcastToGroup(ChatManager.currentChatId, messageObj);
                } else {
                    // å‘é€åˆ°ä¸ªäºº
                    ConnectionManager.connections[ChatManager.currentChatId].dataChannel.send(JSON.stringify(messageObj));
                }

                // æ·»åŠ åˆ°èŠå¤©è®°å½•
                ChatManager.addMessage(ChatManager.currentChatId, messageObj);

                // æ›´æ–°æœ€åæ¶ˆæ¯
                if (isGroupChat) {
                    GroupManager.updateGroupLastMessage(ChatManager.currentChatId, message);
                } else {
                    UserManager.updateContactLastMessage(ChatManager.currentChatId, message);
                }

                input.value = '';
            }
        },

        // æ¸…ç©ºèŠå¤©è®°å½•
        clearChat: function() {
            if (!ChatManager.currentChatId) {
                UIManager.showNotification('è¯·å…ˆé€‰æ‹©èŠå¤©å¯¹è±¡', 'warning');
                return;
            }

            // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
            if (confirm('ç¡®å®šè¦æ¸…ç©ºèŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                // æ¸…ç©ºèŠå¤©
                if (ChatManager.clearChat(ChatManager.currentChatId)) {
                    // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯æç¤º
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'system-message';
                    systemMessage.textContent = 'å·²æ¸…ç©ºèŠå¤©è®°å½•';
                    systemMessage.style.textAlign = 'center';
                    systemMessage.style.padding = '10px';
                    systemMessage.style.color = '#666';
                    systemMessage.style.fontSize = '12px';
                    document.getElementById('chatBox').appendChild(systemMessage);

                    // é€šçŸ¥ç”¨æˆ·
                    UIManager.showNotification('èŠå¤©è®°å½•å·²æ¸…ç©º', 'info');

                    Utils.log('èŠå¤©è®°å½•å·²æ¸…ç©º', Utils.logLevels.INFO);
                }
            }
        },

        // æ˜¾ç¤ºæ¶ˆæ¯
        displayMessage: function (message, isSent) {
            const chatBox = document.getElementById('chatBox');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;

            if (typeof message === 'string') {
                // å¤„ç†çº¯æ–‡æœ¬æ¶ˆæ¯ï¼Œå°†æ¢è¡Œç¬¦è½¬æ¢ä¸º<br>æ ‡ç­¾
                messageDiv.innerHTML = this.formatMessageText(message);
            } else {
                switch (message.type) {
                    case 'audio':
                        const audioDiv = document.createElement('div');
                        audioDiv.className = 'voice-message';

                        // æ ¼å¼åŒ–éŸ³é¢‘æŒç»­æ—¶é—´
                        const formattedDuration = typeof message.duration === 'number'
                            ? Utils.formatTime(message.duration)
                            : message.duration;

                        audioDiv.innerHTML = `
                <button onclick="event.stopPropagation(); MediaManager.playAudio(this)" data-audio="${message.data}">
                    æ’­æ”¾
                </button>
                <div class="voice-wave">
                    ${Array(5).fill('<div class="wave-bar"></div>').join('')}
                </div>
                <span class="duration">${formattedDuration}</span>
            `;
                        messageDiv.appendChild(audioDiv);
                        break;

                    case 'file':
                        // å¤„ç†æ–‡ä»¶æ¶ˆæ¯
                        const fileDiv = document.createElement('div');
                        fileDiv.className = 'file-message';

                        // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶æ•°æ®
                        const fileData = message.data || '';

                        // æ ¹æ®æ–‡ä»¶ç±»å‹å†³å®šå±•ç¤ºæ–¹å¼
                        if (message.fileType && message.fileType.startsWith('image/')) {
                            // å›¾ç‰‡
                            fileDiv.innerHTML = `
                        ${fileData ? `<img src="${fileData}" class="file-preview-img" alt="${message.fileName}"
                             onclick="MessageManager.showFullImage('${fileData}')">` : '<div class="file-error">å›¾ç‰‡æ•°æ®ä¸¢å¤±</div>'}
                    `;
                        } else if (message.fileType && message.fileType.startsWith('video/')) {
                            // è§†é¢‘
                            fileDiv.innerHTML = `
                        ${fileData ? `<video controls class="file-preview-video">
                            <source src="${fileData}" type="${message.fileType}">
                            æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘é¢„è§ˆ
                        </video>` : '<div class="file-error">è§†é¢‘æ•°æ®ä¸¢å¤±</div>'}
                    `;
                        } else {
                            // å…¶ä»–æ–‡ä»¶ç±»å‹
                            const fileSize = MediaManager.formatFileSize(message.fileSize || 0);
                            const fileIcon = MediaManager.getFileIcon(message.fileType);

                            fileDiv.innerHTML = `
                        <div class="file-info">
                            <div class="file-icon">${fileIcon}</div>
                            <div class="file-details">
                                <div class="file-name">${message.fileName || 'æœªçŸ¥æ–‡ä»¶'}</div>
                                <div class="file-meta">
                                    <span class="file-size">${fileSize}</span>
                                    <span class="file-type">${message.fileType || 'æœªçŸ¥ç±»å‹'}</span>
                                </div>
                            </div>
                            ${fileData ? `<a href="${fileData}" download="${message.fileName}" class="download-btn">ä¸‹è½½</a>` :
                                '<span class="download-error">ä¸‹è½½å¤±è´¥</span>'}
                        </div>
                    `;
                        }

                        messageDiv.appendChild(fileDiv);
                        break;

                    // å…¼å®¹æ—§ç‰ˆæœ¬çš„imageç±»å‹ï¼Œå°†å…¶è§†ä¸ºfileç±»å‹å¤„ç†
                    case 'image':
                        const imgDiv = document.createElement('div');
                        imgDiv.className = 'file-message';

                        // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶æ•°æ®
                        const imgData = message.data || '';

                        imgDiv.innerHTML = `
                    ${imgData ? `<img src="${imgData}" class="file-preview-img" alt="${message.fileName || 'å›¾ç‰‡'}"
                         onclick="MessageManager.showFullImage('${imgData}')">` : '<div class="file-error">å›¾ç‰‡æ•°æ®ä¸¢å¤±</div>'}
                `;

                        messageDiv.appendChild(imgDiv);
                        break;

                    case 'text':
                        const textDiv = document.createElement('div');
                        // ä½¿ç”¨formatMessageTextæ–¹æ³•å¤„ç†æ–‡æœ¬å†…å®¹ï¼Œä¿ç•™æ¢è¡Œç¬¦
                        textDiv.innerHTML = this.formatMessageText(message.content);
                        messageDiv.appendChild(textDiv);

                        if (message.links && message.links.length > 0) {
                            message.links.forEach(async (link) => {
                                const linkPreview = await this.createLinkPreview(link);
                                messageDiv.appendChild(linkPreview);
                            });
                        }
                        break;

                    case 'system':
                        // å¤„ç†ç³»ç»Ÿæ¶ˆæ¯
                        const systemDiv = document.createElement('div');
                        systemDiv.className = 'system-message';
                        systemDiv.innerHTML = this.formatMessageText(message.content);
                        messageDiv.className = 'message system'; // è¦†ç›–åŸæ¥çš„sent/receivedç±»å
                        messageDiv.appendChild(systemDiv);
                        break;

                    default:
                        // æœªçŸ¥ç±»å‹æ¶ˆæ¯
                        messageDiv.textContent = JSON.stringify(message);

                }
            }

            // æ·»åŠ æ—¶é—´æˆ³å’Œå‘é€è€…åç§°
            const timestamp = document.createElement('div');
            timestamp.className = 'timestamp';

            // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤èŠæ¶ˆæ¯
            const isGroupChat = ChatManager.currentChatId && ChatManager.currentChatId.startsWith('group_');

            if (isGroupChat && !isSent) {
                const group = GroupManager.groups[ChatManager.currentChatId];

                // ä¼˜å…ˆä½¿ç”¨åŸå§‹å‘é€è€…ä¿¡æ¯
                const senderId = message.originalSender || message.sender;

                // è·å–å‘é€è€…æ˜µç§°
                let senderName = message.originalSenderName || message.senderName || 'æœªçŸ¥ç”¨æˆ·';

                // å¦‚æœåœ¨è”ç³»äººåˆ—è¡¨ä¸­æœ‰è¯¥ç”¨æˆ·ï¼Œä½¿ç”¨è”ç³»äººåç§°
                if (UserManager.contacts[senderId]) {
                    senderName = UserManager.contacts[senderId].name;
                }

                // æ£€æŸ¥å‘é€è€…æ˜¯å¦æ˜¯ç¾¤ä¸»
                if (group && senderId === group.owner) {
                    timestamp.textContent = `${senderName}(ç¾¤ä¸») Â· ${message.timestamp ?
                        new Date(message.timestamp).toLocaleTimeString() :
                        new Date().toLocaleTimeString()}`;
                } else {
                    timestamp.textContent = `${senderName} Â· ${message.timestamp ?
                        new Date(message.timestamp).toLocaleTimeString() :
                        new Date().toLocaleTimeString()}`;
                }

                // æ·»åŠ è½¬å‘æ ‡è¯†ï¼ˆå¦‚æœæœ‰è½¬å‘è€…ä¸”ä¸æ˜¯åŸå§‹å‘é€è€…ï¼‰
                if (message.sender !== message.originalSender && message.sender) {
                    const relayInfo = document.createElement('div');
                    relayInfo.className = 'relay-info';

                    // è·å–è½¬å‘è€…åç§°
                    let relayerName = 'æœªçŸ¥ç”¨æˆ·';
                    if (UserManager.contacts[message.sender]) {
                        relayerName = UserManager.contacts[message.sender].name;
                    } else if (message.sender === group.owner) {
                        relayerName = 'ç¾¤ä¸»';
                    }

                    relayInfo.textContent = `ç”± ${relayerName} è½¬å‘`;
                    timestamp.appendChild(relayInfo);
                }
            } else {
                // ç§èŠæ¶ˆæ¯æˆ–è‡ªå·±å‘é€çš„æ¶ˆæ¯ï¼Œåªæ˜¾ç¤ºæ—¶é—´
                timestamp.textContent = message.timestamp ?
                    new Date(message.timestamp).toLocaleTimeString() :
                    new Date().toLocaleTimeString();
            }

            messageDiv.appendChild(timestamp);

            chatBox.appendChild(messageDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
        },

        // æ˜¾ç¤ºå…¨å±å›¾ç‰‡
        showFullImage: function(src) {
            const modal = document.createElement('div');
            modal.style = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; align-items: center;
            justify-content: center; z-index: 1000; cursor: pointer;
        `;

            const fullImg = document.createElement('img');
            fullImg.src = src;
            fullImg.style = 'max-width: 90%; max-height: 90%; object-fit: contain;';

            modal.appendChild(fullImg);
            document.body.appendChild(modal);

            modal.onclick = () => document.body.removeChild(modal);
        },

        formatMessageText: function(text) {
            if (!text) return '';

            // è½¬ä¹‰HTMLç‰¹æ®Šå­—ç¬¦ï¼Œé˜²æ­¢XSSæ”»å‡»
            const escaped = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');

            // å°†æ¢è¡Œç¬¦è½¬æ¢ä¸º<br>æ ‡ç­¾
            return escaped.replace(/\n/g, '<br>');
        },

        // é“¾æ¥é¢„è§ˆ
        createLinkPreview: async function (url) {
            const preview = document.createElement('div');
            preview.className = 'link-preview';
            preview.innerHTML = `
            <div class="link-preview-loading">
                <span class="loading-spinner"></span> åŠ è½½é¢„è§ˆä¸­...
            </div>
        `;

            try {
                const previewData = await this.fetchLinkPreview(url);

                if (previewData) {
                    preview.innerHTML = `
                    <div class="link-preview-content">
                        ${previewData.image ?
                        `<img src="${previewData.image}"
                                class="link-preview-image"
                                onerror="this.style.display='none'"
                                alt="${previewData.title || 'é“¾æ¥é¢„è§ˆ'}">`
                        : ''}
                        <div class="link-preview-title">${previewData.title || url}</div>
                        <div class="link-preview-description">${previewData.description || 'æ— æè¿°'}</div>
                        <div class="link-preview-domain">
                            <img src="https://www.google.com/s2/favicons?domain=${previewData.domain}"
                                width="16" height="16" onerror="this.style.display='none'" alt="">
                            ${previewData.domain}
                        </div>
                    </div>
                `;
                } else {
                    preview.innerHTML = `
                    <div class="link-preview-content">
                        <div class="link-preview-title">${url}</div>
                        <div class="preview-error">æ— æ³•åŠ è½½é¢„è§ˆ</div>
                    </div>
                `;
                }
            } catch (error) {
                preview.innerHTML = `
                <div class="link-preview-content">
                    <div class="link-preview-title">${url}</div>
                    <div class="preview-error">é¢„è§ˆåŠ è½½å¤±è´¥</div>
                </div>
            `;
            }

            preview.onclick = () => window.open(url, '_blank');
            return preview;
        },

        // è·å–é“¾æ¥é¢„è§ˆ
        fetchLinkPreview: async function (url) {
            try {
                // ä½¿ç”¨ç¬¬ä¸‰æ–¹APIè·å–é“¾æ¥é¢„è§ˆï¼ˆè€ƒè™‘ä¸­å›½ç½‘ç»œæƒ…å†µï¼Œå¯èƒ½éœ€è¦æ›¿æ¢ä¸ºå›½å†…å¯ç”¨çš„æœåŠ¡ï¼‰
                // åœ¨ç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨è‡ªå·±çš„åç«¯æœåŠ¡æ¥ä»£ç†è¯·æ±‚ï¼Œé¿å…APIæœåŠ¡çš„é™åˆ¶
                const proxyUrl = 'https://api.allorigins.win/raw?url=';
                const response = await fetch(`${proxyUrl}${encodeURIComponent(url)}`, {
                    method: 'GET',
                    headers: {'Content-Type': 'text/html'},
                    mode: 'cors',
                    cache: 'force-cache'
                });

                if (!response.ok) throw new Error('æ— æ³•è·å–é“¾æ¥å†…å®¹');

                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // æå–Open Graphæ•°æ®
                const getMetaContent = (name) => {
                    const element = doc.querySelector(`meta[property="og:${name}"], meta[name="${name}"], meta[name="og:${name}"]`);
                    return element ? element.getAttribute('content') : null;
                };

                const title = getMetaContent('title') || doc.title || '';
                const description = getMetaContent('description') || '';
                const image = getMetaContent('image') || '';
                const domain = new URL(url).hostname;

                return {title, description, image, domain};
            } catch (error) {
                Utils.log(`é“¾æ¥é¢„è§ˆè·å–å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);

                // è¿”å›åŸºæœ¬ä¿¡æ¯
                try {
                    const domain = new URL(url).hostname;
                    return {
                        title: url,
                        description: '',
                        image: null,
                        domain: domain
                    };
                } catch (e) {
                    return null;
                }
            }
        },

        // å–æ¶ˆæ–‡ä»¶æ•°æ®
        cancelFileData: function () {
            this.selectedFile = null;
            document.getElementById('filePreviewContainer').innerHTML = '';
            document.getElementById('fileInput').value = '';
        },

        // å–æ¶ˆéŸ³é¢‘æ•°æ®
        cancelAudioData: function () {
            this.audioData = null;
            this.audioDuration = 0;
            document.getElementById('audioPreviewContainer').innerHTML = '';

            // ç¡®ä¿é‡Šæ”¾åª’ä½“èµ„æº
            MediaManager.releaseAudioResources();
        }
    };

    // èŠå¤©ç®¡ç†å™¨
    const ChatManager = {
        currentChatId: null,
        chats: {},

        init: async function() {
            // åˆå§‹åŒ–è”ç³»äººåˆ—è¡¨
            await this.loadChats();

            // è®¾ç½®æ–°å»ºèŠå¤©æŒ‰é’®äº‹ä»¶
            document.getElementById('newChatBtn').addEventListener('click', () => {
                document.getElementById('newChatForm').style.display = 'block';
            });

            // è®¾ç½®æ¸…ç©ºè”ç³»äººåˆ—è¡¨æŒ‰é’®äº‹ä»¶
            document.getElementById('clearContactsBtn').addEventListener('click', () => {
                UserManager.clearAllContacts();
            });

            document.getElementById('cancelNewChatBtn').addEventListener('click', () => {
                document.getElementById('newChatForm').style.display = 'none';
                document.getElementById('peerIdInput').value = '';
                document.getElementById('peerNameInput').value = '';
            });

            document.getElementById('confirmNewChatBtn').addEventListener('click', () => {
                const peerId = document.getElementById('peerIdInput').value.trim();
                const peerName = document.getElementById('peerNameInput').value.trim() || `ç”¨æˆ·${peerId.substring(0, 4)}`;

                if (!peerId) {
                    UIManager.showNotification('è¯·è¾“å…¥å¯¹æ–¹ID', 'warning');
                    return;
                }

                if (UserManager.addContact(peerId, peerName)) {
                    document.getElementById('newChatForm').style.display = 'none';
                    document.getElementById('peerIdInput').value = '';
                    document.getElementById('peerNameInput').value = '';

                    // åˆ‡æ¢åˆ°è”ç³»äººåˆ—è¡¨
                    document.querySelector('.connection-tab[data-tab="chats"]').click();
                }
            });

            // è®¾ç½®é€‰é¡¹å¡åˆ‡æ¢
            document.querySelectorAll('.connection-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.connection-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    const tabName = tab.getAttribute('data-tab');
                    document.querySelectorAll('.connection-panel').forEach(panel => {
                        panel.classList.remove('active');
                    });
                    document.getElementById(`${tabName}Panel`).classList.add('active');
                });
            });
        },

        loadChats: async function() {
            try {
                await DBManager.init();
                const chatItems = await DBManager.getAllItems('chats');
                this.chats = {};

                if (chatItems && chatItems.length > 0) {
                    chatItems.forEach(item => {
                        this.chats[item.id] = item.messages || [];
                    });
                }
            } catch (error) {
                Utils.log(`åŠ è½½èŠå¤©è®°å½•å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                // å°è¯•ä»localStorageåŠ è½½
                this.loadChatsFromLocalStorage();
            }
        },

        saveChats: async function() {
            if (this.currentChatId) {
                try {
                    await DBManager.setItem('chats', {
                        id: this.currentChatId,
                        messages: this.chats[this.currentChatId] || []
                    });

                } catch (error) {
                    Utils.log(`ä¿å­˜èŠå¤©è®°å½•å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                }
            }
        },

        renderChatList: function() {
            const chatList = document.getElementById('chatList');
            chatList.innerHTML = '';

            const sortedContacts = Object.values(UserManager.contacts).sort((a, b) => {
                return new Date(b.lastTime) - new Date(a.lastTime);
            });

            if (sortedContacts.length === 0) {
                chatList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">æš‚æ— èŠå¤©ï¼Œç‚¹å‡»"æ·»åŠ æ–°èŠå¤©"å¼€å§‹</div>';
                return;
            }

            sortedContacts.forEach(contact => {
                const chatItem = document.createElement('div');
                chatItem.className = `chat-item ${contact.id === this.currentChatId ? 'active' : ''}`;
                chatItem.setAttribute('data-id', contact.id);

                const lastTime = new Date(contact.lastTime);
                const formattedTime = Utils.formatDate(lastTime);

                chatItem.innerHTML = `
            <div class="chat-avatar">${contact.name.charAt(0)}</div>
            <div class="chat-info">
                <div class="chat-name">${contact.name}</div>
                <div class="chat-preview">${contact.lastMessage || 'æš‚æ— æ¶ˆæ¯'}</div>
            </div>
            <div class="chat-meta">
                <div class="chat-time">${formattedTime}</div>
                ${contact.unread ? `<div class="chat-badge">${contact.unread > 99 ? '99+' : contact.unread}</div>` : ''}
            </div>
            <div class="delete-btn" style="display: none;">åˆ é™¤</div>
        `;

                chatItem.addEventListener('click', (e) => {
                    // å¦‚æœç‚¹å‡»çš„æ˜¯åˆ é™¤æŒ‰é’®ï¼Œä¸æ‰“å¼€èŠå¤©
                    if (e.target.classList.contains('delete-btn')) {
                        e.stopPropagation();
                        this.deleteChat(contact.id);
                        return;
                    }
                    this.openChat(contact.id);
                });

                // æ·»åŠ é¼ æ ‡æ‚¬æµ®äº‹ä»¶
                chatItem.addEventListener('mouseenter', () => {
                    chatItem.querySelector('.delete-btn').style.display = 'block';
                });

                chatItem.addEventListener('mouseleave', () => {
                    chatItem.querySelector('.delete-btn').style.display = 'none';
                });

                chatList.appendChild(chatItem);
            });
        },

        // æ·»åŠ åˆ é™¤èŠå¤©è®°å½•çš„æ–¹æ³•
        deleteChat: function(chatId) {
            // ç¡®è®¤å¯¹è¯æ¡†
            if (confirm('ç¡®å®šè¦åˆ é™¤æ­¤èŠå¤©å—ï¼Ÿæ­¤æ“ä½œå°†æ¸…ç©ºèŠå¤©è®°å½•ä¸”ä¸å¯æ’¤é”€ã€‚')) {
                // æ¸…ç©ºèŠå¤©è®°å½•
                this.clearChat(chatId);

                // ä»è”ç³»äººåˆ—è¡¨ä¸­ç§»é™¤
                UserManager.removeContact(chatId);

                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰èŠå¤©ï¼Œé‡ç½®èŠå¤©ç•Œé¢
                if (chatId === this.currentChatId) {
                    this.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = 'æœªé€‰æ‹©èŠå¤©';
                    document.getElementById('chatBox').innerHTML = '';

                    // ç¦ç”¨èŠå¤©ç•Œé¢
                    UIManager.enableChatInterface(false);
                }

                // æ›´æ–°è”ç³»äººåˆ—è¡¨
                this.renderChatList();

                // æ˜¾ç¤ºé€šçŸ¥
                UIManager.showNotification('èŠå¤©å·²åˆ é™¤', 'info');
            }
        },

        openChat: function(chatId) {
            // ä¿å­˜ä¹‹å‰çš„èŠå¤©è®°å½•
            if (this.currentChatId) {
                this.saveCurrentChat();
            }

            this.currentChatId = chatId;

            // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤èŠ
            if (chatId.startsWith('group_')) {
                // å¦‚æœæ˜¯ç¾¤èŠï¼Œäº¤ç»™ç¾¤èŠç®¡ç†å™¨å¤„ç†
                GroupManager.openGroup(chatId);
                return;
            }

            // ä¸ªäººèŠå¤©å¤„ç†é€»è¾‘
            UserManager.clearUnread(chatId);

            // æ›´æ–°UI
            document.querySelectorAll('.chat-item').forEach(item => {
                item.classList.toggle('active', item.getAttribute('data-id') === chatId);
            });

            // è®¾ç½®èŠå¤©æ ‡é¢˜
            const contact = UserManager.contacts[chatId];
            if (contact) {
                document.getElementById('currentChatTitle').textContent = contact.name;
            }

            // éšè—ç¾¤èŠæˆå‘˜ç®¡ç†æŒ‰é’®
            document.getElementById('chatHeaderActions').style.display = 'none';

            // åŠ è½½èŠå¤©è®°å½•
            this.loadChatHistory(chatId);

            // åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šåˆ‡æ¢åˆ°èŠå¤©ç•Œé¢
            if (window.innerWidth <= 768) {
                document.querySelector('.container').classList.add('connected-mode');
            }

            // å¯ç”¨èŠå¤©è¾“å…¥
            UIManager.enableChatInterface(true);

            // æ£€æŸ¥è¿æ¥çŠ¶æ€
            const isConnected = ConnectionManager.isConnectedTo(chatId);

            // æ›´æ–°è§†é¢‘é€šè¯æŒ‰é’®çŠ¶æ€
            document.getElementById('videoCallButton').disabled = !isConnected;

            // å¦‚æœè¿æ¥æœªå»ºç«‹ï¼Œæ·»åŠ ç³»ç»Ÿæ¶ˆæ¯æç¤º
            if (!isConnected) {
                const chatBox = document.getElementById('chatBox');
                const systemMessage = document.createElement('div');
                systemMessage.className = 'system-message';
                systemMessage.textContent = 'è¿æ¥æœªå»ºç«‹ï¼Œå‘é€æ¶ˆæ¯æ—¶å°†æç¤ºé‡æ–°è¿æ¥';
                chatBox.appendChild(systemMessage);
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            // èšç„¦è¾“å…¥æ¡†
            setTimeout(() => document.getElementById('messageInput').focus(), 100);
        },

        loadChatHistory: function(chatId) {
            const chatBox = document.getElementById('chatBox');
            chatBox.innerHTML = '';

            if (!this.chats[chatId]) {
                this.chats[chatId] = [];
                return;
            }

            this.chats[chatId].forEach(msg => {
                MessageManager.displayMessage(msg, msg.sender === UserManager.userId);
            });

            // æ»šåŠ¨åˆ°åº•éƒ¨
            chatBox.scrollTop = chatBox.scrollHeight;
        },

        saveCurrentChat: function() {
            if (this.currentChatId) {
                this.saveChats();
            }
        },

        addMessage: async function(chatId, message) {
            if (!this.chats[chatId]) {
                this.chats[chatId] = [];
            }

            this.chats[chatId].push(message);

            // å¦‚æœæ˜¯å½“å‰èŠå¤©ï¼Œæ˜¾ç¤ºæ¶ˆæ¯
            if (chatId === this.currentChatId) {
                MessageManager.displayMessage(message, message.sender === UserManager.userId);
                document.getElementById('chatBox').scrollTop = document.getElementById('chatBox').scrollHeight;
            } else {
                // æ›´æ–°æœªè¯»æ¶ˆæ¯è®¡æ•°
                if (chatId.startsWith('group_')) {
                    GroupManager.updateGroupLastMessage(
                        chatId,
                        message.type === 'text' ? message.content : '[åª’ä½“æ¶ˆæ¯]',
                        true
                    );
                } else {
                    UserManager.updateContactLastMessage(
                        chatId,
                        message.type === 'text' ? message.content : '[åª’ä½“æ¶ˆæ¯]',
                        true
                    );
                }
            }

            try {
                // ä¿å­˜åˆ°IndexedDB
                await DBManager.setItem('chats', {
                    id: chatId,
                    messages: this.chats[chatId]
                });
            } catch (error) {
                Utils.log(`ä¿å­˜æ¶ˆæ¯å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
            }
        },

        clearChat: async function(chatId) {
            if (chatId) {
                this.chats[chatId] = [];

                try {
                    await DBManager.setItem('chats', {
                        id: chatId,
                        messages: []
                    });

                    if (chatId === this.currentChatId) {
                        document.getElementById('chatBox').innerHTML = '';
                    }

                    return true;
                } catch (error) {
                    Utils.log(`æ¸…ç©ºèŠå¤©è®°å½•å¤±è´¥: ${error}`, Utils.logLevels.ERROR);

                    if (chatId === this.currentChatId) {
                        document.getElementById('chatBox').innerHTML = '';
                    }

                    return true;
                }
            }
            return false;
        },

        // æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•
        clearAllChats: async function() {
            // ç¡®è®¤å¯¹è¯æ¡†
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                return;
            }

            // æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•
            this.chats = {};

            try {
                await DBManager.clearStore('chats');

                // å¦‚æœå½“å‰æœ‰æ‰“å¼€çš„èŠå¤©ï¼Œæ¸…ç©ºèŠå¤©æ¡†
                if (this.currentChatId) {
                    document.getElementById('chatBox').innerHTML = '';

                    // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯æç¤º
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'system-message';
                    systemMessage.textContent = 'æ‰€æœ‰èŠå¤©è®°å½•å·²æ¸…ç©º';
                    document.getElementById('chatBox').appendChild(systemMessage);
                }

                // æ›´æ–°æ‰€æœ‰è”ç³»äººçš„æœ€åæ¶ˆæ¯
                for (const contactId in UserManager.contacts) {
                    UserManager.contacts[contactId].lastMessage = '';
                    UserManager.contacts[contactId].unread = 0;
                }
                UserManager.saveContacts();

                // æ›´æ–°ç¾¤ç»„çš„æœ€åæ¶ˆæ¯
                for (const groupId in GroupManager.groups) {
                    GroupManager.groups[groupId].lastMessage = '';
                    GroupManager.groups[groupId].unread = 0;
                }
                GroupManager.saveGroups();

                // æ›´æ–°è”ç³»äººåˆ—è¡¨
                this.renderChatList();

                // é€šçŸ¥ç”¨æˆ·
                UIManager.showNotification('æ‰€æœ‰èŠå¤©è®°å½•å·²æ¸…ç©º', 'info');
                Utils.log('æ‰€æœ‰èŠå¤©è®°å½•å·²æ¸…ç©º', Utils.logLevels.INFO);

                return true;
            } catch (error) {
                Utils.log(`æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•å¤±è´¥: ${error}`, Utils.logLevels.ERROR);

                // å¦‚æœå½“å‰æœ‰æ‰“å¼€çš„èŠå¤©ï¼Œæ¸…ç©ºèŠå¤©æ¡†
                if (this.currentChatId) {
                    document.getElementById('chatBox').innerHTML = '';

                    // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯æç¤º
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'system-message';
                    systemMessage.textContent = 'æ‰€æœ‰èŠå¤©è®°å½•å·²æ¸…ç©º';
                    document.getElementById('chatBox').appendChild(systemMessage);
                }

                // æ›´æ–°è”ç³»äººåˆ—è¡¨
                this.renderChatList();

                return true;
            }
        }
    };

    // ç”¨æˆ·ç®¡ç†å™¨
    const UserManager = {
        userId: null,
        userName: 'æˆ‘',
        contacts: {},

        init: async function() {
            try {
                // ç¡®ä¿æ•°æ®åº“åˆå§‹åŒ–
                await DBManager.init();

                // è·å–æˆ–ç”Ÿæˆç”¨æˆ·ID
                const userData = await DBManager.getItem('user', 'current');
                if (userData) {
                    this.userId = userData.userId;
                } else {
                    // ç”Ÿæˆæ–°ç”¨æˆ·ID
                    this.userId = Utils.generateId();
                    await DBManager.setItem('user', {
                        id: 'current',
                        userId: this.userId
                    });
                }

                // æ˜¾ç¤ºç”¨æˆ·ID
                document.getElementById('userIdValue').textContent = this.userId;
                this.userName = this.userId;

                // è®¾ç½®å¤åˆ¶IDæŒ‰é’®
                document.getElementById('copyIdBtn').addEventListener('click', () => {
                    navigator.clipboard.writeText(this.userId)
                        .then(() => UIManager.showNotification('IDå·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success'))
                        .catch(() => UIManager.showNotification('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error'));
                });

                // åŠ è½½è”ç³»äºº
                await this.loadContacts();
            } catch (error) {
                Utils.log(`ç”¨æˆ·åˆå§‹åŒ–å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                // å›é€€æ–¹æ¡ˆ
                this.userId = Utils.generateId();
                document.getElementById('userIdValue').textContent = this.userId;
                this.loadContactsFromLocalStorage();
            }
        },

        loadContacts: async function() {
            try {
                const contacts = await DBManager.getAllItems('contacts');
                this.contacts = {};

                if (contacts && contacts.length > 0) {
                    contacts.forEach(contact => {
                        this.contacts[contact.id] = contact;
                    });
                    ChatManager.renderChatList();
                }
            } catch (error) {
                Utils.log(`åŠ è½½è”ç³»äººå¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                this.contacts = {};
                // å°è¯•ä»localStorageåŠ è½½
                this.loadContactsFromLocalStorage();
            }
        },

        saveContacts: async function() {
            try {
                for (const id in this.contacts) {
                    await DBManager.setItem('contacts', this.contacts[id]);
                }
            } catch (error) {
                Utils.log(`ä¿å­˜è”ç³»äººå¤±è´¥: ${error}`, Utils.logLevels.ERROR);
            }
        },

        addContact: async function(id, name) {
            if (id === this.userId) {
                UIManager.showNotification('ä¸èƒ½æ·»åŠ è‡ªå·±ä¸ºè”ç³»äºº', 'error');
                return false;
            }

            if (this.contacts[id]) {
                UIManager.showNotification('è¯¥è”ç³»äººå·²å­˜åœ¨', 'warning');
                return false;
            }

            const contact = {
                id: id,
                name: name || `ç”¨æˆ·${id.substring(0, 4)}`,
                lastMessage: '',
                lastTime: new Date().toISOString(),
                unread: 0
            };

            this.contacts[id] = contact;

            try {
                await DBManager.setItem('contacts', contact);
                ChatManager.renderChatList();
                return true;
            } catch (error) {
                Utils.log(`æ·»åŠ è”ç³»äººå¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                // å¤‡ä»½ç­–ç•¥ï¼šä¿å­˜åˆ°localStorage
                this.saveContacts();
                ChatManager.renderChatList();
                return true;
            }
        },

        removeContact: async function(id) {
            if (this.contacts[id]) {
                delete this.contacts[id];

                try {
                    await DBManager.removeItem('contacts', id);
                    ChatManager.renderChatList();
                    return true;
                } catch (error) {
                    Utils.log(`åˆ é™¤è”ç³»äººå¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                    // å¤‡ä»½ç­–ç•¥ï¼šä¿å­˜åˆ°localStorage
                    this.saveContacts();
                    ChatManager.renderChatList();
                    return true;
                }
            }
            return false;
        },

        updateContactLastMessage: async function(id, message, isUnread = false) {
            if (this.contacts[id]) {
                this.contacts[id].lastMessage = message;
                this.contacts[id].lastTime = new Date().toISOString();
                if (isUnread) {
                    this.contacts[id].unread = (this.contacts[id].unread || 0) + 1;
                }

                try {
                    await DBManager.setItem('contacts', this.contacts[id]);
                    ChatManager.renderChatList();
                } catch (error) {
                    Utils.log(`æ›´æ–°è”ç³»äººæœ€åæ¶ˆæ¯å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                    // å¤‡ä»½ç­–ç•¥ï¼šä¿å­˜åˆ°localStorage
                    this.saveContacts();
                    ChatManager.renderChatList();
                }
            }
        },

        clearUnread: async function(id) {
            if (this.contacts[id]) {
                this.contacts[id].unread = 0;

                try {
                    await DBManager.setItem('contacts', this.contacts[id]);
                    ChatManager.renderChatList();
                } catch (error) {
                    Utils.log(`æ¸…é™¤æœªè¯»æ•°å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                    // å¤‡ä»½ç­–ç•¥ï¼šä¿å­˜åˆ°localStorage
                    this.saveContacts();
                    ChatManager.renderChatList();
                }
            }
        },

        // æ¸…ç©ºæ‰€æœ‰è”ç³»äººåˆ—è¡¨
        clearAllContacts: async function() {
            // ç¡®è®¤å¯¹è¯æ¡†
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰èŠå¤©å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                return false;
            }

            // å¤‡ä»½å½“å‰è”ç³»äººIDï¼Œç”¨äºåç»­å…³é—­è¿æ¥
            const contactIds = Object.keys(this.contacts);

            // æ¸…ç©ºè”ç³»äººå¯¹è±¡
            this.contacts = {};

            try {
                // æ¸…ç©ºIndexedDBä¸­çš„è”ç³»äºº
                await DBManager.clearStore('contacts');

                // å…³é—­æ‰€æœ‰è¿æ¥
                contactIds.forEach(peerId => {
                    if (ConnectionManager.connections[peerId]) {
                        ConnectionManager.close(peerId);
                    }
                });

                // æ›´æ–°UI
                ChatManager.renderChatList();

                // æ¸…ç©ºå½“å‰èŠå¤©
                if (ChatManager.currentChatId) {
                    ChatManager.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = 'æœªé€‰æ‹©èŠå¤©';
                    document.getElementById('chatBox').innerHTML = '';

                    // ç¦ç”¨èŠå¤©ç•Œé¢
                    UIManager.enableChatInterface(false);
                }

                // é€šçŸ¥ç”¨æˆ·
                UIManager.showNotification('æ‰€æœ‰è”ç³»äººå·²æ¸…ç©º', 'info');
                Utils.log('æ‰€æœ‰è”ç³»äººå·²æ¸…ç©º', Utils.logLevels.INFO);

                return true;
            } catch (error) {
                Utils.log(`æ¸…ç©ºè”ç³»äººå¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                return true;
            }
        }
    };

    // ç¾¤èŠç®¡ç†å™¨
    const GroupManager = {
        groups: {},
        currentGroupId: null,

        init: async function() {
            // ä»æ•°æ®åº“åŠ è½½ç¾¤èŠ
            await this.loadGroups();

            // è®¾ç½®æ–°å»ºç¾¤èŠæŒ‰é’®äº‹ä»¶
            document.getElementById('newGroupBtn').addEventListener('click', () => {
                document.getElementById('newGroupForm').style.display = 'block';
            });

            document.getElementById('cancelNewGroupBtn').addEventListener('click', () => {
                document.getElementById('newGroupForm').style.display = 'none';
                document.getElementById('groupNameInput').value = '';
            });

            document.getElementById('confirmNewGroupBtn').addEventListener('click', () => {
                const groupName = document.getElementById('groupNameInput').value.trim();

                if (!groupName) {
                    UIManager.showNotification('è¯·è¾“å…¥ç¾¤èŠåç§°', 'warning');
                    return;
                }

                this.createGroup(groupName);
                document.getElementById('newGroupForm').style.display = 'none';
                document.getElementById('groupNameInput').value = '';
            });

            // è®¾ç½®æˆå‘˜ç®¡ç†
            document.getElementById('manageMembersBtn').addEventListener('click', () => {
                this.showMemberManagement();
            });

            document.getElementById('addMemberBtn').addEventListener('click', () => {
                const contactId = document.getElementById('contactsDropdown').value;
                if (contactId) {
                    this.addMemberToGroup(this.currentGroupId, contactId);
                }
            });

            // å…³é—­æ¨¡æ€çª—å£
            document.querySelector('.close-modal').addEventListener('click', () => {
                document.getElementById('memberManagementModal').style.display = 'none';
            });

            // ç‚¹å‡»æ¨¡æ€çª—å£å¤–éƒ¨å…³é—­
            window.addEventListener('click', (event) => {
                const modal = document.getElementById('memberManagementModal');
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        },

        loadGroups: async function() {
            try {
                await DBManager.init();
                const groupItems = await DBManager.getAllItems('groups');
                this.groups = {};

                if (groupItems && groupItems.length > 0) {
                    groupItems.forEach(group => {
                        this.groups[group.id] = group;
                    });
                    this.renderGroupList();
                }
            } catch (error) {
                Utils.log(`åŠ è½½ç¾¤èŠå¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                // å°è¯•ä»localStorageåŠ è½½
                this.loadGroupsFromLocalStorage();
            }
        },

        saveGroups: async function() {
            try {
                for (const id in this.groups) {
                    await DBManager.setItem('groups', this.groups[id]);
                }
            } catch (error) {
                Utils.log(`ä¿å­˜ç¾¤èŠå¤±è´¥: ${error}`, Utils.logLevels.ERROR);
            }
        },

        createGroup: async function(name) {
            const groupId = 'group_' + Utils.generateId();
            const group = {
                id: groupId,
                name: name,
                owner: UserManager.userId,
                members: [UserManager.userId],
                lastMessage: '',
                lastTime: new Date().toISOString(),
                unread: 0
            };

            this.groups[groupId] = group;

            try {
                await DBManager.setItem('groups', group);
                this.renderGroupList();
                UIManager.showNotification(`ç¾¤èŠ"${name}"å·²åˆ›å»º`, 'success');
                return groupId;
            } catch (error) {
                Utils.log(`åˆ›å»ºç¾¤èŠå¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                // å¤‡ä»½åˆ°localStorage
                this.saveGroups();
                this.renderGroupList();
                UIManager.showNotification(`ç¾¤èŠ"${name}"å·²åˆ›å»º`, 'success');
                return groupId;
            }
        },

        renderChatList: function() {
            const chatList = document.getElementById('chatList');
            chatList.innerHTML = '';

            const sortedContacts = Object.values(UserManager.contacts).sort((a, b) => {
                return new Date(b.lastTime) - new Date(a.lastTime);
            });

            if (sortedContacts.length === 0) {
                chatList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">æš‚æ— èŠå¤©ï¼Œç‚¹å‡»"æ·»åŠ æ–°èŠå¤©"å¼€å§‹</div>';
                return;
            }

            sortedContacts.forEach(contact => {
                const chatItem = document.createElement('div');
                chatItem.className = `chat-item ${contact.id === this.currentChatId ? 'active' : ''}`;
                chatItem.setAttribute('data-id', contact.id);

                const lastTime = new Date(contact.lastTime);
                const formattedTime = Utils.formatDate(lastTime);

                chatItem.innerHTML = `
            <div class="chat-avatar">${contact.name.charAt(0)}</div>
            <div class="chat-info">
                <div class="chat-name">${contact.name}</div>
                <div class="chat-preview">${contact.lastMessage || 'æš‚æ— æ¶ˆæ¯'}</div>
            </div>
            <div class="chat-meta">
                <div class="chat-time">${formattedTime}</div>
                ${contact.unread ? `<div class="chat-badge">${contact.unread > 99 ? '99+' : contact.unread}</div>` : ''}
            </div>
            <div class="delete-btn" style="display: none;">åˆ é™¤</div>
        `;

                chatItem.addEventListener('click', (e) => {
                    // å¦‚æœç‚¹å‡»çš„æ˜¯åˆ é™¤æŒ‰é’®ï¼Œä¸æ‰“å¼€èŠå¤©
                    if (e.target.classList.contains('delete-btn')) {
                        e.stopPropagation();
                        this.deleteChat(contact.id);
                        return;
                    }
                    this.openChat(contact.id);
                });

                // æ·»åŠ é¼ æ ‡æ‚¬æµ®äº‹ä»¶
                chatItem.addEventListener('mouseenter', () => {
                    chatItem.querySelector('.delete-btn').style.display = 'block';
                });

                chatItem.addEventListener('mouseleave', () => {
                    chatItem.querySelector('.delete-btn').style.display = 'none';
                });

                chatList.appendChild(chatItem);
            });
        },

        deleteChat: function(chatId) {
            // ç¡®è®¤å¯¹è¯æ¡†
            if (confirm('ç¡®å®šè¦åˆ é™¤æ­¤èŠå¤©å—ï¼Ÿæ­¤æ“ä½œå°†æ¸…ç©ºèŠå¤©è®°å½•ä¸”ä¸å¯æ’¤é”€ã€‚')) {
                // æ¸…ç©ºèŠå¤©è®°å½•
                this.clearChat(chatId);

                // ä»è”ç³»äººåˆ—è¡¨ä¸­ç§»é™¤
                UserManager.removeContact(chatId);

                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰èŠå¤©ï¼Œé‡ç½®èŠå¤©ç•Œé¢
                if (chatId === this.currentChatId) {
                    this.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = 'æœªé€‰æ‹©èŠå¤©';
                    document.getElementById('chatBox').innerHTML = '';

                    // ç¦ç”¨èŠå¤©ç•Œé¢
                    UIManager.enableChatInterface(false);
                }

                // æ›´æ–°è”ç³»äººåˆ—è¡¨
                this.renderChatList();

                // æ˜¾ç¤ºé€šçŸ¥
                UIManager.showNotification('èŠå¤©å·²åˆ é™¤', 'info');
            }
        },

        openGroup: function(groupId) {
            // ä¿å­˜ä¹‹å‰çš„èŠå¤©è®°å½•
            if (ChatManager.currentChatId) {
                ChatManager.saveCurrentChat();
            }

            ChatManager.currentChatId = groupId;
            this.currentGroupId = groupId;
            this.clearUnread(groupId);

            // æ›´æ–°UI
            document.querySelectorAll('.group-item').forEach(item => {
                item.classList.toggle('active', item.getAttribute('data-id') === groupId);
            });

            // è®¾ç½®èŠå¤©æ ‡é¢˜
            const group = this.groups[groupId];
            if (group) {
                document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}äºº)`;

                // æ˜¾ç¤ºæˆå‘˜ç®¡ç†æŒ‰é’®ï¼ˆä»…ç¾¤ä¸»å¯è§ï¼‰
                const chatHeaderActions = document.getElementById('chatHeaderActions');
                if (group.owner === UserManager.userId) {
                    chatHeaderActions.style.display = 'flex';
                } else {
                    chatHeaderActions.style.display = 'none';
                }
            }

            // åŠ è½½èŠå¤©è®°å½•
            ChatManager.loadChatHistory(groupId);

            // åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šåˆ‡æ¢åˆ°èŠå¤©ç•Œé¢
            if (window.innerWidth <= 768) {
                document.querySelector('.container').classList.add('connected-mode');
            }

            // å¯ç”¨èŠå¤©è¾“å…¥
            UIManager.enableChatInterface(true);

            // èšç„¦è¾“å…¥æ¡†
            setTimeout(() => document.getElementById('messageInput').focus(), 100);
        },

        addMemberToGroup: async function(groupId, memberId) {
            const group = this.groups[groupId];
            if (!group) return false;

            // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯æˆå‘˜
            if (group.members.includes(memberId)) {
                UIManager.showNotification('è¯¥ç”¨æˆ·å·²åœ¨ç¾¤èŠä¸­', 'warning');
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥
            if (!ConnectionManager.isConnectedTo(memberId)) {
                UIManager.showNotification('è¯·å…ˆä¸è¯¥ç”¨æˆ·å»ºç«‹è¿æ¥', 'warning');
                return false;
            }

            // æ·»åŠ æˆå‘˜
            group.members.push(memberId);

            try {
                await DBManager.setItem('groups', group);

                // æ›´æ–°æˆå‘˜ç®¡ç†ç•Œé¢
                this.showMemberManagement();

                // æ›´æ–°ç¾¤èŠæ ‡é¢˜
                if (this.currentGroupId === groupId) {
                    document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}äºº)`;
                }

                // å‘é€ç³»ç»Ÿæ¶ˆæ¯
                const systemMessage = {
                    type: 'system',
                    content: `${UserManager.contacts[memberId]?.name || memberId} å·²åŠ å…¥ç¾¤èŠ`,
                    timestamp: new Date().toISOString()
                };

                // æ·»åŠ åˆ°èŠå¤©è®°å½•
                ChatManager.addMessage(groupId, systemMessage);

                // é€šçŸ¥æ–°æˆå‘˜å·²åŠ å…¥ç¾¤èŠ
                const groupInfo = {
                    type: 'group-invite',
                    groupId: groupId,
                    groupName: group.name,
                    members: group.members,
                    owner: group.owner,
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                ConnectionManager.sendTo(memberId, groupInfo);

                // é€šçŸ¥å…¶ä»–æˆå‘˜æœ‰æ–°æˆå‘˜åŠ å…¥
                const memberUpdate = {
                    type: 'group-member-added',
                    groupId: groupId,
                    newMemberId: memberId,
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                this.broadcastToGroup(groupId, memberUpdate, [memberId]);

                UIManager.showNotification(`å·²å°† ${UserManager.contacts[memberId]?.name || memberId} æ·»åŠ åˆ°ç¾¤èŠ`, 'success');
                return true;
            } catch (error) {
                Utils.log(`æ·»åŠ ç¾¤èŠæˆå‘˜å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                // å¤‡ä»½åˆ°localStorage
                this.saveGroups();
                return true;
            }
        },

        removeMemberFromGroup: async function(groupId, memberId) {
            const group = this.groups[groupId];
            if (!group) return false;

            // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤ä¸»
            if (group.owner !== UserManager.userId) {
                UIManager.showNotification('åªæœ‰ç¾¤ä¸»å¯ä»¥ç§»é™¤æˆå‘˜', 'error');
                return false;
            }

            // ç§»é™¤æˆå‘˜
            const index = group.members.indexOf(memberId);
            if (index !== -1) {
                group.members.splice(index, 1);

                try {
                    await DBManager.setItem('groups', group);

                    // æ›´æ–°æˆå‘˜ç®¡ç†ç•Œé¢
                    this.showMemberManagement();

                    // æ›´æ–°ç¾¤èŠæ ‡é¢˜
                    if (this.currentGroupId === groupId) {
                        document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}äºº)`;
                    }

                    // å‘é€ç³»ç»Ÿæ¶ˆæ¯
                    const systemMessage = {
                        type: 'system',
                        content: `${UserManager.contacts[memberId]?.name || memberId} å·²è¢«ç§»å‡ºç¾¤èŠ`,
                        timestamp: new Date().toISOString()
                    };

                    // æ·»åŠ åˆ°èŠå¤©è®°å½•
                    ChatManager.addMessage(groupId, systemMessage);

                    // é€šçŸ¥è¢«ç§»é™¤çš„æˆå‘˜
                    const removeNotification = {
                        type: 'group-removed',
                        groupId: groupId,
                        reason: 'removed_by_owner',
                        sender: UserManager.userId,
                        timestamp: new Date().toISOString()
                    };

                    if (ConnectionManager.isConnectedTo(memberId)) {
                        ConnectionManager.sendTo(memberId, removeNotification);
                    }

                    // é€šçŸ¥å…¶ä»–æˆå‘˜
                    const memberUpdate = {
                        type: 'group-member-removed',
                        groupId: groupId,
                        removedMemberId: memberId,
                        sender: UserManager.userId,
                        timestamp: new Date().toISOString()
                    };

                    this.broadcastToGroup(groupId, memberUpdate);

                    UIManager.showNotification(`å·²å°† ${UserManager.contacts[memberId]?.name || memberId} ç§»å‡ºç¾¤èŠ`, 'success');
                    return true;
                } catch (error) {
                    Utils.log(`ç§»é™¤ç¾¤èŠæˆå‘˜å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                    // å¤‡ä»½åˆ°localStorage
                    this.saveGroups();
                    return true;
                }
            }

            return false;
        },

        clearUnread: async function(groupId) {
            if (this.groups[groupId]) {
                this.groups[groupId].unread = 0;

                try {
                    await DBManager.setItem('groups', this.groups[groupId]);
                    this.renderGroupList();
                } catch (error) {
                    Utils.log(`æ¸…é™¤ç¾¤èŠæœªè¯»æ•°å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                    // å¤‡ä»½åˆ°localStorage
                    this.saveGroups();
                    this.renderGroupList();
                }
            }
        },

        updateGroupLastMessage: async function(groupId, message, isUnread = false) {
            if (this.groups[groupId]) {
                this.groups[groupId].lastMessage = message;
                this.groups[groupId].lastTime = new Date().toISOString();
                if (isUnread) {
                    this.groups[groupId].unread = (this.groups[groupId].unread || 0) + 1;
                }

                try {
                    await DBManager.setItem('groups', this.groups[groupId]);
                    this.renderGroupList();
                } catch (error) {
                    Utils.log(`æ›´æ–°ç¾¤èŠæœ€åæ¶ˆæ¯å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                    // å¤‡ä»½åˆ°localStorage
                    this.saveGroups();
                    this.renderGroupList();
                }
            }
        },

        handleGroupInvite: async function(message) {
            // åˆ›å»ºæˆ–æ›´æ–°æœ¬åœ°ç¾¤ç»„ä¿¡æ¯
            this.groups[message.groupId] = {
                id: message.groupId,
                name: message.groupName,
                owner: message.owner,
                members: message.members,
                lastMessage: 'æ‚¨è¢«é‚€è¯·åŠ å…¥ç¾¤èŠ',
                lastTime: message.timestamp,
                unread: 1
            };

            try {
                await DBManager.setItem('groups', this.groups[message.groupId]);
                this.renderGroupList();

                // æ˜¾ç¤ºé€šçŸ¥
                UIManager.showNotification(`æ‚¨å·²è¢«é‚€è¯·åŠ å…¥ç¾¤èŠ"${message.groupName}"`, 'info');
            } catch (error) {
                Utils.log(`ä¿å­˜ç¾¤èŠé‚€è¯·å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                // å¤‡ä»½åˆ°localStorage
                this.saveGroups();
                this.renderGroupList();

                // æ˜¾ç¤ºé€šçŸ¥
                UIManager.showNotification(`æ‚¨å·²è¢«é‚€è¯·åŠ å…¥ç¾¤èŠ"${message.groupName}"`, 'info');
            }
        },

        handleGroupRemoval: async function(message) {
            const groupId = message.groupId;

            // å¦‚æœç¾¤ç»„å­˜åœ¨ï¼Œç§»é™¤å®ƒ
            if (this.groups[groupId]) {
                // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥ç¾¤ç»„ï¼Œå…³é—­å®ƒ
                if (this.currentGroupId === groupId) {
                    this.currentGroupId = null;
                    ChatManager.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = 'æœªé€‰æ‹©èŠå¤©';
                    document.getElementById('chatBox').innerHTML = '';
                    document.getElementById('chatHeaderActions').style.display = 'none';
                }

                try {
                    // åˆ é™¤ç¾¤ç»„
                    await DBManager.removeItem('groups', groupId);
                    delete this.groups[groupId];
                    this.renderGroupList();

                    // æ˜¾ç¤ºé€šçŸ¥
                    UIManager.showNotification('æ‚¨å·²è¢«ç§»å‡ºç¾¤èŠ', 'warning');
                } catch (error) {
                    Utils.log(`å¤„ç†ç¾¤èŠç§»é™¤å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                    // å¤‡ä»½åˆ°localStorage
                    delete this.groups[groupId];
                    this.saveGroups();
                    this.renderGroupList();

                    // æ˜¾ç¤ºé€šçŸ¥
                    UIManager.showNotification('æ‚¨å·²è¢«ç§»å‡ºç¾¤èŠ', 'warning');
                }
            }
        },

        // ä¿®æ”¹æ¶ˆæ¯æ•°æ®ç»“æ„
        broadcastToGroup: function(groupId, message, excludeMembers = []) {
            const group = this.groups[groupId];
            if (!group) return false;

            // ç¡®ä¿æ¶ˆæ¯æœ‰å‘é€è€…ä¿¡æ¯
            if (!message.sender) {
                message.sender = UserManager.userId;
            }

            // æ·»åŠ åŸå§‹å‘é€è€…ä¿¡æ¯ï¼Œç”¨äºè¿½è¸ªæ¶ˆæ¯çœŸå®æ¥æº
            message.originalSender = message.sender;
            message.originalSenderName = UserManager.userName;

            // ç¡®ä¿æ¶ˆæ¯æœ‰æ—¶é—´æˆ³
            if (!message.timestamp) {
                message.timestamp = new Date().toISOString();
            }

            // æ·»åŠ ç¾¤ç»„ID
            message.groupId = groupId;

            // å¦‚æœæ˜¯ç¾¤ä¸»ï¼Œç›´æ¥å‘æ‰€æœ‰æˆå‘˜å¹¿æ’­
            if (group.owner === UserManager.userId) {
                let successCount = 0;

                // å‘æ¯ä¸ªæˆå‘˜å‘é€æ¶ˆæ¯ï¼ˆæ’é™¤è‡ªå·±å’Œå¯èƒ½çš„æ’é™¤åˆ—è¡¨ï¼‰
                group.members.forEach(memberId => {
                    if (memberId !== UserManager.userId && !excludeMembers.includes(memberId)) {
                        if (ConnectionManager.isConnectedTo(memberId)) {
                            // å‘é€æ–‡ä»¶æ¶ˆæ¯éœ€è¦ä½¿ç”¨sendInChunks
                            if (message.type === 'file' || message.type === 'image' || message.type === 'audio') {
                                Utils.sendInChunks(JSON.stringify(message),
                                    (data) => ConnectionManager.connections[memberId].dataChannel.send(data));
                            } else {
                                ConnectionManager.sendTo(memberId, message);
                            }
                            successCount++;
                        }
                    }
                });

                return successCount > 0;
            }
            // å¦‚æœä¸æ˜¯ç¾¤ä¸»ï¼Œå°†æ¶ˆæ¯å‘é€ç»™ç¾¤ä¸»ï¼Œç”±ç¾¤ä¸»è½¬å‘
            else if (ConnectionManager.isConnectedTo(group.owner)) {
                // æ·»åŠ è½¬å‘æ ‡è®°ï¼Œè¡¨ç¤ºè¿™æ˜¯éœ€è¦ç¾¤ä¸»è½¬å‘çš„æ¶ˆæ¯
                message.needsRelay = true;

                // å‘é€æ–‡ä»¶æ¶ˆæ¯éœ€è¦ä½¿ç”¨sendInChunks
                if (message.type === 'file' || message.type === 'image' || message.type === 'audio') {
                    Utils.sendInChunks(JSON.stringify(message),
                        (data) => ConnectionManager.connections[group.owner].dataChannel.send(data));
                    return true;
                } else {
                    return ConnectionManager.sendTo(group.owner, message);
                }
            }

            return false;
        },

        renderGroupList: function() {
            const groupList = document.getElementById('groupList');
            groupList.innerHTML = '';

            const sortedGroups = Object.values(this.groups).sort((a, b) => {
                return new Date(b.lastTime) - new Date(a.lastTime);
            });

            if (sortedGroups.length === 0) {
                groupList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">æš‚æ— ç¾¤èŠï¼Œç‚¹å‡»"åˆ›å»ºæ–°ç¾¤èŠ"å¼€å§‹</div>';
                return;
            }

            sortedGroups.forEach(group => {
                const groupItem = document.createElement('div');
                groupItem.className = `group-item ${group.id === this.currentGroupId ? 'active' : ''}`;
                groupItem.setAttribute('data-id', group.id);

                const lastTime = new Date(group.lastTime);
                const formattedTime = Utils.formatDate(lastTime);

                // åˆ¤æ–­æ˜¯ç¾¤ä¸»è¿˜æ˜¯æ™®é€šæˆå‘˜
                const isOwner = group.owner === UserManager.userId;
                const buttonText = isOwner ? 'ç¾¤è§£æ•£' : 'é€€ç¾¤';
                const buttonClass = isOwner ? 'dissolve-btn' : 'leave-btn';

                groupItem.innerHTML = `
            <div class="group-avatar">ğŸ‘¥</div>
            <div class="group-info">
                <div class="group-name">${group.name}</div>
                <div class="group-preview">${group.members.length}äºº | ${group.lastMessage || 'æš‚æ— æ¶ˆæ¯'}</div>
            </div>
            <div class="group-meta">
                <div class="group-time">${formattedTime}</div>
                ${group.unread ? `<div class="chat-badge">${group.unread > 99 ? '99+' : group.unread}</div>` : ''}
            </div>
            <div class="${buttonClass}" style="display: none;">${buttonText}</div>
        `;

                groupItem.addEventListener('click', (e) => {
                    // å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®ï¼Œä¸æ‰“å¼€ç¾¤èŠ
                    if (e.target.classList.contains('leave-btn')) {
                        e.stopPropagation();
                        this.leaveGroup(group.id);
                        return;
                    } else if (e.target.classList.contains('dissolve-btn')) {
                        e.stopPropagation();
                        this.dissolveGroup(group.id);
                        return;
                    }
                    this.openGroup(group.id);
                });

                // æ·»åŠ é¼ æ ‡æ‚¬æµ®äº‹ä»¶
                groupItem.addEventListener('mouseenter', () => {
                    groupItem.querySelector(`.${buttonClass}`).style.display = 'block';
                });

                groupItem.addEventListener('mouseleave', () => {
                    groupItem.querySelector(`.${buttonClass}`).style.display = 'none';
                });

                groupList.appendChild(groupItem);
            });
        },

        // ä¿®æ”¹leaveGroupæ–¹æ³•ï¼Œæ·»åŠ ç³»ç»Ÿæ¶ˆæ¯é€šçŸ¥å…¶ä»–æˆå‘˜
        leaveGroup: async function(groupId) {
            if (confirm('ç¡®å®šè¦é€€å‡ºæ­¤ç¾¤èŠå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                const group = this.groups[groupId];
                if (!group) return;

                // è·å–ç”¨æˆ·åç§°
                let userName = UserManager.userName;
                if (UserManager.contacts[UserManager.userId]) {
                    userName = UserManager.contacts[UserManager.userId].name;
                }

                // ä»æˆå‘˜åˆ—è¡¨ä¸­ç§»é™¤è‡ªå·±
                const index = group.members.indexOf(UserManager.userId);
                if (index !== -1) {
                    // åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯ï¼Œé€šçŸ¥å…¶ä»–æˆå‘˜
                    const systemMessage = {
                        type: 'system',
                        content: `${userName} å·²é€€å‡ºç¾¤èŠ`,
                        timestamp: new Date().toISOString(),
                        sender: UserManager.userId
                    };

                    // å¹¿æ’­ç³»ç»Ÿæ¶ˆæ¯ç»™ç¾¤ç»„å…¶ä»–æˆå‘˜
                    this.broadcastToGroup(groupId, systemMessage);

                    // é€šçŸ¥ç¾¤ä¸»æ­¤æˆå‘˜å·²é€€å‡ºï¼ˆä¾¿äºç¾¤ä¸»è¯†åˆ«å¹¶å¯ä»¥é‡æ–°æ·»åŠ ï¼‰
                    const leaveMessage = {
                        type: 'group-member-left',
                        groupId: groupId,
                        leftMemberId: UserManager.userId,
                        leftMemberName: userName,
                        timestamp: new Date().toISOString(),
                        sender: UserManager.userId
                    };
                    this.broadcastToGroup(groupId, leaveMessage);

                    // æ¸…ç©ºç¾¤èŠè®°å½•
                    await ChatManager.clearChat(groupId);

                    // ä»ç¾¤ç»„ä¸­åˆ é™¤
                    await DBManager.removeItem('groups', groupId);
                    delete this.groups[groupId];

                    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥ç¾¤èŠï¼Œé‡ç½®èŠå¤©ç•Œé¢
                    if (this.currentGroupId === groupId) {
                        this.currentGroupId = null;
                        ChatManager.currentChatId = null;
                        document.getElementById('currentChatTitle').textContent = 'æœªé€‰æ‹©èŠå¤©';
                        document.getElementById('chatBox').innerHTML = '';
                        document.getElementById('chatHeaderActions').style.display = 'none';

                        // ç¦ç”¨èŠå¤©ç•Œé¢
                        UIManager.enableChatInterface(false);
                    }

                    // æ›´æ–°ç¾¤èŠåˆ—è¡¨
                    this.renderGroupList();

                    // æ˜¾ç¤ºé€šçŸ¥
                    UIManager.showNotification('å·²é€€å‡ºç¾¤èŠ', 'info');
                }
            }
        },

        // ä¿®æ”¹handleMembershipUpdateæ–¹æ³•ï¼Œå¤„ç†æˆå‘˜é€€å‡ºäº‹ä»¶
        handleMembershipUpdate: async function(message) {
            const groupId = message.groupId;
            const group = this.groups[groupId];

            if (!group) return;

            // æ›´æ–°æˆå‘˜åˆ—è¡¨
            if (message.type === 'group-member-added' && message.newMemberId) {
                if (!group.members.includes(message.newMemberId)) {
                    group.members.push(message.newMemberId);
                }
            } else if (message.type === 'group-member-removed' && message.removedMemberId) {
                const index = group.members.indexOf(message.removedMemberId);
                if (index !== -1) {
                    group.members.splice(index, 1);
                }
            } else if (message.type === 'group-member-left' && message.leftMemberId) {
                const index = group.members.indexOf(message.leftMemberId);
                if (index !== -1) {
                    group.members.splice(index, 1);

                    // å¦‚æœå½“å‰ç”¨æˆ·æ˜¯ç¾¤ä¸»ï¼Œè®°å½•é€€å‡ºæˆå‘˜çš„ä¿¡æ¯ï¼Œä»¥ä¾¿é‡æ–°æ·»åŠ 
                    if (group.owner === UserManager.userId) {
                        // ä¿å­˜é€€å‡ºæˆå‘˜ä¿¡æ¯åˆ°ç¾¤ç»„æ•°æ®ä¸­
                        if (!group.leftMembers) {
                            group.leftMembers = [];
                        }

                        group.leftMembers.push({
                            id: message.leftMemberId,
                            name: message.leftMemberName || `ç”¨æˆ·${message.leftMemberId.substring(0, 4)}`,
                            leftTime: message.timestamp
                        });
                    }
                }
            }

            try {
                await DBManager.setItem('groups', group);

                // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥ç¾¤ç»„ï¼Œæ›´æ–°æ ‡é¢˜
                if (this.currentGroupId === groupId) {
                    document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}äºº)`;
                }
            } catch (error) {
                Utils.log(`æ›´æ–°ç¾¤èŠæˆå‘˜å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                // å¤‡ä»½åˆ°localStorage
                this.saveGroups();

                // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥ç¾¤ç»„ï¼Œæ›´æ–°æ ‡é¢˜
                if (this.currentGroupId === groupId) {
                    document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}äºº)`;
                }
            }
        },

        // ä¿®æ”¹showMemberManagementæ–¹æ³•ï¼Œæ·»åŠ å·²é€€å‡ºæˆå‘˜åˆ—è¡¨
        showMemberManagement: function() {
            if (!this.currentGroupId) return;

            const group = this.groups[this.currentGroupId];
            if (!group) return;

            // å¡«å……æˆå‘˜åˆ—è¡¨
            const memberList = document.getElementById('groupMemberList');
            memberList.innerHTML = '';

            group.members.forEach(memberId => {
                const memberItem = document.createElement('div');
                memberItem.className = 'member-item';

                // ç¡®å®šæˆå‘˜åç§°
                let memberName = memberId;
                if (memberId === UserManager.userId) {
                    memberName = `${UserManager.userName} (æˆ‘)`;
                } else if (UserManager.contacts[memberId]) {
                    memberName = UserManager.contacts[memberId].name;
                }

                // æ ‡è®°ç¾¤ä¸»
                const isOwner = memberId === group.owner;

                memberItem.innerHTML = `
            <div class="member-name">${memberName} ${isOwner ? '<span class="owner-badge">ç¾¤ä¸»</span>' : ''}</div>
            ${!isOwner && group.owner === UserManager.userId ?
                    `<button class="remove-member-btn" data-id="${memberId}">ç§»é™¤</button>` : ''}
        `;

                memberList.appendChild(memberItem);
            });

            // ä¸ºç§»é™¤æŒ‰é’®æ·»åŠ äº‹ä»¶
            memberList.querySelectorAll('.remove-member-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const memberId = e.target.getAttribute('data-id');
                    this.removeMemberFromGroup(this.currentGroupId, memberId);
                });
            });

            // æ·»åŠ å·²é€€å‡ºæˆå‘˜åˆ—è¡¨ï¼ˆä»…ç¾¤ä¸»å¯è§ï¼‰
            if (group.owner === UserManager.userId && group.leftMembers && group.leftMembers.length > 0) {
                const leftMembersSection = document.createElement('div');
                leftMembersSection.className = 'left-members-section';
                leftMembersSection.innerHTML = '<h4>å·²é€€å‡ºæˆå‘˜</h4>';

                const leftMembersList = document.createElement('div');
                leftMembersList.className = 'left-members-list';

                group.leftMembers.forEach(member => {
                    const leftMemberItem = document.createElement('div');
                    leftMemberItem.className = 'left-member-item';

                    // æ ¼å¼åŒ–é€€å‡ºæ—¶é—´
                    const leftTime = new Date(member.leftTime);
                    const formattedTime = Utils.formatDate(leftTime);

                    leftMemberItem.innerHTML = `
                <div class="left-member-info">
                    <div class="left-member-name">${member.name}</div>
                    <div class="left-member-time">é€€å‡ºæ—¶é—´: ${formattedTime}</div>
                </div>
                <button class="readd-member-btn" data-id="${member.id}" data-name="${member.name}">é‡æ–°æ·»åŠ </button>
            `;

                    leftMembersList.appendChild(leftMemberItem);
                });

                leftMembersSection.appendChild(leftMembersList);
                memberList.appendChild(leftMembersSection);

                // ä¸ºé‡æ–°æ·»åŠ æŒ‰é’®æ·»åŠ äº‹ä»¶
                memberList.querySelectorAll('.readd-member-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const memberId = e.target.getAttribute('data-id');
                        const memberName = e.target.getAttribute('data-name');
                        this.readdMemberToGroup(this.currentGroupId, memberId, memberName);
                    });
                });
            }

            // å¡«å……è”ç³»äººä¸‹æ‹‰åˆ—è¡¨
            const contactsDropdown = document.getElementById('contactsDropdown');
            contactsDropdown.innerHTML = '<option value="">é€‰æ‹©è”ç³»äºº...</option>';

            Object.values(UserManager.contacts).forEach(contact => {
                // åªæ˜¾ç¤ºæœªåŠ å…¥ç¾¤çš„è”ç³»äºº
                if (!group.members.includes(contact.id)) {
                    const option = document.createElement('option');
                    option.value = contact.id;
                    option.textContent = contact.name;
                    contactsDropdown.appendChild(option);
                }
            });

            // æ˜¾ç¤ºæ¨¡æ€çª—å£
            document.getElementById('memberManagementModal').style.display = 'block';
        },

        // æ·»åŠ é‡æ–°æ·»åŠ æˆå‘˜æ–¹æ³•
        readdMemberToGroup: async function(groupId, memberId, memberName) {
            const group = this.groups[groupId];
            if (!group) return false;

            // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤ä¸»
            if (group.owner !== UserManager.userId) {
                UIManager.showNotification('åªæœ‰ç¾¤ä¸»å¯ä»¥æ·»åŠ æˆå‘˜', 'error');
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯æˆå‘˜
            if (group.members.includes(memberId)) {
                UIManager.showNotification('è¯¥ç”¨æˆ·å·²åœ¨ç¾¤èŠä¸­', 'warning');
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥
            if (!ConnectionManager.isConnectedTo(memberId)) {
                UIManager.showNotification('è¯·å…ˆä¸è¯¥ç”¨æˆ·å»ºç«‹è¿æ¥', 'warning');
                return false;
            }

            // æ·»åŠ æˆå‘˜
            group.members.push(memberId);

            // ä»leftMembersä¸­ç§»é™¤
            if (group.leftMembers) {
                group.leftMembers = group.leftMembers.filter(member => member.id !== memberId);
            }

            try {
                await DBManager.setItem('groups', group);

                // æ›´æ–°æˆå‘˜ç®¡ç†ç•Œé¢
                this.showMemberManagement();

                // æ›´æ–°ç¾¤èŠæ ‡é¢˜
                if (this.currentGroupId === groupId) {
                    document.getElementById('currentChatTitle').textContent = `${group.name} (${group.members.length}äºº)`;
                }

                // å‘é€ç³»ç»Ÿæ¶ˆæ¯
                const systemMessage = {
                    type: 'system',
                    content: `${memberName || memberId} å·²è¢«é‡æ–°æ·»åŠ åˆ°ç¾¤èŠ`,
                    timestamp: new Date().toISOString()
                };

                // æ·»åŠ åˆ°èŠå¤©è®°å½•
                ChatManager.addMessage(groupId, systemMessage);

                // é€šçŸ¥æ–°æˆå‘˜å·²åŠ å…¥ç¾¤èŠ
                const groupInfo = {
                    type: 'group-invite',
                    groupId: groupId,
                    groupName: group.name,
                    members: group.members,
                    owner: group.owner,
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                ConnectionManager.sendTo(memberId, groupInfo);

                // é€šçŸ¥å…¶ä»–æˆå‘˜æœ‰æ–°æˆå‘˜åŠ å…¥
                const memberUpdate = {
                    type: 'group-member-added',
                    groupId: groupId,
                    newMemberId: memberId,
                    newMemberName: memberName,
                    sender: UserManager.userId,
                    timestamp: new Date().toISOString()
                };

                this.broadcastToGroup(groupId, memberUpdate, [memberId]);

                UIManager.showNotification(`å·²å°† ${memberName || memberId} é‡æ–°æ·»åŠ åˆ°ç¾¤èŠ`, 'success');
                return true;
            } catch (error) {
                Utils.log(`é‡æ–°æ·»åŠ ç¾¤èŠæˆå‘˜å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                // å¤‡ä»½åˆ°localStorage
                this.saveGroups();
                return true;
            }
        },

        // ç¾¤ä¸»è§£æ•£ç¾¤èŠæ–¹æ³•
        dissolveGroup: async function(groupId) {
            if (confirm('ç¡®å®šè¦è§£æ•£æ­¤ç¾¤èŠå—ï¼Ÿæ‰€æœ‰æˆå‘˜å°†è¢«ç§»å‡ºï¼Œä¸”æ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                const group = this.groups[groupId];
                if (!group || group.owner !== UserManager.userId) return;

                // é€šçŸ¥æ‰€æœ‰æˆå‘˜ç¾¤èŠå·²è§£æ•£
                const dissolveMessage = {
                    type: 'group-dissolved',
                    groupId: groupId,
                    timestamp: new Date().toISOString(),
                    sender: UserManager.userId
                };
                this.broadcastToGroup(groupId, dissolveMessage);

                // æ¸…ç©ºç¾¤èŠè®°å½•
                await ChatManager.clearChat(groupId);

                // ä»ç¾¤ç»„ä¸­åˆ é™¤
                await DBManager.removeItem('groups', groupId);
                delete this.groups[groupId];

                // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥ç¾¤èŠï¼Œé‡ç½®èŠå¤©ç•Œé¢
                if (this.currentGroupId === groupId) {
                    this.currentGroupId = null;
                    ChatManager.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = 'æœªé€‰æ‹©èŠå¤©';
                    document.getElementById('chatBox').innerHTML = '';
                    document.getElementById('chatHeaderActions').style.display = 'none';

                    // ç¦ç”¨èŠå¤©ç•Œé¢
                    UIManager.enableChatInterface(false);
                }

                // æ›´æ–°ç¾¤èŠåˆ—è¡¨
                this.renderGroupList();

                // æ˜¾ç¤ºé€šçŸ¥
                UIManager.showNotification('ç¾¤èŠå·²è§£æ•£', 'info');
            }
        },

        // ä¿®æ”¹handleGroupMessageæ–¹æ³•ï¼Œæ·»åŠ å¤„ç†ç¾¤è§£æ•£å’Œæˆå‘˜é€€å‡ºçš„é€»è¾‘
        handleGroupMessage: function(message) {
            const groupId = message.groupId;

            // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤ç»„æ¶ˆæ¯
            if (!groupId || !message.type) return false;

            // å¦‚æœæ˜¯ç¾¤ä¸»æ”¶åˆ°çš„æ¶ˆæ¯ï¼Œä¸”éœ€è¦è½¬å‘
            if (message.needsRelay) {
                const group = this.groups[groupId];
                if (group && group.owner === UserManager.userId) {
                    // ç§»é™¤è½¬å‘æ ‡è®°ï¼Œé˜²æ­¢å¾ªç¯è½¬å‘
                    delete message.needsRelay;

                    // è½¬å‘æ—¶ä¿ç•™åŸå§‹å‘é€è€…ä¿¡æ¯
                    // ç¾¤ä¸»è½¬å‘æ¶ˆæ¯æ—¶ï¼Œä¸ä¿®æ”¹senderï¼Œç¡®ä¿æ¶ˆæ¯æ˜¾ç¤ºçš„æ˜¯çœŸå®å‘é€è€…
                    this.broadcastToGroup(groupId, message, [message.originalSender]);
                }
            }

            // å¤„ç†ä¸åŒç±»å‹çš„ç¾¤ç»„æ¶ˆæ¯
            switch (message.type) {
                case 'group-invite':
                    // å¤„ç†ç¾¤ç»„é‚€è¯·
                    this.handleGroupInvite(message);
                    break;

                case 'group-removed':
                    // å¤„ç†è¢«ç§»å‡ºç¾¤ç»„
                    this.handleGroupRemoval(message);
                    break;

                case 'group-dissolved':
                    // å¤„ç†ç¾¤ç»„è§£æ•£
                    this.handleGroupDissolved(message);
                    break;

                case 'group-member-added':
                case 'group-member-removed':
                case 'group-member-left':
                    // æ›´æ–°ç¾¤ç»„æˆå‘˜ä¿¡æ¯
                    this.handleMembershipUpdate(message);
                    break;

                case 'text':
                case 'file':
                case 'image':
                case 'audio':
                    // å¤„ç†æ™®é€šæ¶ˆæ¯
                    if (this.groups[groupId]) {
                        // æ·»åŠ åˆ°èŠå¤©è®°å½•ï¼Œä¿ç•™åŸå§‹å‘é€è€…ä¿¡æ¯
                        ChatManager.addMessage(groupId, message);

                        // æ›´æ–°ç¾¤ç»„æœ€åæ¶ˆæ¯
                        let previewText = '';
                        const displayName = message.originalSenderName ||
                            (UserManager.contacts[message.originalSender]?.name) ||
                            'ç”¨æˆ·';

                        if (message.type === 'text') {
                            previewText = `${displayName}: ${message.content}`;
                        } else if (message.type === 'file' || message.type === 'image') {
                            if (message.fileType?.startsWith('image/')) {
                                previewText = `${displayName}: [å›¾ç‰‡]`;
                            } else if (message.fileType?.startsWith('video/')) {
                                previewText = `${displayName}: [è§†é¢‘]`;
                            } else if (message.fileType?.startsWith('audio/')) {
                                previewText = `${displayName}: [éŸ³é¢‘]`;
                            } else {
                                previewText = `${displayName}: [æ–‡ä»¶]`;
                            }
                        } else if (message.type === 'audio') {
                            previewText = `${displayName}: [è¯­éŸ³]`;
                        }

                        this.updateGroupLastMessage(
                            groupId,
                            previewText,
                            this.currentGroupId !== groupId
                        );
                    }
                    break;

                case 'system':
                    // å¤„ç†ç³»ç»Ÿæ¶ˆæ¯
                    if (this.groups[groupId]) {
                        ChatManager.addMessage(groupId, message);
                    }
                    break;
            }

            return true;
        },

        // å¤„ç†ç¾¤èŠè§£æ•£
        handleGroupDissolved: async function(message) {
            const groupId = message.groupId;

            // å¦‚æœç¾¤ç»„å­˜åœ¨ä¸”ä¸æ˜¯è‡ªå·±è§£æ•£çš„ï¼Œåˆ™å¤„ç†è§£æ•£æ¶ˆæ¯
            if (this.groups[groupId] && message.sender !== UserManager.userId) {
                // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥ç¾¤ç»„ï¼Œå…³é—­å®ƒ
                if (this.currentGroupId === groupId) {
                    this.currentGroupId = null;
                    ChatManager.currentChatId = null;
                    document.getElementById('currentChatTitle').textContent = 'æœªé€‰æ‹©èŠå¤©';
                    document.getElementById('chatBox').innerHTML = '';
                    document.getElementById('chatHeaderActions').style.display = 'none';

                    // ç¦ç”¨èŠå¤©ç•Œé¢
                    UIManager.enableChatInterface(false);
                }

                try {
                    // æ¸…ç©ºç¾¤èŠè®°å½•
                    await ChatManager.clearChat(groupId);

                    // åˆ é™¤ç¾¤ç»„
                    await DBManager.removeItem('groups', groupId);
                    delete this.groups[groupId];
                    this.renderGroupList();

                    // æ˜¾ç¤ºé€šçŸ¥
                    UIManager.showNotification('ç¾¤ä¸»å·²è§£æ•£ç¾¤èŠ', 'warning');
                } catch (error) {
                    Utils.log(`å¤„ç†ç¾¤èŠè§£æ•£å¤±è´¥: ${error}`, Utils.logLevels.ERROR);
                    // å¤‡ä»½åˆ°localStorage
                    delete this.groups[groupId];
                    this.saveGroups();
                    this.renderGroupList();

                    // æ˜¾ç¤ºé€šçŸ¥
                    UIManager.showNotification('ç¾¤ä¸»å·²è§£æ•£ç¾¤èŠ', 'warning');
                }
            }
        }

    };

    // åˆå§‹åŒ–åº”ç”¨
    const AppInitializer = {

        init: async function () {
            // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
            if (!UIManager.checkWebRTCSupport()) return;

            try {
                // åˆå§‹åŒ–IndexedDB
                await DBManager.init();
                Utils.log('æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ', Utils.logLevels.INFO);

                // åˆå§‹åŒ–ç”¨æˆ·ç®¡ç†
                await UserManager.init();

                // åˆå§‹åŒ–èŠå¤©ç®¡ç†
                await ChatManager.init();

                // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
                this.checkNetworkType();

                // æ·»åŠ ç½‘ç»œçŠ¶æ€ç›‘å¬
                this.startNetworkMonitoring();

                // åˆå§‹åŒ–è¯­éŸ³å½•åˆ¶æŒ‰é’®ï¼ˆä½†ä¸ç”³è¯·æƒé™ï¼‰
                MediaManager.initVoiceRecording();

                // åˆå§‹åŒ–è§†é¢‘é€šè¯æŒ‰é’®ï¼ˆä½†ä¸ç”³è¯·æƒé™ï¼‰
                VideoCallManager.init();

                // æ·»åŠ æŒ‰é’®äº‹ä»¶å¤„ç†ç¨‹åº
                this.setupEventListeners();

                // åˆå§‹åŒ–ç§»åŠ¨ç«¯UI
                this.initMobileUI();

                // åˆå§‹åŒ–ç¾¤èŠç®¡ç†
                await GroupManager.init();

                Utils.log('åº”ç”¨å·²åˆå§‹åŒ–', Utils.logLevels.INFO);
            } catch (error) {
                Utils.log(`åº”ç”¨åˆå§‹åŒ–å¤±è´¥: ${error}`, Utils.logLevels.ERROR);

                // å›é€€åˆ°localStorageæ¨¡å¼
                Utils.log('å›é€€åˆ°localStorageå­˜å‚¨æ¨¡å¼', Utils.logLevels.WARN);

                // åˆå§‹åŒ–ç”¨æˆ·ç®¡ç†
                UserManager.userId = Utils.generateId();
                document.getElementById('userIdValue').textContent = UserManager.userId;

                // åŠ è½½è”ç³»äºº
                UserManager.loadContactsFromLocalStorage();

                // åˆå§‹åŒ–èŠå¤©ç®¡ç†
                ChatManager.loadChatsFromLocalStorage();

                // å…¶ä»–åˆå§‹åŒ–æ­¥éª¤
                this.checkNetworkType();
                this.startNetworkMonitoring();
                MediaManager.initVoiceRecording();
                VideoCallManager.init();
                this.setupEventListeners();
                this.initMobileUI();

                // åŠ è½½ç¾¤ç»„
                GroupManager.loadGroupsFromLocalStorage();

                Utils.log('åº”ç”¨å·²ä½¿ç”¨localStorageæ¨¡å¼åˆå§‹åŒ–', Utils.logLevels.INFO);
            }
        },

        // åˆå§‹åŒ–ç§»åŠ¨ç«¯UI
        initMobileUI: function() {
            // æ·»åŠ è¿”å›è®¾ç½®æŒ‰é’®äº‹ä»¶
            const backButton = document.getElementById('backToSettings');
            if (backButton) {
                backButton.addEventListener('click', function() {
                    document.querySelector('.container').classList.remove('connected-mode');
                });
            }


            // å“åº”å±å¹•å°ºå¯¸å˜åŒ–
            window.addEventListener('resize', function() {
                const container = document.querySelector('.container');
                const isConnected = document.getElementById('connectionStatus').classList.contains('connected');
                const sidebar = document.querySelector('.sidebar');

                // å¦‚æœæ˜¯ç§»åŠ¨ç«¯ä¸”å·²è¿æ¥ï¼Œä¿æŒèŠå¤©ç•Œé¢æ˜¾ç¤º
                if (window.innerWidth <= 768 && isConnected && ChatManager.currentChatId) {
                    // æ˜¾ç¤ºè¿›å…¥èŠå¤©æŒ‰é’®
                    if (sidebar) sidebar.classList.add('show-back-btn');
                } else if (window.innerWidth > 768) {
                    // åœ¨å¤§å±å¹•ä¸Šï¼Œç§»é™¤è¿æ¥æ¨¡å¼ç±»ï¼Œæ˜¾ç¤ºä¸¤ä¸ªé¢æ¿
                    container.classList.remove('connected-mode');
                }
            });
        },

        // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
        checkNetworkType: async function () {
            const networkInfo = document.getElementById('networkInfo');
            networkInfo.innerHTML = '<span class="loading-spinner"></span> æ­£åœ¨æ£€æµ‹ç½‘ç»œ...';

            try {
                const networkType = await Utils.checkNetworkType();

                if (networkType) {
                    let networkHtml = `
                    ç½‘ç»œæ”¯æŒ:<br>
                    IPv4: ${networkType.ipv4 ? 'âœ“' : 'âœ—'}<br>
                    IPv6: ${networkType.ipv6 ? 'âœ“' : 'âœ—'}<br>
                    UDP: ${networkType.udp ? 'âœ“' : 'âœ—'}<br>
                    TCP: ${networkType.tcp ? 'âœ“' : 'âœ—'}<br>
                    ä¸­ç»§: ${networkType.relay ? 'å¯ç”¨' : 'æœªæ£€æµ‹åˆ°'}<br>
                    å€™é€‰æ•°: ${networkType.count}
                `;

                    // æ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´é…ç½®
                    if (!networkType.udp && networkType.tcp) {
                        Config.peerConnectionConfig.iceTransportPolicy = 'relay';
                        networkHtml += '<br><b>å·²åˆ‡æ¢åˆ°ä¸­ç»§ä¼˜å…ˆæ¨¡å¼</b>';
                    }

                    networkInfo.innerHTML = networkHtml;

                    const qualityIndicator = document.getElementById('qualityIndicator');
                    if (qualityIndicator) {
                        if (networkType.udp) {
                            qualityIndicator.className = 'quality-indicator quality-good';
                            document.getElementById('qualityText').textContent = 'ç½‘ç»œè‰¯å¥½';
                        } else if (networkType.tcp) {
                            qualityIndicator.className = 'quality-indicator quality-medium';
                            document.getElementById('qualityText').textContent = 'ç½‘ç»œå—é™';
                        } else {
                            qualityIndicator.className = 'quality-indicator quality-poor';
                            document.getElementById('qualityText').textContent = 'ç½‘ç»œå—é˜»';
                        }
                    }
                } else {
                    networkInfo.innerHTML = 'ç½‘ç»œæ£€æµ‹å¤±è´¥';
                }
            } catch (error) {
                networkInfo.innerHTML = 'ç½‘ç»œæ£€æµ‹å¤±è´¥: ' + error.message;
            }
        },

        // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ–
        startNetworkMonitoring: function () {
            window.addEventListener('online', this.handleNetworkChange.bind(this));
            window.addEventListener('offline', this.handleNetworkChange.bind(this));
        },

        // å¤„ç†ç½‘ç»œå˜åŒ–
        handleNetworkChange: function () {
            if (navigator.onLine) {
                UIManager.updateStatus('ç½‘ç»œå·²æ¢å¤ï¼Œå°è¯•é‡æ–°è¿æ¥...');

                // å°è¯•é‡æ–°è¿æ¥æ‰€æœ‰æ´»è·ƒçš„è¿æ¥
                for (const peerId in ConnectionManager.connections) {
                    const conn = ConnectionManager.connections[peerId];
                    if (conn && conn.peerConnection &&
                        conn.peerConnection.iceConnectionState !== 'connected') {
                        ConnectionManager.restartIce(peerId);
                    }
                }
            } else {
                UIManager.updateStatus('ç½‘ç»œå·²æ–­å¼€');
            }
        },

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        setupEventListeners: function () {
            // æ¶ˆæ¯è¾“å…¥æ¡†å›è½¦å‘é€
            document.getElementById('messageInput').addEventListener('keydown', (e) => {
                // å¦‚æœæ˜¯ Ctrl+Enter ç»„åˆé”®ï¼Œåˆ™å‘é€æ¶ˆæ¯
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    MessageManager.sendMessage();
                }
                // ä»…æŒ‰å›è½¦é”®æ—¶ï¼Œå…è®¸æ¢è¡Œ
                else if (e.key === 'Enter' && !e.ctrlKey) {
                    // ä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå…è®¸è¾“å…¥æ¢è¡Œç¬¦
                }
            });

            // æ·»åŠ æ–­å¼€è¿æ¥äº‹ä»¶å¤„ç†
            EventEmitter.on('connectionDisconnected', function(peerId) {
                // å¦‚æœæ˜¯å½“å‰èŠå¤©ï¼Œæ›´æ–°UI
                if (ChatManager.currentChatId === peerId) {
                    // ç¦ç”¨è§†é¢‘é€šè¯æŒ‰é’®
                    document.getElementById('videoCallButton').disabled = true;
                    // ç¦ç”¨éŸ³é¢‘é€šè¯æŒ‰é’®
                    document.getElementById('audioCallButton').disabled = true;

                    // ç§»åŠ¨ç«¯ï¼šæ–­å¼€è¿æ¥æ—¶åˆ‡æ¢å›è®¾ç½®ç•Œé¢
                    if (window.innerWidth <= 768) {
                        document.querySelector('.container').classList.remove('connected-mode');
                    }
                }
            });

            EventEmitter.on('connectionEstablished', function(peerId) {
                // å¦‚æœæ˜¯å½“å‰èŠå¤©ï¼Œæ›´æ–°UI
                if (ChatManager.currentChatId === peerId) {
                    // å¯ç”¨è§†é¢‘é€šè¯æŒ‰é’®
                    document.getElementById('videoCallButton').disabled = false;
                    document.getElementById('videoCallButton').onclick = () => VideoCallManager.initiateCall(peerId);

                    // å¯ç”¨éŸ³é¢‘é€šè¯æŒ‰é’®
                    document.getElementById('audioCallButton').disabled = false;
                    document.getElementById('audioCallButton').onclick = () => VideoCallManager.initiateAudioCall(peerId);
                }
            });

            EventEmitter.on('connectionFailed', function(peerId) {
                // å¦‚æœæ˜¯å½“å‰èŠå¤©ï¼Œæ›´æ–°UI
                if (ChatManager.currentChatId === peerId) {
                    // ç¦ç”¨è§†é¢‘é€šè¯æŒ‰é’®
                    document.getElementById('videoCallButton').disabled = true;

                    // ç§»åŠ¨ç«¯ï¼šè¿æ¥å¤±è´¥æ—¶åˆ‡æ¢å›è®¾ç½®ç•Œé¢
                    if (window.innerWidth <= 768) {
                        document.querySelector('.container').classList.remove('connected-mode');
                    }
                }
            });

            // è¯­éŸ³å½•åˆ¶æŒ‰é’®äº‹ä»¶
            const voiceButton = document.getElementById('voiceButton');

            // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
            if ('ontouchstart' in window) {
                // ç§»åŠ¨è®¾å¤‡ä½¿ç”¨è§¦æ‘¸äº‹ä»¶
                voiceButton.addEventListener('touchstart', function (e) {
                    e.preventDefault();
                    MediaManager.startRecording();
                });

                voiceButton.addEventListener('touchend', function (e) {
                    e.preventDefault();
                    MediaManager.stopRecording();
                });
            } else {
                // æ¡Œé¢è®¾å¤‡ä½¿ç”¨é¼ æ ‡äº‹ä»¶
                voiceButton.addEventListener('mousedown', MediaManager.startRecording.bind(MediaManager));
                voiceButton.addEventListener('mouseup', MediaManager.stopRecording.bind(MediaManager));
                voiceButton.addEventListener('mouseleave', MediaManager.stopRecording.bind(MediaManager));
            }

            // æ·»åŠ å…¨å±€é”™è¯¯å¤„ç†
            window.addEventListener('error', (event) => {
                Utils.log(`åº”ç”¨é”™è¯¯: ${event.message}`, Utils.logLevels.ERROR);
            });

            // æ·»åŠ æ–­å¼€è¿æ¥å‰çš„æç¤º
            window.addEventListener('beforeunload', () => {
                // é‡Šæ”¾è¯­éŸ³å½•åˆ¶èµ„æº
                MediaManager.releaseAudioResources();

                // é‡Šæ”¾è§†é¢‘é€šè¯èµ„æº
                VideoCallManager.releaseMediaResources();

                // å…³é—­æ‰€æœ‰è¿æ¥
                for (const peerId in ConnectionManager.connections) {
                    ConnectionManager.close(peerId);
                }
            });


            // æ·»åŠ é‡ç½®æŒ‰é’®äº‹ä»¶
            document.getElementById('resetAllBtn').addEventListener('click', () => {
                UIManager.resetConnectionControls();
            });
        }
    };

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    window.addEventListener('load', AppInitializer.init.bind(AppInitializer));
</script>
</html>