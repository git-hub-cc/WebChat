<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P èŠå¤©</title>
    <style>
        /* å…¨å±€æ ·å¼ */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            display: flex;
            height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
            background: #fff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        /* ä¾§è¾¹æ æ ·å¼ */
        .sidebar {
            width: 30%;
            min-width: 300px;
            padding: 20px;
            background: #f8f9fa;
            border-right: 1px solid #eee;
            overflow-y: auto;
        }

        .sidebar h2 {
            margin-bottom: 20px;
            color: #343a40;
        }

        .status {
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
            background: #e9ecef;
            text-align: center;
            font-weight: bold;
            transition: all 0.3s;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
        }

        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .network-info {
            margin-bottom: 20px;
            padding: 10px;
            background: #f1f3f5;
            border-radius: 4px;
            font-size: 14px;
        }

        .connection-quality {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .quality-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin: 0 8px;
            background: #6c757d;
        }

        .quality-good {
            background: #28a745;
        }

        .quality-medium {
            background: #ffc107;
        }

        .quality-poor {
            background: #dc3545;
        }

        .steps {
            margin-bottom: 20px;
        }

        .step {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .step-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #007bff;
            color: white;
            margin-right: 10px;
            font-size: 14px;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
        }

        button:hover {
            background: #0069d9;
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .connection-info {
            margin-top: 20px;
        }

        .connection-info h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        textarea {
            width: 100%;
            height: 80px;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            resize: none;
            font-family: monospace;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .copy-button {
            width: 100%;
            background: #17a2b8;
        }

        .copy-button:hover {
            background: #138496;
        }

        .debug-info {
            margin-top: 20px;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            background: #343a40;
            color: #fff;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }

        /* èŠå¤©å®¹å™¨æ ·å¼ */
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .chat-box {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #fff;
        }

        .input-area {
            padding: 15px;
            border-top: 1px solid #eee;
            background: #f8f9fa;
        }

        .input-controls {
            display: flex;
            gap: 10px;
        }

        #messageInput {
            flex: 1;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            resize: none; /* é˜²æ­¢ç”¨æˆ·æ‰‹åŠ¨è°ƒæ•´å¤§å° */
            min-height: 24px; /* ä¿æŒåˆå§‹é«˜åº¦ */
            max-height: 120px; /* é™åˆ¶æœ€å¤§é«˜åº¦ */
            overflow-y: auto; /* å¯ç”¨å‚ç›´æ»šåŠ¨ */
            font-family: inherit; /* ç»§æ‰¿çˆ¶å…ƒç´ å­—ä½“ */
            line-height: 1.4; /* è®¾ç½®è¡Œé«˜ */
        }

        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 70%;
            position: relative;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .sent {
            background: #dcf8c6;
            margin-left: auto;
            border-bottom-right-radius: 5px;
        }

        .received {
            background: #f1f0f0;
            margin-right: auto;
            border-bottom-left-radius: 5px;
        }

        .timestamp {
            font-size: 11px;
            color: #999;
            margin-top: 5px;
            text-align: right;
        }

        /* é“¾æ¥é¢„è§ˆæ ·å¼ */
        .link-preview {
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            background: #fff;
            transition: box-shadow 0.2s;
        }

        .link-preview:hover {
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .link-preview-loading {
            padding: 15px;
            text-align: center;
            color: #6c757d;
        }

        .link-preview-content {
            padding: 12px;
        }

        .link-preview-image {
            width: 100%;
            height: 150px;
            object-fit: cover;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .link-preview-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #343a40;
            font-size: 14px;
        }

        .link-preview-description {
            color: #6c757d;
            font-size: 13px;
            margin-bottom: 5px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .link-preview-domain {
            display: flex;
            align-items: center;
            color: #adb5bd;
            font-size: 12px;
            gap: 5px;
        }

        .preview-error {
            color: #dc3545;
            font-size: 12px;
        }

        /* å›¾ç‰‡é¢„è§ˆæ ·å¼ */
        .image-preview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            margin-top: 10px;
            cursor: pointer;
        }

        #imagePreviewContainer {
            margin-top: 10px;
            position: relative;
        }

        #imagePreviewContainer button {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 12px;
            padding: 5px 10px;
        }

        /* è¯­éŸ³æ¶ˆæ¯æ ·å¼ */
        .voice-message {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
        }

        .voice-message button {
            background: #6c5ce7;
            color: white;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            padding: 0;
        }

        .voice-wave {
            display: flex;
            align-items: center;
            gap: 2px;
            height: 20px;
        }

        .wave-bar {
            width: 3px;
            height: 100%;
            background: #6c5ce7;
            border-radius: 3px;
            animation: waveAnimation 1.5s infinite;
        }

        .wave-bar:nth-child(2) {
            animation-delay: 0.2s;
            height: 15px;
        }

        .wave-bar:nth-child(3) {
            animation-delay: 0.4s;
            height: 20px;
        }

        .wave-bar:nth-child(4) {
            animation-delay: 0.6s;
            height: 10px;
        }

        .wave-bar:nth-child(5) {
            animation-delay: 0.8s;
            height: 15px;
        }

        @keyframes waveAnimation {
            0%, 100% {
                transform: scaleY(1);
            }
            50% {
                transform: scaleY(0.6);
            }
        }

        .duration {
            font-size: 12px;
            color: #666;
        }

        #audioPreviewContainer {
            margin-top: 10px;
        }

        #audioPreviewContainer button:last-child {
            font-size: 12px;
            padding: 4px 8px;
            background: #dc3545;
        }

        .voice-record-button {
            position: relative;
            background: #6c5ce7 !important;
        }

        .voice-record-button.recording {
            background: #dc3545 !important;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
            }
        }

        .audio-timer {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #dc3545;
            white-space: nowrap;
        }


        /* åŠ è½½åŠ¨ç”» */
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0, 123, 255, 0.2);
            border-top-color: #007bff;
            border-radius: 50%;
            animation: spin 1s infinite linear;
            margin-right: 5px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* åœ¨headçš„styleæ ‡ç­¾ä¸­æ·»åŠ ä»¥ä¸‹CSSæ ·å¼ */

        /* é€šçŸ¥æ ·å¼ */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 350px;
            z-index: 9999;
        }

        .notification {
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            animation: notification-in 0.3s ease-out;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .notification-hide {
            transform: translateX(400px);
            opacity: 0;
        }

        @keyframes notification-in {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .notification-icon {
            margin-right: 10px;
            font-size: 18px;
        }

        .notification-message {
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
        }

        .notification-close {
            background: none;
            border: none;
            color: #999;
            font-size: 20px;
            line-height: 1;
            cursor: pointer;
            padding: 0 5px;
        }

        .notification-close:hover {
            color: #333;
        }

        .notification-info {
            border-left: 4px solid #2196F3;
        }

        .notification-warning {
            border-left: 4px solid #FF9800;
        }

        .notification-error {
            border-left: 4px solid #F44336;
        }

        .notification-success {
            border-left: 4px solid #4CAF50;
        }

        .input-area {
            padding: 15px;
            border-top: 1px solid #eee;
            background: #f8f9fa;
            display: flex;
            flex-direction: column;
        }

        .input-controls {
            display: flex;
            gap: 10px;
            align-items: flex-start; /* è°ƒæ•´ä¸ºé¡¶éƒ¨å¯¹é½ï¼Œæ›´é€‚åˆå¤šè¡Œæ–‡æœ¬ */
        }

        /* ç¡®ä¿æŒ‰é’®å’Œå¤šè¡Œæ–‡æœ¬æ¡†çš„å¯¹é½ */
        .input-controls button {
            margin-top: 2px; /* å¾®è°ƒæŒ‰é’®ä½ç½® */
        }

        /* å¦‚æœéœ€è¦å“åº”å¼è®¾è®¡è°ƒæ•´ */
        @media screen and (max-width: 576px) {
            #messageInput {
                max-height: 80px; /* åœ¨å°å±è®¾å¤‡ä¸Šå‡å°æœ€å¤§é«˜åº¦ */
            }
        }

        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 70%;
            position: relative;
            animation: fadeIn 0.3s;
            white-space: pre-wrap; /* ä¿ç•™ç©ºæ ¼å’Œæ¢è¡Œ */
            word-wrap: break-word; /* å…è®¸é•¿å•è¯æ¢è¡Œ */
            overflow-wrap: break-word; /* åŒä¸Šï¼Œæ›´å¥½çš„å…¼å®¹æ€§ */
        }

        .message > div {
            white-space: pre-wrap; /* ä¿ç•™ç©ºæ ¼å’Œæ¢è¡Œ */
            word-wrap: break-word; /* å…è®¸é•¿å•è¯æ¢è¡Œ */
        }

        /* è¿›å…¥èŠå¤©çª—å£æŒ‰é’®æ ·å¼ */
        .back-to-chat-btn {
            margin-bottom: 15px;
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }

        .back-to-chat-btn:hover {
            background: #218838;
        }



        /* ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šé»˜è®¤éšè—èŠå¤©ç•Œé¢ï¼Œåªæ˜¾ç¤ºè¿æ¥è®¾ç½® */
        @media screen and (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                min-width: 0;
                height: auto;
                max-height: none;
            }

            .chat-container {
                display: none; /* é»˜è®¤éšè—èŠå¤©ç•Œé¢ */
                height: 100vh;
            }

            /* è¿æ¥æˆåŠŸåçš„æ ·å¼ */
            .connected-mode .sidebar {
                display: none; /* è¿æ¥æˆåŠŸåéšè—ä¾§è¾¹æ  */
            }

            .connected-mode .chat-container {
                display: flex; /* è¿æ¥æˆåŠŸåæ˜¾ç¤ºèŠå¤©ç•Œé¢ */
                flex-direction: column;
                height: 100vh;
            }

            /* æ·»åŠ è¿”å›æŒ‰é’®æ ·å¼ */
            .back-to-settings {
                position: absolute;
                top: 10px;
                left: 10px;
                padding: 5px 10px;
                background: rgba(0, 0, 0, 0.1);
                border-radius: 4px;
                font-size: 12px;
                z-index: 100;
                display: none; /* é»˜è®¤éšè— */
            }

            .connected-mode .back-to-settings {
                display: block; /* è¿æ¥æ¨¡å¼ä¸‹æ˜¾ç¤º */
            }

            /* æ˜¾ç¤ºè¿”å›æŒ‰é’®æ ·å¼ */
            .sidebar.show-back-btn .back-to-chat-btn {
                display: block; /* è¿æ¥æˆåŠŸåæ˜¾ç¤ºè¿”å›æŒ‰é’® */
            }
        }

        /* å½“çª—å£å®½åº¦å¤§äº768pxæ—¶éšè— */
        @media screen and (min-width: 768px) {
            .back-to-chat-btn {
                display: none;
            }
            .back-to-settings{
                display: none;
            }
        }

        /* è§†é¢‘é€šè¯ç›¸å…³æ ·å¼ */
        .video-call-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .video-call-controls {
            position: absolute;
            bottom: 30px;
            display: flex;
            gap: 20px;
        }

        .video-call-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .end-call {
            background: #FF3B30;
        }

        .mute-audio {
            background: #fff;
        }

        .toggle-camera {
            background: #fff;
        }

        .video-streams {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #localVideo {
            position: absolute;
            width: 120px;
            height: 180px;
            right: 20px;
            top: 20px;
            object-fit: cover;
            border: 2px solid #fff;
            border-radius: 8px;
            z-index: 2;
        }

        /* è§†é¢‘é€šè¯è¯·æ±‚å¼¹çª— */
        .video-call-request {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: slide-down 0.3s ease-out;
        }

        @keyframes slide-down {
            from { transform: translateX(-50%) translateY(-100px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        .video-call-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #f0f0f0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #666;
        }

        .video-call-request-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            width: 100%;
        }

        .video-call-request-buttons button {
            flex: 1;
            padding: 10px;
            border-radius: 20px;
            border: none;
            font-weight: bold;
        }

        .accept-call {
            background: #4CD964;
            color: white;
        }

        .reject-call {
            background: #FF3B30;
            color: white;
        }

        /* è§†é¢‘é€šè¯æŒ‰é’® */
        .video-call-btn {
            background: #007AFF;
        }
        /* æ·»åŠ åˆ°ç°æœ‰çš„ style æ ‡ç­¾ä¸­ */
        .media-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 0 0 0 10px
        }

        .left-buttons {
            display: flex;
            gap: 10px;
        }

        .right-buttons {
            display: flex;
            gap: 10px;
        }

        .clear-chat-btn {
            background-color: #f44336;
        }

        .clear-chat-btn:hover {
            background-color: #d32f2f;
        }

        /* è°ƒæ•´è¾“å…¥æ§ä»¶çš„æ ·å¼ */
        .input-controls {
            display: flex;
            gap: 10px;
            align-items: flex-start;
            width: 100%;
        }

        .input-controls textarea {
            flex: 1;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="sidebar">
        <h2>è¿æ¥è®¾ç½®</h2>
        <button id="backToChatBtn" class="back-to-chat-btn">è¿›å…¥èŠå¤©çª—å£</button>
        <div class="status" id="connectionStatus">æœªè¿æ¥</div>
        <div class="network-info" id="networkInfo">
            ç½‘ç»œçŠ¶æ€: æ£€æµ‹ä¸­...
            <div class="connection-quality">
                <span>è¿æ¥è´¨é‡:</span>
                <div class="quality-indicator" id="qualityIndicator"></div>
                <span id="qualityText">æœªè¿æ¥</span>
            </div>
        </div>

        <div class="steps">
            <div class="step">
                <div class="step-number">1</div>
                <button onclick="ConnectionManager.createOffer()" id="createOfferBtn">åˆ›å»ºè¿æ¥è¯·æ±‚</button>
            </div>
            <div class="step">
                <div class="step-number">2</div>
                <button onclick="ConnectionManager.createAnswer()" id="createAnswerBtn">åˆ›å»ºè¿æ¥å“åº”</button>
            </div>
            <div class="step">
                <div class="step-number">3</div>
                <button onclick="ConnectionManager.handleAnswer()" id="handleAnswerBtn">å¤„ç†å¯¹æ–¹å“åº”</button>
            </div>
        </div>

        <div class="connection-info">
            <h3>è¿æ¥ä¿¡æ¯</h3>
            <textarea id="sdpText" placeholder="ç²˜è´´å¯¹æ–¹çš„è¿æ¥ä¿¡æ¯..."></textarea>
            <button onclick="UIManager.copyText()" class="copy-button">å¤åˆ¶è¿æ¥ä¿¡æ¯</button>
        </div>

        <div class="debug-info" id="debugInfo"></div>
    </div>

    <div class="chat-container">
        <!-- æ·»åŠ è¿”å›è®¾ç½®æŒ‰é’® -->
        <button class="back-to-settings" id="backToSettings">è¿”å›è¿æ¥è®¾ç½®</button>

        <div class="chat-box" id="chatBox"></div>

        <div class="input-area">
            <!-- æ·»åŠ åª’ä½“æŒ‰é’®è¡Œ -->
            <div class="media-controls">
                <div class="left-buttons">
                    <button class="upload-btn" onclick="document.getElementById('fileInput').click()" id="uploadButton" disabled>
                        å›¾ç‰‡
                    </button>
                    <button class="voice-record-button" id="voiceButton" disabled>
                        <span id="voiceButtonText">å½•éŸ³</span>
                        <span id="voiceTimer" class="audio-timer" style="display: none">00:00</span>
                    </button>
                    <button class="video-call-btn" id="videoCallButton" disabled onclick="VideoCallManager.initiateCall()">
                        è§†é¢‘
                    </button>
                </div>
                <div class="right-buttons">
                    <button class="clear-chat-btn" id="clearChatButton" onclick="MessageManager.clearChat()">
                        æ¸…ç©ºä¼šè¯
                    </button>
                </div>
            </div>

            <!-- æ–‡æœ¬è¾“å…¥è¡Œ -->
            <div class="input-controls">
                <label for="messageInput"></label><textarea id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯... (Ctrl+Enter å‘é€)" disabled></textarea>
                <button id="sendButton" disabled onclick="MessageManager.sendMessage()">å‘é€</button>
            </div>

            <input type="file" id="fileInput" accept="image/*" style="display: none"
                   onchange="MediaManager.handleImageSelect(event)">
            <div id="imagePreviewContainer"></div>
            <div id="audioPreviewContainer"></div>
        </div>
    </div>
</div>
<!-- è§†é¢‘é€šè¯è¯·æ±‚å¼¹çª— -->
<div id="videoCallRequest" class="video-call-request" style="display: none;">
    <div class="video-call-avatar">ğŸ‘¤</div>
    <h3>è§†é¢‘é€šè¯è¯·æ±‚</h3>
    <p>å¯¹æ–¹è¯·æ±‚ä¸æ‚¨è¿›è¡Œè§†é¢‘é€šè¯</p>
    <div class="video-call-request-buttons">
        <button class="reject-call" onclick="VideoCallManager.rejectCall()">æ‹’ç»</button>
        <button class="accept-call" onclick="VideoCallManager.acceptCall()">æ¥å—</button>
    </div>
</div>

<!-- è§†é¢‘é€šè¯ç•Œé¢ -->
<div id="videoCallContainer" class="video-call-container" style="display: none;">
    <div class="video-streams">
        <video id="remoteVideo" autoplay playsinline></video>
        <video id="localVideo" autoplay playsinline muted></video>
    </div>
    <div class="video-call-controls">
        <button class="video-call-button toggle-camera" id="toggleCameraBtn" onclick="VideoCallManager.toggleCamera()">
            ğŸ“¹
        </button>
        <button class="video-call-button mute-audio" id="toggleAudioBtn" onclick="VideoCallManager.toggleAudio()">
            ğŸ¤
        </button>
        <button class="video-call-button end-call" onclick="VideoCallManager.endCall()">
            ğŸ“
        </button>
    </div>
</div>
</body>

<script>
    // é…ç½®å¯¹è±¡
    const Config = {
        // ICEæœåŠ¡å™¨é…ç½®ï¼Œä¼˜å…ˆä½¿ç”¨ä¸­å›½æœåŠ¡å™¨
        iceServers: [
            // {
            //     // å›½å†…STUNæœåŠ¡å™¨
            //     urls: [
            //         'stun:stun.miwifi.com:3478',      // å°ç±³
            //         'stun:stun.qq.com:3478',          // è…¾è®¯
            //         'stun:stun.easemob.com:3478',     // ç¯ä¿¡
            //         'stun:stun.cloopen.com:3478',     // å®¹è”äº‘
            //         'stun:stun.aliyun.com:3478'       // é˜¿é‡Œäº‘ï¼ˆå¦‚å¯ç”¨ï¼‰
            //     ]
            // },
            // {
            //     // å›½å†…TURNæœåŠ¡å™¨ï¼ˆæ³¨ï¼šå®é™…é¡¹ç›®åº”ä½¿ç”¨è‡ªå·±çš„TURNæœåŠ¡å™¨ï¼‰
            //     urls: [
            //         'turn:turn.bluehost.cn:3478',
            //         'turn:turn.bluehost.cn:3478?transport=tcp'
            //     ],
            //     username: 'webrtc',
            //     credential: 'webrtc'
            // },
            {
                "urls": [
                    "turn:stun.evan-brass.net",
                    "turn:stun.evan-brass.net?transport=tcp",
                    "stun:stun.evan-brass.net"
                ],
                "username": "guest",
                "credential": "password"
            }
        ],

        // WebRTCé…ç½®
        peerConnectionConfig: {
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            iceCandidatePoolSize: 10,
            sdpSemantics: 'unified-plan'
        },

        // é‡è¿é…ç½®
        reconnect: {
            maxAttempts: 5,
            delay: 2000,
            backoffFactor: 1.5
        },

        // è¶…æ—¶é…ç½®
        timeouts: {
            iceGathering: 5000,  // æ›´ä½çš„è¶…æ—¶ï¼Œå¿«é€Ÿå¤±è´¥
            connection: 8000,
            networkCheck: 5000
        },

        // åª’ä½“é…ç½®
        media: {
            maxImageSize: 3 * 1024 * 1024,  // 3MB
            maxAudioDuration: 60,  // 60ç§’
            imageCompression: 0.7  // é»˜è®¤å‹ç¼©ç‡
        }
    };

    // å·¥å…·ç±»
    const Utils = {
        // æ—¥å¿—çº§åˆ«
        logLevels: {
            DEBUG: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3
        },

        // å½“å‰æ—¥å¿—çº§åˆ«
        currentLogLevel: 0,

        // è®°å½•æ—¥å¿—
        log: function (message, level = this.logLevels.DEBUG) {
            if (level >= this.currentLogLevel) {
                const debugInfo = document.getElementById('debugInfo');
                const timestamp = new Date().toLocaleTimeString();

                let prefix = '';
                switch (level) {
                    case this.logLevels.INFO:
                        prefix = '[ä¿¡æ¯] ';
                        break;
                    case this.logLevels.WARN:
                        prefix = '[è­¦å‘Š] ';
                        break;
                    case this.logLevels.ERROR:
                        prefix = '[é”™è¯¯] ';
                        break;
                    default:
                        prefix = '[è°ƒè¯•] ';
                }

                debugInfo.innerHTML = `[${timestamp}] ${prefix}${message}<br>` + debugInfo.innerHTML;

                // é™åˆ¶æ—¥å¿—æ¡æ•°
                const lines = debugInfo.innerHTML.split('<br>');
                if (lines.length > 10) {
                    debugInfo.innerHTML = lines.slice(0, 10).join('<br>');
                }

                // åœ¨æ§åˆ¶å°ä¹Ÿè®°å½•æ—¥å¿—
                if (level === this.logLevels.ERROR) {
                    console.error(message);
                } else if (level === this.logLevels.WARN) {
                    console.warn(message);
                } else {
                    console.log(message);
                }
            }
        },

        // å‹ç¼©å›¾ç‰‡
        compressImage: function (dataUrl, quality = Config.media.imageCompression) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // å¦‚æœå›¾ç‰‡å¾ˆå¤§ï¼ŒæŒ‰æ¯”ä¾‹ç¼©å°
                    let width = img.width;
                    let height = img.height;
                    const maxDimension = 1200;

                    if (width > maxDimension || height > maxDimension) {
                        if (width > height) {
                            height = Math.round((height / width) * maxDimension);
                            width = maxDimension;
                        } else {
                            width = Math.round((width / height) * maxDimension);
                            height = maxDimension;
                        }
                    }

                    canvas.width = width;
                    canvas.height = height;

                    // ç»˜åˆ¶å¹¶å‹ç¼©
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg', quality));
                };

                img.onerror = reject;
                img.src = dataUrl;
            });
        },

        // æ ¼å¼åŒ–æ—¶é—´
        formatTime: function (seconds) {
            const minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${minutes}:${secs}`;
        },

        // é˜²æŠ–å‡½æ•°
        debounce: function (func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        },

        // ç½‘ç»œç±»å‹æ£€æµ‹
        checkNetworkType: async function () {
            try {
                const pc = new RTCPeerConnection();
                const candidates = [];

                pc.onicecandidate = (e) => {
                    if (e.candidate) {
                        candidates.push(e.candidate);
                    }
                };

                await pc.createDataChannel("");
                await pc.createOffer().then(offer => pc.setLocalDescription(offer));
                await new Promise(r => setTimeout(r, 1000));

                pc.close();

                const hasIPv4 = candidates.some(c => c.address && c.address.indexOf('.') !== -1);
                const hasIPv6 = candidates.some(c => c.address && c.address.indexOf(':') !== -1);
                const hasRelay = candidates.some(c => c.type === 'relay');
                const hasUdp = candidates.some(c => c.protocol === 'udp');
                const hasTcp = candidates.some(c => c.protocol === 'tcp');

                return {
                    ipv4: hasIPv4,
                    ipv6: hasIPv6,
                    relay: hasRelay,
                    udp: hasUdp,
                    tcp: hasTcp,
                    count: candidates.length
                };
            } catch (error) {
                Utils.log(`ç½‘ç»œæ£€æµ‹å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                return null;
            }
        },

        // åˆ†å—å‘é€å¤§æ–‡ä»¶
        sendInChunks: function (data, sendFunc, chunkSize = 16 * 1024) {
            // å¦‚æœæ•°æ®å°äºé˜ˆå€¼ï¼Œç›´æ¥å‘é€
            if (data.length < chunkSize) {
                return sendFunc(data);
            }

            // å¦åˆ™åˆ†å—å‘é€
            const chunks = [];
            const totalChunks = Math.ceil(data.length / chunkSize);
            const fileId = new Date().getTime();

            for (let i = 0; i < totalChunks; i++) {
                const start = i * chunkSize;
                const end = Math.min(data.length, start + chunkSize);
                chunks.push(data.substring(start, end));
            }

            Utils.log(`æ–‡ä»¶è¿‡å¤§ï¼Œåˆ†ä¸º${totalChunks}å—å‘é€`, Utils.logLevels.INFO);

            // å‘é€å…ƒæ•°æ®
            sendFunc(JSON.stringify({
                type: 'file-meta',
                id: fileId,
                totalChunks: totalChunks
            }));

            // é€å—å‘é€
            chunks.forEach((chunk, index) => {
                setTimeout(() => {
                    sendFunc(JSON.stringify({
                        type: 'file-chunk',
                        id: fileId,
                        chunk: chunk,
                        index: index
                    }));
                }, index * 100); // æ·»åŠ å°å»¶è¿Ÿé¿å…å‘é€è¿‡å¿«
            });
        }
    };

    // äº‹ä»¶ç®¡ç†å™¨ï¼ˆè§‚å¯Ÿè€…æ¨¡å¼ï¼‰
    const EventEmitter = {
        events: {},

        // æ³¨å†Œäº‹ä»¶
        on: function (event, callback) {
            if (!this.events[event]) {
                this.events[event] = [];
            }
            this.events[event].push(callback);
        },

        // è§¦å‘äº‹ä»¶
        emit: function (event, ...args) {
            if (this.events[event]) {
                this.events[event].forEach(callback => {
                    try {
                        callback(...args);
                    } catch (e) {
                        Utils.log(`äº‹ä»¶å¤„ç†å‘ç”Ÿé”™è¯¯: ${e.message}`, Utils.logLevels.ERROR);
                    }
                });
            }
        },

        // ç§»é™¤äº‹ä»¶
        off: function (event, callback) {
            if (this.events[event]) {
                if (callback) {
                    this.events[event] = this.events[event].filter(cb => cb !== callback);
                } else {
                    delete this.events[event];
                }
            }
        }
    };

    // è¿æ¥ç®¡ç†å™¨
    const ConnectionManager = {
        peerConnection: null,
        dataChannel: null,
        iceCandidates: [],
        connectionTimeout: null,
        reconnectAttempts: 0,
        iceTimer: null,
        iceGatheringStartTime: null,
        connectionStrength: 0, // 0-100èŒƒå›´å†…çš„è¿æ¥å¼ºåº¦
        pendingChunks: {},

        // åˆå§‹åŒ–è¿æ¥
        init: function () {
            if (this.peerConnection) {
                this.close();
            }

            try {
                // åˆ›å»ºæ–°çš„é…ç½®ï¼ŒåŸºäºå½“å‰ç½‘ç»œçŠ¶å†µ
                let currentConfig = {...Config.peerConnectionConfig};
                currentConfig.iceServers = Config.iceServers;

                this.peerConnection = new RTCPeerConnection(currentConfig);

                this.peerConnection.onicecandidate = this.handleIceCandidate.bind(this);
                this.peerConnection.onicegatheringstatechange = this.handleIceGatheringStateChange.bind(this);
                this.peerConnection.oniceconnectionstatechange = this.handleIceConnectionStateChange.bind(this);
                this.peerConnection.ondatachannel = this.handleDataChannel.bind(this);

                this.iceCandidates = [];
                this.reconnectAttempts = 0;

                Utils.log('WebRTCè¿æ¥å·²åˆå§‹åŒ–', Utils.logLevels.INFO);
                return true;
            } catch (error) {
                Utils.log(`åˆå§‹åŒ–è¿æ¥å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                return false;
            }
        },

        // å¤„ç†ICEå€™é€‰è€…
        handleIceCandidate: function (event) {
            if (event.candidate) {
                this.iceCandidates.push(event.candidate);
                this.updateSdpText();
                Utils.log(`æ”¶é›†åˆ°ICEå€™é€‰: ${event.candidate.type} ${event.candidate.protocol}`, Utils.logLevels.DEBUG);

                // å¦‚æœè¿æ¥å·²å»ºç«‹ï¼Œå°è¯•å‘é€å€™é€‰è€…ç»™å¯¹æ–¹ï¼ˆå¯ç”¨Trickle ICEï¼‰
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.sendIceCandidate(event.candidate);
                }
            }
        },

        // å¤„ç†ICEæ”¶é›†çŠ¶æ€å˜åŒ–
        handleIceGatheringStateChange: function (event) {
            const state = this.peerConnection.iceGatheringState;

            switch (state) {
                case 'gathering':
                    UIManager.updateStatus('æ­£åœ¨æ”¶é›†ç½‘ç»œä¿¡æ¯...');
                    this.startIceTimer();
                    this.iceGatheringStartTime = Date.now();
                    break;

                case 'complete':
                    this.stopIceTimer();
                    const duration = (Date.now() - this.iceGatheringStartTime) / 1000;
                    UIManager.updateStatus(`ç½‘ç»œä¿¡æ¯æ”¶é›†å®Œæˆ (${duration.toFixed(1)}ç§’)`);
                    this.updateSdpText();
                    break;
            }
        },

        // å¤„ç†ICEè¿æ¥çŠ¶æ€å˜åŒ–
        handleIceConnectionStateChange: function () {
            const state = this.peerConnection.iceConnectionState;
            UIManager.updateStatus(`ICEçŠ¶æ€: ${state}`);

            switch (state) {
                case 'checking':
                    this.startConnectionTimeout();
                    EventEmitter.emit('connectionChecking');
                    break;

                case 'connected':
                    this.clearConnectionTimeout();
                    this.enableTrickleIce();
                    this.reconnectAttempts = this.calculateConnectionStrength();
                    UIManager.updateConnectionState(true);
                    EventEmitter.emit('connectionEstablished');
                    break;

                case 'disconnected':
                    this.handleDisconnection();
                    EventEmitter.emit('connectionDisconnected');
                    break;

                case 'failed':
                    this.handleConnectionFailure();
                    EventEmitter.emit('connectionFailed');
                    break;

                case 'closed':
                    UIManager.updateConnectionState(false);
                    EventEmitter.emit('connectionClosed');
                    break;
            }
        },

        // å¤„ç†æ•°æ®é€šé“
        handleDataChannel: function (event) {
            this.setupDataChannel(event.channel);
        },

        // å¯åŠ¨ICEæ”¶é›†è®¡æ—¶å™¨
        startIceTimer: function () {
            this.stopIceTimer();
            this.iceTimer = setTimeout(() => {
                if (this.peerConnection && this.peerConnection.iceGatheringState !== 'complete') {
                    Utils.log('ICEæ”¶é›†è¶…æ—¶ï¼Œä½¿ç”¨å½“å‰å¯ç”¨è¿æ¥', Utils.logLevels.WARN);
                    UIManager.updateStatus('ç½‘ç»œä¿¡æ¯æ”¶é›†è¶…æ—¶ï¼Œä½¿ç”¨å½“å‰å¯ç”¨è¿æ¥');
                    this.updateSdpText();
                }
            }, Config.timeouts.iceGathering);
        },

        // åœæ­¢ICEæ”¶é›†è®¡æ—¶å™¨
        stopIceTimer: function () {
            if (this.iceTimer) {
                clearTimeout(this.iceTimer);
                this.iceTimer = null;
            }
        },

        // å¯åŠ¨è¿æ¥è¶…æ—¶
        startConnectionTimeout: function () {
            this.clearConnectionTimeout();
            this.connectionTimeout = setTimeout(() => {
                if (this.peerConnection && this.peerConnection.iceConnectionState === 'checking') {
                    Utils.log('è¿æ¥å»ºç«‹è¶…æ—¶', Utils.logLevels.WARN);
                    this.handleConnectionFailure();
                }
            }, Config.timeouts.connection);
        },

        // æ¸…é™¤è¿æ¥è¶…æ—¶
        clearConnectionTimeout: function () {
            if (this.connectionTimeout) {
                clearTimeout(this.connectionTimeout);
                this.connectionTimeout = null;
            }
        },

        // å¤„ç†è¿æ¥å¤±è´¥
        handleConnectionFailure: function () {
            UIManager.updateStatus('è¿æ¥å¤±è´¥');
            UIManager.updateConnectionState(false);

            if (this.reconnectAttempts < Config.reconnect.maxAttempts) {
                const delay = Config.reconnect.delay * Math.pow(Config.reconnect.backoffFactor, this.reconnectAttempts);
                this.reconnectAttempts++;

                UIManager.updateStatus(`æ­£åœ¨å°è¯•é‡æ–°è¿æ¥ (${this.reconnectAttempts}/${Config.reconnect.maxAttempts})...`, delay);

                setTimeout(() => {
                    this.restartIceWithRelay();
                }, delay);
            } else {
                UIManager.updateStatus('è¿æ¥å¤±è´¥ï¼Œè¯·é‡æ–°å¼€å§‹è¿æ¥æµç¨‹');
                this.resetConnection();
            }
        },

        // å¤„ç†è¿æ¥æ–­å¼€
        handleDisconnection: function () {
            UIManager.updateStatus('è¿æ¥æ–­å¼€ï¼Œå°è¯•é‡è¿...');
            UIManager.updateConnectionState(false, 'disconnected');

            // ä½¿ç”¨æŒ‡æ•°é€€é¿é‡è¿
            const delay = 1000;
            setTimeout(() => {
                if (this.peerConnection && this.peerConnection.iceConnectionState === 'disconnected') {
                    this.restartIce();
                }
            }, delay);
        },

        // ä½¿ç”¨ä¸­ç»§æœåŠ¡å™¨é‡å¯ICE
        restartIceWithRelay: async function () {
            try {
                if (!this.peerConnection) {
                    throw new Error('æ²¡æœ‰æ´»åŠ¨çš„è¿æ¥');
                }

                // è°ƒæ•´é…ç½®ï¼Œå¼ºåˆ¶ä½¿ç”¨ä¸­ç»§
                const relayConfig = {
                    ...Config.peerConnectionConfig,
                    iceTransportPolicy: 'relay'
                };
                relayConfig.iceServers = Config.iceServers;

                this.peerConnection.setConfiguration(relayConfig);

                Utils.log('æ­£åœ¨ä½¿ç”¨ä¸­ç»§æœåŠ¡å™¨é‡æ–°åå•†è¿æ¥', Utils.logLevels.INFO);

                if (this.peerConnection.signalingState === 'stable') {
                    const offer = await this.peerConnection.createOffer({iceRestart: true});
                    await this.peerConnection.setLocalDescription(offer);
                    UIManager.updateStatus('æ­£åœ¨å°è¯•ä½¿ç”¨ä¸­ç»§æœåŠ¡å™¨é‡è¿...');
                    this.updateSdpText();
                }
            } catch (error) {
                Utils.log(`é‡è¿å°è¯•å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                // ç»§ç»­å°è¯•ä¸‹ä¸€æ¬¡é‡è¿æˆ–æœ€ç»ˆæ”¾å¼ƒ
                this.handleConnectionFailure();
            }
        },

        // æ ‡å‡†ICEé‡å¯
        restartIce: async function () {
            try {
                if (!this.peerConnection || this.peerConnection.signalingState !== 'stable') {
                    return;
                }

                Utils.log('æ­£åœ¨å°è¯•ICEé‡å¯', Utils.logLevels.INFO);

                const offer = await this.peerConnection.createOffer({iceRestart: true});
                await this.peerConnection.setLocalDescription(offer);

                this.updateSdpText();
                UIManager.updateStatus('æ­£åœ¨åå•†é‡æ–°è¿æ¥...');
            } catch (error) {
                Utils.log(`ICEé‡å¯å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
            }
        },

        // å¯ç”¨Trickle ICEï¼ˆå®æ—¶å‘é€ICEå€™é€‰è€…ï¼‰
        enableTrickleIce: function () {
            Utils.log('å¯ç”¨Trickle ICE', Utils.logLevels.DEBUG);
            // å·²åœ¨handleIceCandidateå¤„ç†
        },

        // å‘é€ICEå€™é€‰è€…
        sendIceCandidate: function (candidate) {
            if (this.dataChannel && this.dataChannel.readyState === 'open') {
                try {
                    const message = {
                        type: 'ice-candidate',
                        candidate: candidate
                    };
                    this.dataChannel.send(JSON.stringify(message));
                    Utils.log('å·²å‘é€ICEå€™é€‰', Utils.logLevels.DEBUG);
                } catch (error) {
                    Utils.log(`å‘é€ICEå€™é€‰å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                }
            }
        },

        // è®¾ç½®æ•°æ®é€šé“
        setupDataChannel: function (channel) {
            this.dataChannel = channel;

            this.dataChannel.onopen = () => {
                Utils.log('æ•°æ®é€šé“å·²æ‰“å¼€', Utils.logLevels.INFO);
                UIManager.updateStatus("è¿æ¥å·²å»ºç«‹ï¼Œå¯ä»¥å¼€å§‹èŠå¤©");
                UIManager.enableChatInterface(true);
                EventEmitter.emit('dataChannelOpen');

                // é¦–æ¬¡è¿æ¥æˆåŠŸåè‡ªåŠ¨äº¤æ¢æ›´å¤šICEå€™é€‰
                this.enableTrickleIce();

                // å¼€å§‹è¿æ¥è´¨é‡ç›‘æ§
                this.startConnectionMonitoring();
            };

            this.dataChannel.onclose = () => {
                Utils.log('æ•°æ®é€šé“å·²å…³é—­', Utils.logLevels.INFO);
                UIManager.updateStatus("è¿æ¥å·²å…³é—­");
                UIManager.enableChatInterface(false);
                EventEmitter.emit('dataChannelClosed');
            };

            this.dataChannel.onmessage = (event) => {
                try {
                    // å°è¯•è§£æJSONæ¶ˆæ¯
                    const message = JSON.parse(event.data);

                    // æ£€æŸ¥æ˜¯å¦æ˜¯è§†é¢‘é€šè¯ç›¸å…³æ¶ˆæ¯
                    if (message.type && message.type.startsWith('video-call-')) {
                        VideoCallManager.handleMessage(message);
                        return;
                    }

                    switch (message.type) {
                        case 'ice-candidate':
                            this.handleIncomingIceCandidate(message.candidate);
                            break;

                        case 'file-meta':
                            // åˆå§‹åŒ–æ–‡ä»¶å—æ”¶é›†
                            this.pendingChunks[message.id] = {
                                chunks: new Array(message.totalChunks),
                                received: 0,
                                total: message.totalChunks
                            };
                            break;

                        case 'file-chunk':
                            // æ”¶é›†æ–‡ä»¶å—
                            if (this.pendingChunks[message.id]) {
                                this.pendingChunks[message.id].chunks[message.index] = message.chunk;
                                this.pendingChunks[message.id].received++;

                                // æ£€æŸ¥æ˜¯å¦å·²æ”¶åˆ°æ‰€æœ‰å—
                                if (this.pendingChunks[message.id].received === this.pendingChunks[message.id].total) {
                                    const completeData = this.pendingChunks[message.id].chunks.join('');
                                    delete this.pendingChunks[message.id];

                                    // è§£æå¹¶æ˜¾ç¤ºå®Œæ•´æ¶ˆæ¯
                                    const fullMessage = JSON.parse(completeData);
                                    MessageManager.displayMessage(fullMessage, false);
                                }
                            }
                            break;

                        default:
                            // æ™®é€šæ¶ˆæ¯ç›´æ¥æ˜¾ç¤º
                            MessageManager.displayMessage(message, false);
                    }
                } catch (e) {
                    // å¦‚æœä¸æ˜¯JSONï¼Œä½œä¸ºæ™®é€šæ–‡æœ¬æ˜¾ç¤º
                    MessageManager.displayMessage(event.data, false);
                }
            };

            this.dataChannel.onerror = (error) => {
                Utils.log(`æ•°æ®é€šé“é”™è¯¯: ${error.message || 'æœªçŸ¥é”™è¯¯'}`, Utils.logLevels.ERROR);
                EventEmitter.emit('dataChannelError', error);
            };
        },

        // å¤„ç†æ¥æ”¶åˆ°çš„ICEå€™é€‰è€…
        handleIncomingIceCandidate: async function (candidate) {
            try {
                if (this.peerConnection) {
                    await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    Utils.log('å·²æ·»åŠ è¿œç¨‹ICEå€™é€‰', Utils.logLevels.DEBUG);
                }
            } catch (error) {
                Utils.log(`æ·»åŠ è¿œç¨‹ICEå€™é€‰å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
            }
        },

        // å¼€å§‹è¿æ¥è´¨é‡ç›‘æµ‹
        startConnectionMonitoring: function () {
            setInterval(async () => {
                if (this.peerConnection && this.dataChannel && this.dataChannel.readyState === 'open') {
                    try {
                        const stats = await this.peerConnection.getStats();
                        let currentRoundTripTime = null;
                        let bytesReceived = 0;
                        let bytesSent = 0;
                        let localCandidateType = null;
                        let remoteCandidateType = null;

                        stats.forEach(report => {
                            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                                currentRoundTripTime = report.currentRoundTripTime;
                                // ä¿å­˜UDPæˆ–TCPè¿æ¥ç±»å‹
                                if (report.localCandidateId && report.remoteCandidateId) {
                                    stats.forEach(s => {
                                        if (s.id === report.localCandidateId) {
                                            localCandidateType = `${s.candidateType}/${s.protocol}`;
                                        }
                                        if (s.id === report.remoteCandidateId) {
                                            remoteCandidateType = `${s.candidateType}/${s.protocol}`;
                                        }
                                    });
                                }
                            }

                            if (report.type === 'data-channel') {
                                bytesReceived += report.bytesReceived || 0;
                                bytesSent += report.bytesSent || 0;
                            }
                        });

                        // åªåœ¨æœ‰æ•ˆRTTæ—¶æ›´æ–°è¿æ¥è´¨é‡
                        if (currentRoundTripTime !== null) {
                            UIManager.updateConnectionQuality(currentRoundTripTime);
                            this.connectionStrength = this.calculateConnectionStrength(currentRoundTripTime);

                            Utils.log(`è¿æ¥ç›‘æµ‹: RTT=${currentRoundTripTime.toFixed(3)}s, æœ¬åœ°=${localCandidateType}, è¿œç¨‹=${remoteCandidateType}, ä¼ è¾“=${bytesReceived + bytesSent}å­—èŠ‚`,
                                Utils.logLevels.DEBUG);

                            // å¦‚æœè¿æ¥è´¨é‡å¾ˆå·®ï¼Œå°è¯•é‡æ–°åå•†
                            if (currentRoundTripTime > 1.5 && this.connectionStrength < 30) {
                                this.considerReconnection();
                            }
                        }
                    } catch (error) {
                        Utils.log(`è·å–è¿æ¥ç»Ÿè®¡å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                    }
                }
            }, Config.timeouts.networkCheck);
        },

        // è®¡ç®—è¿æ¥å¼ºåº¦ (0-100)
        calculateConnectionStrength: function (rtt = null) {
            if (!this.peerConnection) return 0;

            let strength = 0;

            // åŸºäºICEè¿æ¥çŠ¶æ€
            switch (this.peerConnection.iceConnectionState) {
                case 'connected':
                    strength += 60;
                    break;
                case 'completed':
                    strength += 70;
                    break;
                case 'checking':
                    strength += 30;
                    break;
                case 'disconnected':
                    strength += 10;
                    break;
                default:
                    strength += 0;
            }

            // å¦‚æœRTTå¯ç”¨ï¼Œæ ¹æ®å»¶è¿Ÿè°ƒæ•´
            if (rtt !== null) {
                if (rtt < 0.1) strength += 30;
                else if (rtt < 0.3) strength += 20;
                else if (rtt < 0.7) strength += 10;
                else if (rtt > 1.0) strength -= 20;
            }

            // ç¡®ä¿åœ¨0-100èŒƒå›´å†…
            return Math.max(0, Math.min(100, strength));
        },

        // åœ¨è¿æ¥è´¨é‡å·®æ—¶è€ƒè™‘é‡è¿
        considerReconnection: function () {
            if (this.reconnectAttempts < Config.reconnect.maxAttempts) {
                Utils.log('æ£€æµ‹åˆ°è¿æ¥è´¨é‡å·®ï¼Œå°è¯•é‡æ–°åå•†...', Utils.logLevels.WARN);
                this.restartIce();
            }
        },

        // æ›´æ–°SDPæ–‡æœ¬
        updateSdpText: function () {
            if (!this.peerConnection || !this.peerConnection.localDescription) {
                return;
            }

            const connectionInfo = {
                sdp: this.peerConnection.localDescription,
                candidates: this.iceCandidates
            };

            document.getElementById('sdpText').value = JSON.stringify(connectionInfo);
        },

        // é‡ç½®è¿æ¥
        resetConnection: function () {
            if (this.peerConnection) {
                this.peerConnection.close();
            }

            this.peerConnection = null;
            this.dataChannel = null;
            this.iceCandidates = [];
            this.reconnectAttempts = 0;

            UIManager.resetConnectionControls();
        },

        // å…³é—­è¿æ¥
        close: function () {
            this.stopIceTimer();
            this.clearConnectionTimeout();

            if (this.dataChannel) {
                try {
                    this.dataChannel.close();
                } catch (e) {
                    // å¿½ç•¥å…³é—­é”™è¯¯
                }
                this.dataChannel = null;
            }

            if (this.peerConnection) {
                try {
                    this.peerConnection.close();
                } catch (e) {
                    // å¿½ç•¥å…³é—­é”™è¯¯
                }
                this.peerConnection = null;
            }

            UIManager.updateStatus('è¿æ¥å·²å…³é—­');
            UIManager.enableChatInterface(false);
        },

        // åˆ›å»ºè¿æ¥è¯·æ±‚
        createOffer: async function () {
            if (!UIManager.checkWebRTCSupport()) return;

            try {
                if (!this.init()) {
                    throw new Error('æ— æ³•åˆå§‹åŒ–WebRTCè¿æ¥');
                }

                // åˆ›å»ºæ•°æ®é€šé“
                this.dataChannel = this.peerConnection.createDataChannel("messageChannel", {
                    ordered: true,
                    maxRetransmits: 30
                });

                this.setupDataChannel(this.dataChannel);

                // åˆ›å»ºoffer
                const offer = await this.peerConnection.createOffer({
                    offerToReceiveAudio: false,
                    offerToReceiveVideo: false
                });

                await this.peerConnection.setLocalDescription(offer);
                UIManager.updateStatus("æ­£åœ¨æ”¶é›†ç½‘ç»œä¿¡æ¯...");

                // çŸ­æš‚å»¶è¿Ÿåæ›´æ–°SDPï¼ˆè®©ICEæ”¶é›†å¼€å§‹ï¼‰
                setTimeout(() => this.updateSdpText(), 1000);

                UIManager.disableConnectionButtons('offer');
            } catch (error) {
                Utils.log(`åˆ›å»ºè¿æ¥è¯·æ±‚å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.updateStatus('åˆ›å»ºè¿æ¥è¯·æ±‚å¤±è´¥');
            }
        },

        // åˆ›å»ºè¿æ¥å“åº”
        createAnswer: async function () {
            try {
                if (!this.init()) {
                    throw new Error('æ— æ³•åˆå§‹åŒ–WebRTCè¿æ¥');
                }

                // è§£æå¯¹æ–¹çš„SDP
                const sdpText = document.getElementById('sdpText').value.trim();
                if (!sdpText) {
                    throw new Error('è¯·å…ˆç²˜è´´å¯¹æ–¹çš„è¿æ¥ä¿¡æ¯');
                }

                const offerData = JSON.parse(sdpText);

                if (!offerData.sdp) {
                    throw new Error('æ— æ•ˆçš„è¿æ¥ä¿¡æ¯æ ¼å¼');
                }

                // è®¾ç½®è¿œç¨‹æè¿°
                await this.peerConnection.setRemoteDescription(new RTCSessionDescription(offerData.sdp));

                // æ·»åŠ ICEå€™é€‰è€…
                if (offerData.candidates && offerData.candidates.length > 0) {
                    for (const candidate of offerData.candidates) {
                        await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                }

                // åˆ›å»ºåº”ç­”
                const answer = await this.peerConnection.createAnswer();
                await this.peerConnection.setLocalDescription(answer);

                UIManager.updateStatus("æ­£åœ¨æ”¶é›†ç½‘ç»œä¿¡æ¯...");

                // çŸ­æš‚å»¶è¿Ÿåæ›´æ–°SDP
                setTimeout(() => this.updateSdpText(), 1000);

                UIManager.disableConnectionButtons('answer');
            } catch (error) {
                Utils.log(`åˆ›å»ºè¿æ¥å“åº”å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.updateStatus(`åˆ›å»ºè¿æ¥å“åº”å¤±è´¥: ${error.message}`);
            }
        },

        // å¤„ç†è¿æ¥å“åº”
        handleAnswer: async function () {
            try {
                if (!this.peerConnection) {
                    throw new Error('æœªåˆ›å»ºè¿æ¥ï¼Œè¯·å…ˆæ‰§è¡Œæ­¥éª¤1');
                }

                // è§£æå¯¹æ–¹çš„SDP
                const sdpText = document.getElementById('sdpText').value.trim();
                if (!sdpText) {
                    throw new Error('è¯·å…ˆç²˜è´´å¯¹æ–¹çš„è¿æ¥ä¿¡æ¯');
                }

                const answerData = JSON.parse(sdpText);

                if (!answerData.sdp) {
                    throw new Error('æ— æ•ˆçš„è¿æ¥ä¿¡æ¯æ ¼å¼');
                }

                // è®¾ç½®è¿œç¨‹æè¿°
                await this.peerConnection.setRemoteDescription(new RTCSessionDescription(answerData.sdp));

                // æ·»åŠ ICEå€™é€‰è€…
                if (answerData.candidates && answerData.candidates.length > 0) {
                    for (const candidate of answerData.candidates) {
                        await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                }

                UIManager.updateStatus("æ­£åœ¨å»ºç«‹è¿æ¥...");
                UIManager.disableConnectionButtons('complete');
            } catch (error) {
                Utils.log(`å¤„ç†è¿æ¥å“åº”å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.updateStatus(`å¤„ç†è¿æ¥å“åº”å¤±è´¥: ${error.message}`);
            }
        }
    };

    // UI ç®¡ç†å™¨
    const UIManager = {
        // æ›´æ–°è¿æ¥çŠ¶æ€æ˜¾ç¤º
        updateConnectionState: function (connected, state = '') {
            const statusElement = document.getElementById('connectionStatus');
            if (connected) {
                statusElement.classList.add('connected');
                statusElement.classList.remove('disconnected');
            } else {
                if (state === 'disconnected') {
                    statusElement.classList.add('disconnected');
                } else {
                    statusElement.classList.remove('connected');
                }
            }
        },

        // å¯ç”¨/ç¦ç”¨èŠå¤©ç•Œé¢
        enableChatInterface: function(enabled) {
            const messageInput = document.getElementById('messageInput');
            const sendButton = document.getElementById('sendButton');
            const uploadButton = document.getElementById('uploadButton');
            const voiceButton = document.getElementById('voiceButton');
            const videoCallButton = document.getElementById('videoCallButton');
            const clearChatButton = document.getElementById('clearChatButton');

            messageInput.disabled = !enabled;
            sendButton.disabled = !enabled;
            uploadButton.disabled = !enabled;
            voiceButton.disabled = !enabled;
            videoCallButton.disabled = !enabled;
            clearChatButton.disabled = !enabled;

            if (enabled) {
                // èšç„¦è¾“å…¥æ¡†
                setTimeout(() => messageInput.focus(), 300);
            }
        },

        // æ›´æ–°è¿æ¥çŠ¶æ€æ–‡æœ¬
        updateStatus: function (message, delay = 0) {
            const statusElement = document.getElementById('connectionStatus');

            if (delay > 0) {
                // å¦‚æœæœ‰å»¶è¿Ÿï¼Œæ˜¾ç¤ºå€’è®¡æ—¶
                statusElement.innerHTML = `${message} <span class="loading-spinner"></span>`;

                let countdown = Math.floor(delay / 1000);
                const timer = setInterval(() => {
                    countdown--;
                    if (countdown <= 0) {
                        clearInterval(timer);
                        statusElement.textContent = message;
                    } else {
                        statusElement.innerHTML = `${message} (${countdown}ç§’) <span class="loading-spinner"></span>`;
                    }
                }, 1000);
            } else {
                statusElement.textContent = message;
            }
        },

        // æ›´æ–°è¿æ¥è´¨é‡æŒ‡ç¤ºå™¨
        updateConnectionQuality: function (rtt) {
            const indicator = document.getElementById('qualityIndicator');
            const qualityText = document.getElementById('qualityText');

            if (!indicator || !qualityText) return;

            try {
                if (rtt < 0.3) {
                    indicator.className = 'quality-indicator quality-good';
                    qualityText.textContent = 'è‰¯å¥½';
                } else if (rtt < 0.8) {
                    indicator.className = 'quality-indicator quality-medium';
                    qualityText.textContent = 'ä¸€èˆ¬';
                } else {
                    indicator.className = 'quality-indicator quality-poor';
                    qualityText.textContent = 'è¾ƒå·®';
                }
            } catch (error) {
                Utils.log(`æ›´æ–°è¿æ¥è´¨é‡æ˜¾ç¤ºå¤±è´¥: ${error}`, Utils.logLevels.ERROR);
            }
        },

        // ç¦ç”¨è¿æ¥æŒ‰é’®
        disableConnectionButtons: function (stage) {
            switch (stage) {
                case 'offer':
                    document.getElementById('createOfferBtn').disabled = true;
                    document.getElementById('createAnswerBtn').disabled = true;
                    document.getElementById('handleAnswerBtn').disabled = false;
                    break;

                case 'answer':
                    document.getElementById('createOfferBtn').disabled = true;
                    document.getElementById('createAnswerBtn').disabled = true;
                    document.getElementById('handleAnswerBtn').disabled = true;
                    break;

                case 'complete':
                    document.getElementById('createOfferBtn').disabled = true;
                    document.getElementById('createAnswerBtn').disabled = true;
                    document.getElementById('handleAnswerBtn').disabled = true;
                    break;
            }
        },

        // é‡ç½®è¿æ¥æ§ä»¶
        resetConnectionControls: function () {
            document.getElementById('createOfferBtn').disabled = false;
            document.getElementById('createAnswerBtn').disabled = false;
            document.getElementById('handleAnswerBtn').disabled = false;
            document.getElementById('backToChatBtn').style.display = 'none';
            document.querySelector('.sidebar').classList.remove('show-back-btn');
            this.enableChatInterface(false);

            // ç§»åŠ¨ç«¯ï¼šåˆ‡æ¢å›è¿æ¥è®¾ç½®ç•Œé¢
            if (window.innerWidth <= 768) {
                document.querySelector('.container').classList.remove('connected-mode');
            }
        },

        // å¤åˆ¶æ–‡æœ¬
        copyText: function () {
            const textarea = document.getElementById('sdpText');
            textarea.select();
            document.execCommand('copy');

            const copyButton = document.querySelector('.copy-button');
            const originalText = copyButton.textContent;

            copyButton.textContent = 'å·²å¤åˆ¶ï¼';
            setTimeout(() => {
                copyButton.textContent = originalText;
            }, 2000);
        },

        // æ£€æŸ¥WebRTCæ”¯æŒ
        checkWebRTCSupport: function () {
            if (typeof RTCPeerConnection === 'undefined') {
                this.updateStatus('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ WebRTCï¼Œè¯·ä½¿ç”¨ Chrome ç­‰ç°ä»£æµè§ˆå™¨');
                Utils.log('æµè§ˆå™¨ä¸æ”¯æŒWebRTC', Utils.logLevels.ERROR);
                return false;
            }

            if (typeof navigator.mediaDevices === 'undefined' ||
                typeof navigator.mediaDevices.getUserMedia === 'undefined') {
                Utils.log('æµè§ˆå™¨å¯èƒ½ä¸å®Œå…¨æ”¯æŒåª’ä½“è®¾å¤‡API', Utils.logLevels.WARN);
            }

            return true;
        },

        // æ˜¾ç¤ºé€šçŸ¥æ¶ˆæ¯
        showNotification: function (message, type = 'info') {
            // åˆ›å»ºé€šçŸ¥å…ƒç´ 
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;

            // è®¾ç½®å›¾æ ‡
            let icon = '';
            switch (type) {
                case 'warning':
                    icon = 'âš ï¸';
                    break;
                case 'error':
                    icon = 'âŒ';
                    break;
                case 'success':
                    icon = 'âœ…';
                    break;
                default:
                    icon = 'â„¹ï¸';
            }

            notification.innerHTML = `
                <span class="notification-icon">${icon}</span>
                <span class="notification-message">${message}</span>
                <button class="notification-close">Ã—</button>
            `;

            // æ·»åŠ åˆ°ç•Œé¢
            if (!document.querySelector('.notification-container')) {
                const container = document.createElement('div');
                container.className = 'notification-container';
                document.body.appendChild(container);
            }

            const container = document.querySelector('.notification-container');
            container.appendChild(notification);

            // ç‚¹å‡»å…³é—­æŒ‰é’®ç§»é™¤é€šçŸ¥
            notification.querySelector('.notification-close').addEventListener('click', () => {
                notification.classList.add('notification-hide');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }

                    // å¦‚æœå®¹å™¨ä¸ºç©ºï¼Œç§»é™¤å®¹å™¨
                    if (container.children.length === 0) {
                        container.parentNode.removeChild(container);
                    }
                }, 300);
            });

            // è‡ªåŠ¨å…³é—­
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.add('notification-hide');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }

                        // å¦‚æœå®¹å™¨ä¸ºç©ºï¼Œç§»é™¤å®¹å™¨
                        if (container.children.length === 0) {
                            container.parentNode.removeChild(container);
                        }
                    }, 300);
                }
            }, 10000); // 10ç§’åè‡ªåŠ¨å…³é—­
        }

    };

    // æ¶ˆæ¯ç®¡ç†å™¨
    const MessageManager = {
        selectedImage: null,
        audioData: null,
        audioDuration: 0,

        // å‘é€æ¶ˆæ¯
        sendMessage: function() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            if ((!message && !this.selectedImage && !this.audioData) ||
                !ConnectionManager.dataChannel ||
                ConnectionManager.dataChannel.readyState !== 'open') {
                return;
            }

            // å‘é€è¯­éŸ³æ¶ˆæ¯
            if (this.audioData) {
                const audioMessage = {
                    type: 'audio',
                    data: this.audioData,
                    duration: this.audioDuration
                };

                Utils.sendInChunks(JSON.stringify(audioMessage),
                    (data) => ConnectionManager.dataChannel.send(data));

                this.displayMessage(audioMessage, true);
                this.cancelAudioData(); // è¿™é‡Œä¼šè°ƒç”¨ MediaManager.releaseAudioResources()
            }

            // å‘é€å›¾ç‰‡æ¶ˆæ¯
            if (this.selectedImage) {
                const imageMessage = {
                    type: 'image',
                    data: this.selectedImage
                };

                Utils.sendInChunks(JSON.stringify(imageMessage),
                    (data) => ConnectionManager.dataChannel.send(data));

                this.displayMessage(imageMessage, true);
                this.cancelImageData();
            }

            // å‘é€æ–‡æœ¬æ¶ˆæ¯
            if (message) {
                const urlRegex = /(https?:\/\/[^\s]+)/g;
                const messageObj = {
                    type: 'text',
                    content: message, // ç›´æ¥ä½¿ç”¨åŸå§‹æ¶ˆæ¯ï¼ŒåŒ…å«æ¢è¡Œç¬¦
                    links: message.match(urlRegex) || [],
                    timestamp: new Date().toISOString()
                };

                ConnectionManager.dataChannel.send(JSON.stringify(messageObj));
                this.displayMessage(messageObj, true);
                input.value = '';
            }
        },

        // æ¸…ç©ºèŠå¤©è®°å½•
        clearChat: function() {
            // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                // æ¸…ç©ºèŠå¤©åŒºåŸŸ
                const chatBox = document.getElementById('chatBox');
                chatBox.innerHTML = '';

                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯æç¤º
                const systemMessage = document.createElement('div');
                systemMessage.className = 'system-message';
                systemMessage.textContent = 'å·²æ¸…ç©ºèŠå¤©è®°å½•';
                systemMessage.style.textAlign = 'center';
                systemMessage.style.padding = '10px';
                systemMessage.style.color = '#666';
                systemMessage.style.fontSize = '12px';
                chatBox.appendChild(systemMessage);

                // é€šçŸ¥ç”¨æˆ·
                UIManager.showNotification('èŠå¤©è®°å½•å·²æ¸…ç©º', 'info');

                Utils.log('èŠå¤©è®°å½•å·²æ¸…ç©º', Utils.logLevels.INFO);
            }
        },

        // æ˜¾ç¤ºæ¶ˆæ¯
        displayMessage: function (message, isSent) {
            const chatBox = document.getElementById('chatBox');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;

            if (typeof message === 'string') {
                // å¤„ç†çº¯æ–‡æœ¬æ¶ˆæ¯ï¼Œå°†æ¢è¡Œç¬¦è½¬æ¢ä¸º<br>æ ‡ç­¾
                messageDiv.innerHTML = this.formatMessageText(message);
            } else {
                switch (message.type) {
                    case 'audio':
                        const audioDiv = document.createElement('div');
                        audioDiv.className = 'voice-message';

                        // æ ¼å¼åŒ–éŸ³é¢‘æŒç»­æ—¶é—´
                        const formattedDuration = typeof message.duration === 'number'
                            ? Utils.formatTime(message.duration)
                            : message.duration;

                        audioDiv.innerHTML = `
                    <button onclick="event.stopPropagation(); MediaManager.playAudio(this)" data-audio="${message.data}">
                        æ’­æ”¾
                    </button>
                    <div class="voice-wave">
                        ${Array(5).fill('<div class="wave-bar"></div>').join('')}
                    </div>
                    <span class="duration">${formattedDuration}</span>
                `;
                        messageDiv.appendChild(audioDiv);
                        break;

                    case 'image':
                        const img = document.createElement('img');
                        img.src = message.data;
                        img.className = 'image-preview';
                        img.onclick = () => {
                            // ç‚¹å‡»å›¾ç‰‡æ—¶æ”¾å¤§æ˜¾ç¤º
                            const modal = document.createElement('div');
                            modal.style = `
                        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                        background: rgba(0,0,0,0.8); display: flex; align-items: center;
                        justify-content: center; z-index: 1000; cursor: pointer;
                    `;

                            const fullImg = document.createElement('img');
                            fullImg.src = message.data;
                            fullImg.style = 'max-width: 90%; max-height: 90%; object-fit: contain;';

                            modal.appendChild(fullImg);
                            document.body.appendChild(modal);

                            modal.onclick = () => document.body.removeChild(modal);
                        };
                        messageDiv.appendChild(img);
                        break;

                    case 'text':
                        const textDiv = document.createElement('div');
                        // ä½¿ç”¨formatMessageTextæ–¹æ³•å¤„ç†æ–‡æœ¬å†…å®¹ï¼Œä¿ç•™æ¢è¡Œç¬¦
                        textDiv.innerHTML = this.formatMessageText(message.content);
                        messageDiv.appendChild(textDiv);

                        if (message.links && message.links.length > 0) {
                            message.links.forEach(async (link) => {
                                const linkPreview = await this.createLinkPreview(link);
                                messageDiv.appendChild(linkPreview);
                            });
                        }
                        break;

                    default:
                        // æœªçŸ¥ç±»å‹æ¶ˆæ¯
                        messageDiv.textContent = JSON.stringify(message);
                }
            }

            // æ·»åŠ æ—¶é—´æˆ³
            const timestamp = document.createElement('div');
            timestamp.className = 'timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();
            messageDiv.appendChild(timestamp);

            chatBox.appendChild(messageDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
        },
        formatMessageText: function(text) {
            if (!text) return '';

            // è½¬ä¹‰HTMLç‰¹æ®Šå­—ç¬¦ï¼Œé˜²æ­¢XSSæ”»å‡»
            const escaped = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');

            // å°†æ¢è¡Œç¬¦è½¬æ¢ä¸º<br>æ ‡ç­¾
            return escaped.replace(/\n/g, '<br>');
        },
        // é“¾æ¥é¢„è§ˆ
        createLinkPreview: async function (url) {
            const preview = document.createElement('div');
            preview.className = 'link-preview';
            preview.innerHTML = `
            <div class="link-preview-loading">
                <span class="loading-spinner"></span> åŠ è½½é¢„è§ˆä¸­...
            </div>
        `;

            try {
                const previewData = await this.fetchLinkPreview(url);

                if (previewData) {
                    preview.innerHTML = `
                    <div class="link-preview-content">
                        ${previewData.image ?
                        `<img src="${previewData.image}"
                                class="link-preview-image"
                                onerror="this.style.display='none'"
                                alt="${previewData.title || 'é“¾æ¥é¢„è§ˆ'}">`
                        : ''}
                        <div class="link-preview-title">${previewData.title || url}</div>
                        <div class="link-preview-description">${previewData.description || 'æ— æè¿°'}</div>
                        <div class="link-preview-domain">
                            <img src="https://www.google.com/s2/favicons?domain=${previewData.domain}"
                                width="16" height="16" onerror="this.style.display='none'">
                            ${previewData.domain}
                        </div>
                    </div>
                `;
                } else {
                    preview.innerHTML = `
                    <div class="link-preview-content">
                        <div class="link-preview-title">${url}</div>
                        <div class="preview-error">æ— æ³•åŠ è½½é¢„è§ˆ</div>
                    </div>
                `;
                }
            } catch (error) {
                preview.innerHTML = `
                <div class="link-preview-content">
                    <div class="link-preview-title">${url}</div>
                    <div class="preview-error">é¢„è§ˆåŠ è½½å¤±è´¥</div>
                </div>
            `;
            }

            preview.onclick = () => window.open(url, '_blank');
            return preview;
        },

        // è·å–é“¾æ¥é¢„è§ˆ
        fetchLinkPreview: async function (url) {
            try {
                // ä½¿ç”¨ç¬¬ä¸‰æ–¹APIè·å–é“¾æ¥é¢„è§ˆï¼ˆè€ƒè™‘ä¸­å›½ç½‘ç»œæƒ…å†µï¼Œå¯èƒ½éœ€è¦æ›¿æ¢ä¸ºå›½å†…å¯ç”¨çš„æœåŠ¡ï¼‰
                // åœ¨ç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨è‡ªå·±çš„åç«¯æœåŠ¡æ¥ä»£ç†è¯·æ±‚ï¼Œé¿å…APIæœåŠ¡çš„é™åˆ¶
                const proxyUrl = 'https://api.allorigins.win/raw?url=';
                const response = await fetch(`${proxyUrl}${encodeURIComponent(url)}`, {
                    method: 'GET',
                    headers: {'Content-Type': 'text/html'},
                    mode: 'cors',
                    cache: 'force-cache'
                });

                if (!response.ok) throw new Error('æ— æ³•è·å–é“¾æ¥å†…å®¹');

                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // æå–Open Graphæ•°æ®
                const getMetaContent = (name) => {
                    const element = doc.querySelector(`meta[property="og:${name}"], meta[name="${name}"], meta[name="og:${name}"]`);
                    return element ? element.getAttribute('content') : null;
                };

                const title = getMetaContent('title') || doc.title || '';
                const description = getMetaContent('description') || '';
                const image = getMetaContent('image') || '';
                const domain = new URL(url).hostname;

                return {title, description, image, domain};
            } catch (error) {
                Utils.log(`é“¾æ¥é¢„è§ˆè·å–å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);

                // è¿”å›åŸºæœ¬ä¿¡æ¯
                try {
                    const domain = new URL(url).hostname;
                    return {
                        title: url,
                        description: '',
                        image: null,
                        domain: domain
                    };
                } catch (e) {
                    return null;
                }
            }
        },

        // å–æ¶ˆå›¾ç‰‡æ•°æ®
        cancelImageData: function () {
            this.selectedImage = null;
            document.getElementById('imagePreviewContainer').innerHTML = '';
            document.getElementById('fileInput').value = '';
        },

        // å–æ¶ˆéŸ³é¢‘æ•°æ®
        cancelAudioData: function () {
            this.audioData = null;
            this.audioDuration = 0;
            document.getElementById('audioPreviewContainer').innerHTML = '';

            // ç¡®ä¿é‡Šæ”¾åª’ä½“èµ„æº
            MediaManager.releaseAudioResources();
        }
    };

    // åª’ä½“ç®¡ç†å™¨
    const MediaManager = {
        mediaRecorder: null,
        audioChunks: [],
        recordingTimer: null,
        recordingStartTime: null,
        recordingDuration: 0,

        // åˆå§‹åŒ–è¯­éŸ³å½•åˆ¶
        initVoiceRecording: function() {
            // ä¸å†ä¸»åŠ¨è¯·æ±‚éº¦å…‹é£æƒé™ï¼Œè€Œæ˜¯åœ¨æŒ‰ä¸‹å½•éŸ³æŒ‰é’®æ—¶è¯·æ±‚

            // æ£€æŸ¥æ˜¯å¦åœ¨å®‰å…¨ä¸Šä¸‹æ–‡(HTTPS)
            if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                Utils.log('è¯­éŸ³å½•åˆ¶åŠŸèƒ½éœ€è¦HTTPSç¯å¢ƒ', Utils.logLevels.WARN);

                const voiceButton = document.getElementById('voiceButton');
                voiceButton.disabled = true;
                voiceButton.title = 'å½•éŸ³åŠŸèƒ½éœ€è¦HTTPSç¯å¢ƒ';
                voiceButton.innerHTML = '<span id="voiceButtonText">éœ€è¦HTTPS</span>';

                // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
                UIManager.showNotification('è¯­éŸ³å½•åˆ¶åŠŸèƒ½éœ€è¦HTTPSå®‰å…¨ç¯å¢ƒæ‰èƒ½ä½¿ç”¨ï¼Œè¯·ä½¿ç”¨HTTPSè®¿é—®æœ¬é¡µé¢ã€‚', 'warning');
                return;
            }

            // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒgetUserMedia
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                Utils.log('æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½', Utils.logLevels.WARN);

                const voiceButton = document.getElementById('voiceButton');
                voiceButton.disabled = true;
                voiceButton.title = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½';
                voiceButton.innerHTML = '<span id="voiceButtonText">å½•éŸ³ä¸å¯ç”¨</span>';
                return;
            }

            // å¯ç”¨å½•éŸ³æŒ‰é’®ï¼Œä½†å»¶è¿Ÿè¯·æ±‚æƒé™
            document.getElementById('voiceButton').disabled = false;
            Utils.log('è¯­éŸ³å½•åˆ¶æŒ‰é’®å·²å¯ç”¨ï¼Œå°†åœ¨ç”¨æˆ·ç‚¹å‡»æ—¶è¯·æ±‚æƒé™', Utils.logLevels.INFO);
        },
        // æ·»åŠ ä¸€ä¸ªæ–°æ–¹æ³•æ¥è¯·æ±‚éº¦å…‹é£æƒé™
        requestMicrophonePermission: async function() {
            if (this.mediaRecorder) {
                return true; // å·²ç»æœ‰æƒé™äº†
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({audio: true});

                // å°è¯•ä½¿ç”¨æ›´å¥½çš„ç¼–ç æ–¹å¼
                const options = {};

                // å°è¯•ä½¿ç”¨ opus ç¼–ç å™¨
                if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                    options.mimeType = 'audio/webm;codecs=opus';
                } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                    options.mimeType = 'audio/mp4';
                }

                this.mediaRecorder = new MediaRecorder(stream, options);

                this.mediaRecorder.ondataavailable = (event) => {
                    this.audioChunks.push(event.data);
                };

                this.mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(this.audioChunks, {type: options.mimeType || 'audio/webm'});
                    const reader = new FileReader();

                    reader.onloadend = () => {
                        MessageManager.audioData = reader.result;
                        MessageManager.audioDuration = this.recordingDuration;
                        this.displayAudioPreview(reader.result, this.recordingDuration);
                    };

                    reader.readAsDataURL(audioBlob);
                };

                Utils.log('éº¦å…‹é£æƒé™å·²è·å–', Utils.logLevels.INFO);
                return true;
            } catch (error) {
                Utils.log(`è·å–éº¦å…‹é£æƒé™å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);

                const voiceButton = document.getElementById('voiceButton');
                voiceButton.disabled = true;
                voiceButtonText.textContent = 'å½•éŸ³ä¸å¯ç”¨';

                // æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯æç¤º
                UIManager.showNotification('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯­éŸ³å½•åˆ¶åŠŸèƒ½ä¸å¯ç”¨ã€‚', 'error');
                return false;
            }
        },

        // å¼€å§‹å½•éŸ³
        startRecording: async function() {
            // å…ˆè¯·æ±‚æƒé™
            if (!this.mediaRecorder) {
                const permissionGranted = await this.requestMicrophonePermission();
                if (!permissionGranted) return;
            }

            try {
                this.audioChunks = [];
                this.mediaRecorder.start();
                this.recordingStartTime = Date.now();

                const voiceButton = document.getElementById('voiceButton');
                const voiceButtonText = document.getElementById('voiceButtonText');
                const voiceTimer = document.getElementById('voiceTimer');

                voiceButton.classList.add('recording');
                voiceButtonText.textContent = 'åœæ­¢å½•éŸ³';
                voiceTimer.style.display = 'inline';

                this.recordingTimer = setInterval(() => this.updateRecordingTimer(), 1000);
                this.updateRecordingTimer();

                Utils.log('å¼€å§‹å½•éŸ³', Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`å¼€å§‹å½•éŸ³å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
            }
        },

        // åœæ­¢å½•éŸ³
        stopRecording: function () {
            if (!this.mediaRecorder || this.mediaRecorder.state !== 'recording') return;

            try {
                this.mediaRecorder.stop();
                clearInterval(this.recordingTimer);

                const voiceButton = document.getElementById('voiceButton');
                const voiceButtonText = document.getElementById('voiceButtonText');
                const voiceTimer = document.getElementById('voiceTimer');

                voiceButton.classList.remove('recording');
                voiceButtonText.textContent = 'å½•éŸ³';
                voiceTimer.style.display = 'none';

                Utils.log('å½•éŸ³å·²åœæ­¢', Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`åœæ­¢å½•éŸ³å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
            }
        },
        releaseAudioResources: function() {
            // æ£€æŸ¥æ˜¯å¦æœ‰æ´»è·ƒçš„åª’ä½“æµ
            if (this.mediaRecorder && this.mediaRecorder.stream) {
                // åœæ­¢æ‰€æœ‰éŸ³é¢‘è½¨é“
                this.mediaRecorder.stream.getTracks().forEach(track => {
                    track.stop();
                    Utils.log('éº¦å…‹é£èµ„æºå·²é‡Šæ”¾', Utils.logLevels.DEBUG);
                });
            }

            // é‡ç½®å½•éŸ³å™¨
            this.mediaRecorder = null;
        },

        // æ›´æ–°å½•éŸ³è®¡æ—¶å™¨
        updateRecordingTimer: function () {
            const now = Date.now();
            const duration = Math.floor((now - this.recordingStartTime) / 1000);
            this.recordingDuration = duration;

            const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
            const seconds = (duration % 60).toString().padStart(2, '0');
            document.getElementById('voiceTimer').textContent = `${minutes}:${seconds}`;

            // å¦‚æœè¶…è¿‡æœ€å¤§å½•åˆ¶æ—¶é—´ï¼Œè‡ªåŠ¨åœæ­¢
            if (duration >= Config.media.maxAudioDuration) {
                this.stopRecording();
            }
        },

        // å¤„ç†å›¾ç‰‡é€‰æ‹©
        handleImageSelect: async function (event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
                return;
            }

            if (file.size > Config.media.maxImageSize) {
                alert(`å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡ ${Config.media.maxImageSize / 1024 / 1024} MB`);
                return;
            }

            try {
                const reader = new FileReader();

                reader.onload = async (e) => {
                    // å‹ç¼©å›¾ç‰‡
                    const compressedImage = await Utils.compressImage(e.target.result);
                    MessageManager.selectedImage = compressedImage;
                    this.displayImagePreview(compressedImage);
                };

                reader.readAsDataURL(file);
            } catch (error) {
                Utils.log(`å¤„ç†å›¾ç‰‡å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                alert('å¤„ç†å›¾ç‰‡å¤±è´¥');
            }
        },

        // æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆ
        displayImagePreview: function (dataUrl) {
            const container = document.getElementById('imagePreviewContainer');
            container.innerHTML = `
            <div style="position: relative; display: inline-block;">
                <img src="${dataUrl}" class="image-preview">
                <button onclick="MessageManager.cancelImageData()">å–æ¶ˆ</button>
            </div>
        `;
        },

        // æ˜¾ç¤ºéŸ³é¢‘é¢„è§ˆ
        displayAudioPreview: function (audioData, duration) {
            const container = document.getElementById('audioPreviewContainer');
            const formattedDuration = Utils.formatTime(duration);

            container.innerHTML = `
            <div class="voice-message">
                <button onclick="event.stopPropagation(); MediaManager.playAudio(this)" data-audio="${audioData}">
                    æ’­æ”¾
                </button>
                <div class="voice-wave">
                    ${Array(5).fill('<div class="wave-bar"></div>').join('')}
                </div>
                <span class="duration">${formattedDuration}</span>
                <button onclick="MessageManager.cancelAudioData()">å–æ¶ˆ</button>
            </div>
            `;

            // éŸ³é¢‘æ•°æ®å·²ä¿å­˜ï¼Œå¯ä»¥é‡Šæ”¾éº¦å…‹é£èµ„æº
            this.releaseAudioResources();
        },

        // æ’­æ”¾éŸ³é¢‘
        playAudio: function (button) {
            const audio = new Audio(button.dataset.audio);
            const originalText = button.textContent;

            button.textContent = 'æ’­æ”¾ä¸­...';
            audio.play();

            // æ·»åŠ æ³¢å½¢åŠ¨ç”»æ•ˆæœ
            const waveContainer = button.nextElementSibling;
            if (waveContainer && waveContainer.classList.contains('voice-wave')) {
                waveContainer.classList.add('playing');
            }

            audio.onended = () => {
                button.textContent = originalText;
                if (waveContainer) {
                    waveContainer.classList.remove('playing');
                }
            };

            audio.onerror = () => {
                button.textContent = 'æ’­æ”¾å¤±è´¥';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            };
        }
    };

    // è§†é¢‘é€šè¯ç®¡ç†å™¨
    const VideoCallManager = {
        localStream: null,
        remoteStream: null,
        localVideo: null,
        remoteVideo: null,
        peerConnection: null,
        isCallActive: false,
        isCaller: false,
        isCallPending: false,
        isAudioMuted: false,
        isVideoEnabled: true,
        callRequestTimeout: null,

        // åˆå§‹åŒ–
        init: function() {
            this.localVideo = document.getElementById('localVideo');
            this.remoteVideo = document.getElementById('remoteVideo');

            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                Utils.log('æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘é€šè¯åŠŸèƒ½', Utils.logLevels.ERROR);
                document.getElementById('videoCallButton').disabled = true;
                document.getElementById('videoCallButton').title = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘é€šè¯';
                return false;
            }

            // ç›‘å¬è§†é¢‘é€šè¯æ¶ˆæ¯
            EventEmitter.on('dataChannelOpen', () => {
                document.getElementById('videoCallButton').disabled = false;
            });

            return true;
        },

        // å‘èµ·è§†é¢‘é€šè¯
        initiateCall: async function() {
            if (this.isCallActive || this.isCallPending) return;

            try {
                this.isCaller = true;
                this.isCallPending = true;

                // å‘ŠçŸ¥å¯¹æ–¹è¯·æ±‚è§†é¢‘é€šè¯
                const callRequest = {
                    type: 'video-call-request',
                    timestamp: Date.now()
                };

                ConnectionManager.dataChannel.send(JSON.stringify(callRequest));

                UIManager.showNotification('ç­‰å¾…å¯¹æ–¹æ¥å—è§†é¢‘é€šè¯...', 'info');
                Utils.log('å·²å‘é€è§†é¢‘é€šè¯è¯·æ±‚', Utils.logLevels.INFO);

                // 30ç§’è¶…æ—¶
                this.callRequestTimeout = setTimeout(() => {
                    if (this.isCallPending) {
                        this.isCallPending = false;
                        this.isCaller = false;
                        UIManager.showNotification('å¯¹æ–¹æœªåº”ç­”ï¼Œé€šè¯è¯·æ±‚å·²å–æ¶ˆ', 'warning');

                        // å‘é€å–æ¶ˆæ¶ˆæ¯
                        const cancelRequest = {
                            type: 'video-call-cancel',
                            timestamp: Date.now()
                        };
                        ConnectionManager.dataChannel.send(JSON.stringify(cancelRequest));
                    }
                }, 30000);
            } catch (error) {
                Utils.log(`å‘èµ·é€šè¯å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.showNotification('å‘èµ·è§†é¢‘é€šè¯å¤±è´¥', 'error');
                this.isCallPending = false;
                this.isCaller = false;
            }
        },

        // æ˜¾ç¤ºé€šè¯è¯·æ±‚
        showCallRequest: function() {
            document.getElementById('videoCallRequest').style.display = 'flex';
        },

        // éšè—é€šè¯è¯·æ±‚
        hideCallRequest: function() {
            document.getElementById('videoCallRequest').style.display = 'none';
        },

        // æ¥å—é€šè¯
        acceptCall: async function() {
            this.hideCallRequest();

            try {
                // æ˜¾ç¤ºè·å–åª’ä½“è®¾å¤‡æƒé™çš„æç¤º
                UIManager.showNotification('æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™...', 'info');

                // è·å–æ‘„åƒå¤´æƒé™
                this.localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });

                // æ˜¾ç¤ºæœ¬åœ°è§†é¢‘
                this.localVideo.srcObject = this.localStream;

                // åˆ›å»ºWebRTCè¿æ¥
                this.setupPeerConnection();

                // æ˜¾ç¤ºè§†é¢‘é€šè¯ç•Œé¢
                document.getElementById('videoCallContainer').style.display = 'flex';

                // å‘é€æ¥å—ä¿¡å·
                const acceptMessage = {
                    type: 'video-call-accepted',
                    timestamp: Date.now()
                };
                ConnectionManager.dataChannel.send(JSON.stringify(acceptMessage));

                this.isCallActive = true;
                this.isCallPending = false;

                Utils.log('å·²æ¥å—è§†é¢‘é€šè¯', Utils.logLevels.INFO);
            } catch (error) {
                Utils.log(`æ¥å—é€šè¯å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.showNotification('æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–éº¦å…‹é£', 'error');

                // å‘é€æ‹’ç»æ¶ˆæ¯ï¼Œæ ‡æ˜åŸå› æ˜¯è®¾å¤‡é—®é¢˜
                const rejectMessage = {
                    type: 'video-call-rejected',
                    reason: 'device_error',
                    timestamp: Date.now()
                };
                ConnectionManager.dataChannel.send(JSON.stringify(rejectMessage));
            }
        },

        // æ‹’ç»é€šè¯
        rejectCall: function() {
            this.hideCallRequest();

            // å‘é€æ‹’ç»æ¶ˆæ¯
            const rejectMessage = {
                type: 'video-call-rejected',
                reason: 'user_rejected',
                timestamp: Date.now()
            };
            ConnectionManager.dataChannel.send(JSON.stringify(rejectMessage));

            // é‡ç½®çŠ¶æ€
            this.isCallPending = false;
            this.isCallActive = false;
            this.isCaller = false;

            Utils.log('å·²æ‹’ç»è§†é¢‘é€šè¯', Utils.logLevels.INFO);
        },

        // è®¾ç½®å¯¹ç­‰è¿æ¥
        setupPeerConnection: function() {
            // ä½¿ç”¨å·²æœ‰çš„è¿æ¥ä¼ é€’ä¿¡ä»¤
            if (!ConnectionManager.peerConnection) {
                Utils.log('æ— æ³•åˆ›å»ºè§†é¢‘é€šè¯è¿æ¥: æ²¡æœ‰åŸºç¡€è¿æ¥', Utils.logLevels.ERROR);
                return;
            }

            this.peerConnection = ConnectionManager.peerConnection;

            // æ·»åŠ æœ¬åœ°æµ
            this.localStream.getTracks().forEach(track => {
                this.peerConnection.addTrack(track, this.localStream);
            });

            // å¤„ç†è¿œç¨‹æµ
            this.peerConnection.ontrack = (event) => {
                if (event.streams && event.streams[0]) {
                    this.remoteVideo.srcObject = event.streams[0];
                    this.remoteStream = event.streams[0];
                    Utils.log('æ”¶åˆ°è¿œç¨‹è§†é¢‘æµ', Utils.logLevels.INFO);
                }
            };

            // å¦‚æœæ˜¯å‘¼å«æ–¹ï¼Œåˆ›å»ºå¹¶å‘é€offer
            if (this.isCaller) {
                this.createAndSendOffer();
            }
        },

        // åˆ›å»ºå¹¶å‘é€offer
        createAndSendOffer: async function() {
            try {
                const offer = await this.peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });

                await this.peerConnection.setLocalDescription(offer);

                // å‘é€offerç»™å¯¹æ–¹
                const offerMessage = {
                    type: 'video-call-offer',
                    sdp: this.peerConnection.localDescription
                };
                ConnectionManager.dataChannel.send(JSON.stringify(offerMessage));

                Utils.log('å·²å‘é€è§†é¢‘é€šè¯offer', Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`åˆ›å»ºofferå¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                this.endCall();
            }
        },

        // å¤„ç†æ”¶åˆ°çš„offer
        handleOffer: async function(offer) {
            try {
                if (!this.peerConnection) {
                    this.setupPeerConnection();
                }

                await this.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

                // åˆ›å»ºanswer
                const answer = await this.peerConnection.createAnswer();
                await this.peerConnection.setLocalDescription(answer);

                // å‘é€answerç»™å¯¹æ–¹
                const answerMessage = {
                    type: 'video-call-answer',
                    sdp: this.peerConnection.localDescription
                };
                ConnectionManager.dataChannel.send(JSON.stringify(answerMessage));

                Utils.log('å·²å›å¤è§†é¢‘é€šè¯answer', Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`å¤„ç†offerå¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                this.endCall();
            }
        },

        // å¤„ç†æ”¶åˆ°çš„answer
        handleAnswer: async function(answer) {
            try {
                await this.peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                Utils.log('å·²è®¾ç½®è¿œç¨‹æè¿°', Utils.logLevels.DEBUG);
            } catch (error) {
                Utils.log(`å¤„ç†answerå¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                this.endCall();
            }
        },

        // åˆ‡æ¢æ‘„åƒå¤´
        toggleCamera: function() {
            if (!this.localStream) return;

            const videoTrack = this.localStream.getVideoTracks()[0];
            if (videoTrack) {
                this.isVideoEnabled = !this.isVideoEnabled;
                videoTrack.enabled = this.isVideoEnabled;

                const button = document.getElementById('toggleCameraBtn');
                button.innerHTML = this.isVideoEnabled ? 'ğŸ“¹' : 'ğŸš«';
                button.style.background = this.isVideoEnabled ? '#fff' : '#666';

                Utils.log(`æ‘„åƒå¤´å·²${this.isVideoEnabled ? 'å¼€å¯' : 'å…³é—­'}`, Utils.logLevels.DEBUG);
            }
        },

        // åˆ‡æ¢éº¦å…‹é£
        toggleAudio: function() {
            if (!this.localStream) return;

            const audioTrack = this.localStream.getAudioTracks()[0];
            if (audioTrack) {
                this.isAudioMuted = !this.isAudioMuted;
                audioTrack.enabled = !this.isAudioMuted;

                const button = document.getElementById('toggleAudioBtn');
                button.innerHTML = this.isAudioMuted ? 'ğŸ”‡' : 'ğŸ¤';
                button.style.background = this.isAudioMuted ? '#666' : '#fff';

                Utils.log(`éº¦å…‹é£å·²${this.isAudioMuted ? 'é™éŸ³' : 'å¼€å¯'}`, Utils.logLevels.DEBUG);
            }
        },

        // ç»“æŸé€šè¯
        endCall: function() {
            // æ¸…é™¤è¶…æ—¶å®šæ—¶å™¨
            if (this.callRequestTimeout) {
                clearTimeout(this.callRequestTimeout);
                this.callRequestTimeout = null;
            }

            // å‘é€ç»“æŸé€šè¯ä¿¡å·
            if (this.isCallActive || this.isCallPending) {
                const endCallMessage = {
                    type: 'video-call-end',
                    timestamp: Date.now()
                };
                try {
                    if (ConnectionManager.dataChannel &&
                        ConnectionManager.dataChannel.readyState === 'open') {
                        ConnectionManager.dataChannel.send(JSON.stringify(endCallMessage));
                    }
                } catch (error) {
                    Utils.log(`å‘é€ç»“æŸé€šè¯æ¶ˆæ¯å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                }
            }

            // å½»åº•å…³é—­å¹¶åœæ­¢æ‰€æœ‰åª’ä½“è½¨é“
            this.releaseMediaResources();

            // é‡ç½®è§†é¢‘å…ƒç´ 
            if (this.localVideo) this.localVideo.srcObject = null;
            if (this.remoteVideo) this.remoteVideo.srcObject = null;
            this.remoteStream = null;

            // éšè—è§†é¢‘é€šè¯ç•Œé¢
            document.getElementById('videoCallContainer').style.display = 'none';
            this.hideCallRequest();

            // é‡ç½®çŠ¶æ€
            this.isCallActive = false;
            this.isCallPending = false;
            this.isCaller = false;
            this.isAudioMuted = false;
            this.isVideoEnabled = true;

            Utils.log('è§†é¢‘é€šè¯å·²ç»“æŸï¼Œæ‰€æœ‰èµ„æºå·²é‡Šæ”¾', Utils.logLevels.INFO);
        },

        // æ·»åŠ ä¸€ä¸ªæ–°æ–¹æ³•ä¸“é—¨è´Ÿè´£é‡Šæ”¾åª’ä½“èµ„æº
        releaseMediaResources: function() {
            // å…³é—­æœ¬åœ°è§†é¢‘/éŸ³é¢‘è½¨é“
            if (this.localStream) {
                this.localStream.getTracks().forEach(track => {
                    track.stop();
                    Utils.log(`å·²åœæ­¢${track.kind}è½¨é“`, Utils.logLevels.DEBUG);
                });
                this.localStream = null;
            }

            // å¦‚æœæœ‰è¿œç¨‹æµï¼Œä¹Ÿå¯ä»¥è€ƒè™‘æ¸…ç†
            if (this.remoteStream) {
                // æˆ‘ä»¬ä¸éœ€è¦åœæ­¢è¿œç¨‹è½¨é“ï¼Œä½†å¯ä»¥æ¸…é™¤å¼•ç”¨
                this.remoteStream = null;
            }
        },

        // å¤„ç†æ¶ˆæ¯
        handleMessage: function(message) {
            switch (message.type) {
                case 'video-call-request':
                    if (!this.isCallActive && !this.isCallPending) {
                        this.isCallPending = true;
                        this.showCallRequest();
                        Utils.log('æ”¶åˆ°è§†é¢‘é€šè¯è¯·æ±‚', Utils.logLevels.INFO);
                    } else {
                        // å·²åœ¨é€šè¯ä¸­ï¼Œè‡ªåŠ¨æ‹’ç»
                        const busyMessage = {
                            type: 'video-call-rejected',
                            reason: 'busy',
                            timestamp: Date.now()
                        };
                        ConnectionManager.dataChannel.send(JSON.stringify(busyMessage));
                    }
                    break;

                case 'video-call-accepted':
                    if (this.isCallPending && this.isCaller) {
                        clearTimeout(this.callRequestTimeout);
                        this.callRequestTimeout = null;

                        // å¯¹æ–¹å·²æ¥å—ï¼Œå¼€å§‹é€šè¯
                        this.startLocalStream();
                    }
                    break;

                case 'video-call-rejected':
                    if (this.isCallPending) {
                        clearTimeout(this.callRequestTimeout);
                        this.callRequestTimeout = null;
                        this.isCallPending = false;
                        this.isCaller = false;

                        // é‡Šæ”¾å·²ç”³è¯·çš„ä»»ä½•åª’ä½“èµ„æº
                        this.releaseMediaResources();

                        let reason = 'å¯¹æ–¹æ‹’ç»äº†è§†é¢‘é€šè¯';
                        if (message.reason === 'busy') {
                            reason = 'å¯¹æ–¹æ­£å¿™';
                        } else if (message.reason === 'device_error') {
                            reason = 'å¯¹æ–¹æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–éº¦å…‹é£';
                        }

                        UIManager.showNotification(reason, 'warning');
                        Utils.log(`è§†é¢‘é€šè¯è¢«æ‹’ç»: ${message.reason}`, Utils.logLevels.INFO);
                    }
                    break;

                case 'video-call-cancel':
                    if (this.isCallPending && !this.isCaller) {
                        this.isCallPending = false;
                        this.hideCallRequest();

                        // é‡Šæ”¾å·²ç”³è¯·çš„ä»»ä½•åª’ä½“èµ„æº
                        this.releaseMediaResources();

                        Utils.log('å¯¹æ–¹å–æ¶ˆäº†è§†é¢‘é€šè¯è¯·æ±‚', Utils.logLevels.INFO);
                    }
                    break;

                case 'video-call-offer':
                    if (this.isCallActive && !this.isCaller) {
                        this.handleOffer(message.sdp);
                    }
                    break;

                case 'video-call-answer':
                    if (this.isCallActive && this.isCaller) {
                        this.handleAnswer(message.sdp);
                    }
                    break;

                case 'video-call-end':
                    if (this.isCallActive || this.isCallPending) {
                        this.endCall();
                        UIManager.showNotification('å¯¹æ–¹ç»“æŸäº†é€šè¯', 'info');
                    }
                    break;
            }
        },

        // å¼€å§‹æœ¬åœ°æµ
        startLocalStream: async function() {
            try {
                // åªæœ‰åœ¨è¿˜æ²¡æœ‰æœ¬åœ°æµæ—¶æ‰è¯·æ±‚æ‘„åƒå¤´æƒé™
                if (!this.localStream) {
                    // æ˜¾ç¤ºè·å–åª’ä½“è®¾å¤‡æƒé™çš„æç¤º
                    UIManager.showNotification('æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™...', 'info');

                    // è·å–æ‘„åƒå¤´æƒé™
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: true
                    });

                    // æ˜¾ç¤ºæœ¬åœ°è§†é¢‘
                    this.localVideo.srcObject = this.localStream;
                }

                // åˆ›å»ºWebRTCè¿æ¥
                this.setupPeerConnection();

                // æ˜¾ç¤ºè§†é¢‘é€šè¯ç•Œé¢
                document.getElementById('videoCallContainer').style.display = 'flex';

                this.isCallActive = true;
                this.isCallPending = false;

                Utils.log('è§†é¢‘é€šè¯å·²å¼€å§‹', Utils.logLevels.INFO);
            } catch (error) {
                Utils.log(`å¯åŠ¨æœ¬åœ°è§†é¢‘å¤±è´¥: ${error.message}`, Utils.logLevels.ERROR);
                UIManager.showNotification('æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–éº¦å…‹é£', 'error');
                this.endCall();
            }
        }
    };

    // åˆå§‹åŒ–åº”ç”¨
    const AppInitializer = {
        init: function () {
            // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
            if (!UIManager.checkWebRTCSupport()) return;

            // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
            this.checkNetworkType();

            // æ·»åŠ ç½‘ç»œçŠ¶æ€ç›‘å¬
            this.startNetworkMonitoring();

            // åˆå§‹åŒ–è¯­éŸ³å½•åˆ¶æŒ‰é’®ï¼ˆä½†ä¸ç”³è¯·æƒé™ï¼‰
            MediaManager.initVoiceRecording();

            // åˆå§‹åŒ–è§†é¢‘é€šè¯æŒ‰é’®ï¼ˆä½†ä¸ç”³è¯·æƒé™ï¼‰
            VideoCallManager.init();

            // æ·»åŠ æŒ‰é’®äº‹ä»¶å¤„ç†ç¨‹åº
            this.setupEventListeners();

            // åˆå§‹åŒ–ç§»åŠ¨ç«¯UI
            this.initMobileUI();

            Utils.log('åº”ç”¨å·²åˆå§‹åŒ–', Utils.logLevels.INFO);
        },

        // åˆå§‹åŒ–ç§»åŠ¨ç«¯UI
        initMobileUI: function() {
            // æ·»åŠ è¿”å›è®¾ç½®æŒ‰é’®äº‹ä»¶
            const backButton = document.getElementById('backToSettings');
            if (backButton) {
                backButton.addEventListener('click', function() {
                    document.querySelector('.container').classList.remove('connected-mode');
                });
            }

            // æ·»åŠ è¿›å…¥èŠå¤©æŒ‰é’®äº‹ä»¶
            const backToChatBtn = document.getElementById('backToChatBtn');
            if (backToChatBtn) {
                backToChatBtn.addEventListener('click', function() {
                    // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥
                    const isConnected = document.getElementById('connectionStatus').classList.contains('connected');
                    if (isConnected) {
                        document.querySelector('.container').classList.add('connected-mode');
                    } else {
                        UIManager.showNotification('è¯·å…ˆå»ºç«‹è¿æ¥', 'warning');
                    }
                });
            }

            // å“åº”å±å¹•å°ºå¯¸å˜åŒ–
            window.addEventListener('resize', function() {
                const container = document.querySelector('.container');
                const isConnected = document.getElementById('connectionStatus').classList.contains('connected');
                const sidebar = document.querySelector('.sidebar');
                const backToChatBtn = document.getElementById('backToChatBtn');

                // å¦‚æœæ˜¯ç§»åŠ¨ç«¯ä¸”å·²è¿æ¥ï¼Œä¿æŒèŠå¤©ç•Œé¢æ˜¾ç¤º
                if (window.innerWidth <= 768 && isConnected) {
                    // æ˜¾ç¤ºè¿›å…¥èŠå¤©æŒ‰é’®
                    if (backToChatBtn) backToChatBtn.style.display = 'block';
                    if (sidebar) sidebar.classList.add('show-back-btn');
                } else if (window.innerWidth > 768) {
                    // åœ¨å¤§å±å¹•ä¸Šï¼Œç§»é™¤è¿æ¥æ¨¡å¼ç±»ï¼Œæ˜¾ç¤ºä¸¤ä¸ªé¢æ¿
                    container.classList.remove('connected-mode');
                }
            });
        },

        // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
        checkNetworkType: async function () {
            const networkInfo = document.getElementById('networkInfo');
            networkInfo.innerHTML = '<span class="loading-spinner"></span> æ­£åœ¨æ£€æµ‹ç½‘ç»œ...';

            try {
                const networkType = await Utils.checkNetworkType();

                if (networkType) {
                    let networkHtml = `
                    ç½‘ç»œæ”¯æŒ:<br>
                    IPv4: ${networkType.ipv4 ? 'âœ“' : 'âœ—'}<br>
                    IPv6: ${networkType.ipv6 ? 'âœ“' : 'âœ—'}<br>
                    UDP: ${networkType.udp ? 'âœ“' : 'âœ—'}<br>
                    TCP: ${networkType.tcp ? 'âœ“' : 'âœ—'}<br>
                    ä¸­ç»§: ${networkType.relay ? 'å¯ç”¨' : 'æœªæ£€æµ‹åˆ°'}<br>
                    å€™é€‰æ•°: ${networkType.count}
                `;

                    // æ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´é…ç½®
                    if (!networkType.udp && networkType.tcp) {
                        Config.peerConnectionConfig.iceTransportPolicy = 'relay';
                        networkHtml += '<br><b>å·²åˆ‡æ¢åˆ°ä¸­ç»§ä¼˜å…ˆæ¨¡å¼</b>';
                    }

                    networkInfo.innerHTML = networkHtml;

                    const qualityIndicator = document.getElementById('qualityIndicator');
                    if (qualityIndicator) {
                        if (networkType.udp) {
                            qualityIndicator.className = 'quality-indicator quality-good';
                            document.getElementById('qualityText').textContent = 'ç½‘ç»œè‰¯å¥½';
                        } else if (networkType.tcp) {
                            qualityIndicator.className = 'quality-indicator quality-medium';
                            document.getElementById('qualityText').textContent = 'ç½‘ç»œå—é™';
                        } else {
                            qualityIndicator.className = 'quality-indicator quality-poor';
                            document.getElementById('qualityText').textContent = 'ç½‘ç»œå—é˜»';
                        }
                    }
                } else {
                    networkInfo.innerHTML = 'ç½‘ç»œæ£€æµ‹å¤±è´¥';
                }
            } catch (error) {
                networkInfo.innerHTML = 'ç½‘ç»œæ£€æµ‹å¤±è´¥: ' + error.message;
            }
        },

        // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ–
        startNetworkMonitoring: function () {
            window.addEventListener('online', this.handleNetworkChange.bind(this));
            window.addEventListener('offline', this.handleNetworkChange.bind(this));
        },

        // å¤„ç†ç½‘ç»œå˜åŒ–
        handleNetworkChange: function () {
            if (navigator.onLine) {
                UIManager.updateStatus('ç½‘ç»œå·²æ¢å¤ï¼Œå°è¯•é‡æ–°è¿æ¥...');
                if (ConnectionManager.peerConnection &&
                    ConnectionManager.peerConnection.iceConnectionState !== 'connected') {
                    ConnectionManager.restartIce();
                }
            } else {
                UIManager.updateStatus('ç½‘ç»œå·²æ–­å¼€');
            }
        },

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        setupEventListeners: function () {
            // æ¶ˆæ¯è¾“å…¥æ¡†å›è½¦å‘é€
            document.getElementById('messageInput').addEventListener('keydown', (e) => {
                // å¦‚æœæ˜¯ Ctrl+Enter ç»„åˆé”®ï¼Œåˆ™å‘é€æ¶ˆæ¯
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    MessageManager.sendMessage();
                }
                // ä»…æŒ‰å›è½¦é”®æ—¶ï¼Œå…è®¸æ¢è¡Œ
                else if (e.key === 'Enter' && !e.ctrlKey) {
                    // ä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå…è®¸è¾“å…¥æ¢è¡Œç¬¦

                    // å¯é€‰ï¼šå¦‚æœæƒ³åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šæœ‰æ›´å¥½çš„ä½“éªŒï¼Œå¯ä»¥æ‰‹åŠ¨æ’å…¥æ¢è¡Œç¬¦
                    // å› ä¸ºæœ‰äº›ç§»åŠ¨æµè§ˆå™¨çš„æ–‡æœ¬åŒºåŸŸè¡Œä¸ºä¸ä¸€è‡´
                    /*
                    e.preventDefault();
                    const input = document.getElementById('messageInput');
                    const cursorPosition = input.selectionStart;
                    const textBeforeCursor = input.value.substring(0, cursorPosition);
                    const textAfterCursor = input.value.substring(cursorPosition);
                    input.value = textBeforeCursor + '\n' + textAfterCursor;
                    input.selectionStart = input.selectionEnd = cursorPosition + 1;
                    */
                }
            });


            // æ·»åŠ æ–­å¼€è¿æ¥äº‹ä»¶å¤„ç†
            EventEmitter.on('connectionDisconnected', function() {
                // ç§»åŠ¨ç«¯ï¼šæ–­å¼€è¿æ¥æ—¶åˆ‡æ¢å›è®¾ç½®ç•Œé¢
                if (window.innerWidth <= 768) {
                    document.querySelector('.container').classList.remove('connected-mode');
                }
            });

            EventEmitter.on('connectionFailed', function() {
                // ç§»åŠ¨ç«¯ï¼šè¿æ¥å¤±è´¥æ—¶åˆ‡æ¢å›è®¾ç½®ç•Œé¢
                if (window.innerWidth <= 768) {
                    document.querySelector('.container').classList.remove('connected-mode');
                }
            });


            // è¯­éŸ³å½•åˆ¶æŒ‰é’®äº‹ä»¶
            const voiceButton = document.getElementById('voiceButton');

            // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
            if ('ontouchstart' in window) {
                // ç§»åŠ¨è®¾å¤‡ä½¿ç”¨è§¦æ‘¸äº‹ä»¶
                voiceButton.addEventListener('touchstart', function (e) {
                    e.preventDefault();
                    MediaManager.startRecording();
                });

                voiceButton.addEventListener('touchend', function (e) {
                    e.preventDefault();
                    MediaManager.stopRecording();
                });
            } else {
                // æ¡Œé¢è®¾å¤‡ä½¿ç”¨é¼ æ ‡äº‹ä»¶
                voiceButton.addEventListener('mousedown', MediaManager.startRecording.bind(MediaManager));
                voiceButton.addEventListener('mouseup', MediaManager.stopRecording.bind(MediaManager));
                voiceButton.addEventListener('mouseleave', MediaManager.stopRecording.bind(MediaManager));
            }

            // æ·»åŠ å…¨å±€é”™è¯¯å¤„ç†
            window.addEventListener('error', (event) => {
                Utils.log(`åº”ç”¨é”™è¯¯: ${event.message}`, Utils.logLevels.ERROR);
            });

            // æ·»åŠ æ–­å¼€è¿æ¥å‰çš„æç¤º
            window.addEventListener('beforeunload', () => {
                // é‡Šæ”¾è¯­éŸ³å½•åˆ¶èµ„æº
                MediaManager.releaseAudioResources();

                // é‡Šæ”¾è§†é¢‘é€šè¯èµ„æº
                VideoCallManager.releaseMediaResources();

                // å…³é—­æ‰€æœ‰è¿æ¥
                if (ConnectionManager.peerConnection) {
                    ConnectionManager.close();
                }
            });
        }
    };

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    window.addEventListener('load', AppInitializer.init.bind(AppInitializer));
</script>
</html>